<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java细知识 | 我的博客</title>
<meta name=keywords content="Java"><meta name=description content='单元测试 单元测试：针对最小的功能单元编写测试代码
Java程序最小的功能单元是方法，对Java程序进行单元测试就是针对单个方法测试
测试驱动开发
先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码 举例子
public class Factorial { public static long fact(long n) { long r = 1; for (long i = 1; i <= n; i++) { r = r * i; } return r; } } 测试这方法，一个很自然的想法是编写一个main()方法，然后运行一些测试代码：
public class Test { public static void main(String[] args) { if (fact(10) == 3628800) { System.out.println("pass"); } else { System.out.println("fail"); } } } 只能有一个main()方法，不能把测试代码分离 是没有打印出测试结果和期望结果，例如，expected: 3628800, but actual: 123456 很难编写一组通用的测试代码 编写JUnit测试 JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计'><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/java03/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/java03/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Java细知识"><meta property="og:description" content='单元测试 单元测试：针对最小的功能单元编写测试代码
Java程序最小的功能单元是方法，对Java程序进行单元测试就是针对单个方法测试
测试驱动开发
先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码 举例子
public class Factorial { public static long fact(long n) { long r = 1; for (long i = 1; i <= n; i++) { r = r * i; } return r; } } 测试这方法，一个很自然的想法是编写一个main()方法，然后运行一些测试代码：
public class Test { public static void main(String[] args) { if (fact(10) == 3628800) { System.out.println("pass"); } else { System.out.println("fail"); } } } 只能有一个main()方法，不能把测试代码分离 是没有打印出测试结果和期望结果，例如，expected: 3628800, but actual: 123456 很难编写一组通用的测试代码 编写JUnit测试 JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计'><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/java03/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-22T22:06:05+08:00"><meta property="article:modified_time" content="2025-01-22T22:06:05+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java细知识"><meta name=twitter:description content='单元测试 单元测试：针对最小的功能单元编写测试代码
Java程序最小的功能单元是方法，对Java程序进行单元测试就是针对单个方法测试
测试驱动开发
先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码 举例子
public class Factorial { public static long fact(long n) { long r = 1; for (long i = 1; i <= n; i++) { r = r * i; } return r; } } 测试这方法，一个很自然的想法是编写一个main()方法，然后运行一些测试代码：
public class Test { public static void main(String[] args) { if (fact(10) == 3628800) { System.out.println("pass"); } else { System.out.println("fail"); } } } 只能有一个main()方法，不能把测试代码分离 是没有打印出测试结果和期望结果，例如，expected: 3628800, but actual: 123456 很难编写一组通用的测试代码 编写JUnit测试 JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Java细知识","item":"https://zwlzls.github.io/posts/java03/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java细知识","name":"Java细知识","description":"单元测试 单元测试：针对最小的功能单元编写测试代码\nJava程序最小的功能单元是方法，对Java程序进行单元测试就是针对单个方法测试\n测试驱动开发\n先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码 举例子\npublic class Factorial { public static long fact(long n) { long r = 1; for (long i = 1; i \u0026lt;= n; i++) { r = r * i; } return r; } } 测试这方法，一个很自然的想法是编写一个main()方法，然后运行一些测试代码：\npublic class Test { public static void main(String[] args) { if (fact(10) == 3628800) { System.out.println(\u0026#34;pass\u0026#34;); } else { System.out.println(\u0026#34;fail\u0026#34;); } } } 只能有一个main()方法，不能把测试代码分离 是没有打印出测试结果和期望结果，例如，expected: 3628800, but actual: 123456 很难编写一组通用的测试代码 编写JUnit测试 JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计","keywords":["Java"],"articleBody":"单元测试 单元测试：针对最小的功能单元编写测试代码\nJava程序最小的功能单元是方法，对Java程序进行单元测试就是针对单个方法测试\n测试驱动开发\n先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码 举例子\npublic class Factorial { public static long fact(long n) { long r = 1; for (long i = 1; i \u003c= n; i++) { r = r * i; } return r; } } 测试这方法，一个很自然的想法是编写一个main()方法，然后运行一些测试代码：\npublic class Test { public static void main(String[] args) { if (fact(10) == 3628800) { System.out.println(\"pass\"); } else { System.out.println(\"fail\"); } } } 只能有一个main()方法，不能把测试代码分离 是没有打印出测试结果和期望结果，例如，expected: 3628800, but actual: 123456 很难编写一组通用的测试代码 编写JUnit测试 JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计\n好处： 可以非常简单地组织测试代码，并随时运行它们 给出成功的测试和失败的测试，还可以生成测试报告 使用操作\npackage com.itranswarp.learnjava; import static org.junit.jupiter.api.Assertions.*; import org.junit.jupiter.api.Test; public class FactorialTest { @Test void testFact() { assertEquals(1, Factorial.fact(1)); assertEquals(2, Factorial.fact(2)); assertEquals(6, Factorial.fact(3)); assertEquals(3628800, Factorial.fact(10)); assertEquals(2432902008176640000L, Factorial.fact(20)); } } 还有其他断言操作，以下错误结果\norg.opentest4j.AssertionFailedError: expected: \u003c3628800\u003e but was: \u003c362880\u003e at org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:55) at org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:195) at org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:168) at org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:163) at org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:611) at com.itranswarp.learnjava.FactorialTest.testFact(FactorialTest.java:14) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at ... 失败信息的意思是期待结果3628800但是实际返回是362880，此时，我们要么修正实现代码，要么修正测试代码，直到测试通过为止\n单元测试规范：\n一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试； 二是每个单元测试应当互相独立，不依赖运行的顺序； 三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为0，null，空字符串\"\"等情况 使用Fixture 一个单元测试中，我们经常编写多个@Test方法，来分组、分类对目标代码进行测试 测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况\nJUnit提供了编写测试前准备、测试后清理的固定代码：：Fixture\n举例子\n一个具体的Calculator的例子：\npublic class Calculator { private long n = 0; public long add(long x) { n = n + x; return n; } public long sub(long x) { n = n - x; return n; } } 测试的时候，我们要先初始化对象，我们不必在每个测试方法中都写上初始化代码，而是通过@BeforeEach来初始化，通过@AfterEach来清理资源\npublic class CalculatorTest { Calculator calculator; @BeforeEach public void setUp() { this.calculator = new Calculator(); } @AfterEach public void tearDown() { this.calculator = null; } @Test void testAdd() { assertEquals(100, this.calculator.add(100)); assertEquals(150, this.calculator.add(50)); assertEquals(130, this.calculator.add(-20)); } @Test void testSub() { assertEquals(-100, this.calculator.sub(100)); assertEquals(-150, this.calculator.sub(50)); assertEquals(-130, this.calculator.sub(-20)); } } CalculatorTest测试中，有两个标记为@BeforeEach和@AfterEach的方法，它们会在运行每个@Test方法前后自动运行\n**细节：**测试代码在JUnit中运行顺序如下：\ninvokeBeforeAll(CalculatorTest.class); for (Method testMethod : findTestMethods(CalculatorTest.class)) { var test = new CalculatorTest(); // 创建Test实例 invokeBeforeEach(test); invokeTestMethod(test, testMethod); invokeAfterEach(test); } invokeAfterAll(CalculatorTest.class); 一些资源初始化和清理可能更加繁琐，而且会耗费较长的时间，例如初始化数据库。JUnit还提供了@BeforeAll和@AfterAll\n@BeforeAll和@AfterAll在所有@Test方法运行前后仅运行一次，因此，它们只能初始化静态变量，例如：\npublic class DatabaseTest { static Database db; @BeforeAll public static void initDatabase() { db = createDb(...); } @AfterAll public static void dropDatabase() { ... } } 总结使用\n对于实例变量，在@BeforeEach中初始化，在@AfterEach中清理，它们在各个@Test方法中互不影响，因为是不同的实例 对于静态变量，在@BeforeAll中初始化，在@AfterAll中清理，它们在各个@Test方法中均是唯一实例，会影响各个@Test方法 异常测试 编写JUnit测试，除了正常的输入输出，还要特别针对可能导致异常的情况进行测试\nFactorial举例\npublic class Factorial { public static long fact(long n) { if (n \u003c 0) { throw new IllegalArgumentException(); } long r = 1; for (long i = 1; i \u003c= n; i++) { r = r * i; } return r; } } 对异常进行测试。JUnit测试中，我们可以编写一个@Test方法专门测试异常：\n@Test void testNegative() { assertThrows(IllegalArgumentException.class, new Executable() { @Override public void execute() throws Throwable { Factorial.fact(-1); } }); } assertThrows()来期望捕获一个指定的异常。第二个参数Executable封装要执行的会产生异常的代码\n条件测试 JUnit根据不同条件注解，决定是否运行当前@Test方法。类似@Disabled这种注解\n@Disabled使用\n需要排出某些@Test方法，不要让它运行，就可标记一个@Disabled\n@Disabled @Test void testBug101() { // 这个测试不会运行 } 加上@Disabled，JUnit仍然识别是测试方法，只是暂时不运行。测试结果中显示：\nTests run: 68, Failures: 2, Errors: 0, Skipped: 5 举例子\npublic class Config { public String getConfigFile(String filename) { String os = System.getProperty(\"os.name\").toLowerCase(); if (os.contains(\"win\")) { return \"C:\\\\\" + filename; } if (os.contains(\"mac\") || os.contains(\"linux\") || os.contains(\"unix\")) { return \"/usr/local/\" + filename; } throw new UnsupportedOperationException(); } } 测试getConfigFile()这方法，但是Windows上跑，和Linux上跑的代码路径不同\n@Test @EnabledOnOs(OS.WINDOWS) void testWindows() { assertEquals(\"C:\\\\test.ini\", config.getConfigFile(\"test.ini\")); } @Test @EnabledOnOs({ OS.LINUX, OS.MAC }) void testLinuxAndMac() { assertEquals(\"/usr/local/test.cfg\", config.getConfigFile(\"test.cfg\")); } 条件测试是根据某些注解在运行期让JUnit自动忽略某些测试\n参数化测试 含义：待测试的输入和输出是一组数据，可以把测试数据组织起来，用不同的测试数据调用相同的测试\n@ParameterizedTest注解，用来进行参数化测试\n想对Math.abs()进行测试，先用一组正数进行测试：\n@ParameterizedTest @ValueSource(ints = { 0, 1, 5, 100 }) void testAbs(int x) { assertEquals(x, Math.abs(x)); } 再用一组负数进行测试：\n@ParameterizedTest @ValueSource(ints = { -1, -5, -100 }) void testAbsNegative(int x) { assertEquals(-x, Math.abs(x)); } 实际的测试场景\n编写StringUtils.capitalize()方法，把字符串的第一个字母变为大写，后续字母变为小写：\npublic class StringUtils { public static String capitalize(String s) { if (s.length() == 0) { return s; } return Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase(); } } 参数化测试的方法来测试，不但要给出输入，还要给出预期输出：\n参数传入方法通过@MethodSource注解，允许编写同名的静态方法来测试参数： @ParameterizedTest @MethodSource void testCapitalize(String input, String result) { assertEquals(result, StringUtils.capitalize(input)); } static List\u003cArguments\u003e testCapitalize() { return List.of( // arguments: Arguments.of(\"abc\", \"Abc\"), // Arguments.of(\"APPLE\", \"Apple\"), // Arguments.of(\"gooD\", \"Good\")); } 参数传入方法是使用@CsvSource，每一个字符串表示一行，一行包含的若干参数用,分隔，因此可改写为： @ParameterizedTest @CsvSource({ \"abc, Abc\", \"APPLE, Apple\", \"gooD, Good\" }) void testCapitalize(String input, String result) { assertEquals(result, StringUtils.capitalize(input)); } 成百上千的测试输入，直接写@CsvSource很不方便。这个时候，可以把测试数据提到一个独立的CSV文件中，标注上@CsvFileSource： @ParameterizedTest @CsvFileSource(resources = { \"/test-capitalize.csv\" }) void testCapitalizeUsingCsvFile(String input, String result) { assertEquals(result, StringUtils.capitalize(input)); } 在classpath中查找指定的CSV文件，内容如下：\napple, Apple HELLO, Hello JUnit, Junit reSource, Resource 注解Annotation 使用注解 注解：放在Java源码的类、方法、字段、参数前的一种特殊“注释”：\n// this is a component: @Resource(\"hello\") public class Hello { @Inject int n; @PostConstruct public void hello(@Param String name) { System.out.println(name); } @Override public String toString() { return \"Hello\"; } } JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定\n注解作用：\n第一类是由编译器使用的注解，例如： @Override：让编译器检查该方法是否正确地实现了覆写 @SuppressWarnings：告诉编译器忽略此处代码产生的警告 第二类是由工具处理.class文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能 第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用 举个栗子，对以下代码：\npublic class Hello { @Check(min=0, max=100, value=55) public int n; @Check(value=99) public int p; @Check(99) // @Check(value=99) public int x; @Check public int y; } 定义一个注解时，还可以定义配置参数。配置参数可以包括：\n所有基本类型； String； 枚举类型； 基本类型、String、Class以及枚举的数组 大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数；如只写注解，相当于全部使用默认值\n定义注解 Java语言使用@interface语法来定义注解（Annotation）：\npublic @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\"; } 元注解\n有一些注解可以修饰其他注解，这些注解称为元注解\n@Target\n使用@Target可以定义Annotation能够被应用于源码的哪些位置：\n类或接口：ElementType.TYPE； 字段：ElementType.FIELD； 方法：ElementType.METHOD； 构造方法：ElementType.CONSTRUCTOR； 方法参数：ElementType.PARAMETER 定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }：\n@Target({ ElementType.METHOD, ElementType.FIELD }) public @interface Report { ... } @Repeatable\n使用@Repeatable这个元注解可以定义Annotation是否可重复。这个注解应用不是特别广泛。\n@Repeatable(Reports.class) @Target(ElementType.TYPE) public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\"; } @Target(ElementType.TYPE) public @interface Reports { Report[] value(); } 经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Report注解：\n@Report(type=1, level=\"debug\") @Report(type=2, level=\"warning\") public class Hello { } lnherited\n@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效：\n@Inherited @Target(ElementType.TYPE) public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\"; } 在使用的时候，如果一个类用到了@Report：\n@Report(type=1) public class Person { } 则它的子类默认也定义了该注解：\npublic class Student extends Person { } 总结方法\n第一步，用@interface定义注解：\npublic @interface Report { } 第二步，添加参数、默认值：\npublic @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\"; } 把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。\n第三步，用元注解配置注解：\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\"; } 必须设置@Target来指定Annotation可以应用的范围；\n应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation\n处理注解 // 判断@Report是否存在于Person类: Person.class.isAnnotationPresent(Report.class); 使用反射API读取Annotation：\nClass.getAnnotation(Class) Field.getAnnotation(Class) Method.getAnnotation(Class) Constructor.getAnnotation(Class) 例如：\n// 获取Person定义的@Report注解: Report report = Person.class.getAnnotation(Report.class); int type = report.type(); String level = report.level(); 使用反射API读取Annotation有两种方法。\n方法一是先判断Annotation是否存在，如果存在，就直接读取： Class cls = Person.class; if (cls.isAnnotationPresent(Report.class)) { Report report = cls.getAnnotation(Report.class); ... } 第二种方法是直接读取Annotation，如果Annotation不存在，将返回null：\nClass cls = Person.class; Report report = cls.getAnnotation(Report.class); if (report != null) { ... } 要读取方法参数的注解，我们先用反射获取Method实例，然后读取方法参数的所有注解：\n// 获取Method实例: Method m = ... // 获取所有参数的Annotation: Annotation[][] annos = m.getParameterAnnotations(); // 第一个参数（索引为0）的所有Annotation: Annotation[] annosOfName = annos[0]; for (Annotation anno : annosOfName) { if (anno instanceof Range r) { // @Range注解 r.max(); } if (anno instanceof NotNull n) { // @NotNull注解 // } } 使用注解\n看一个@Range注解，希望用来定义一个String字段的规则：字段长度满足@Range的参数定义：\n@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface Range { int min() default 0; int max() default 255; } 在某个JavaBean中，我们可以使用该注解：\npublic class Person { @Range(min=1, max=20) public String name; @Range(max=10) public String city; } 编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义：\nvoid check(Person person) throws IllegalArgumentException, ReflectiveOperationException { // 遍历所有Field: for (Field field : person.getClass().getFields()) { // 获取Field定义的@Range: Range range = field.getAnnotation(Range.class); // 如果@Range存在: if (range != null) { // 获取Field的值: Object value = field.get(person); // 如果值是String: if (value instanceof String s) { // 判断值是否满足@Range的min/max: if (s.length() \u003c range.min() || s.length() \u003e range.max()) { throw new IllegalArgumentException(\"Invalid field: \" + field.getName()); } } } } } ","wordCount":"999","inLanguage":"en","datePublished":"2025-01-22T22:06:05+08:00","dateModified":"2025-01-22T22:06:05+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/java03/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Java细知识</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95 aria-label=单元测试>单元测试</a><ul><li><a href=#%e7%bc%96%e5%86%99junit%e6%b5%8b%e8%af%95 aria-label=编写JUnit测试>编写JUnit测试</a></li><li><a href=#%e4%bd%bf%e7%94%a8fixture aria-label=使用Fixture>使用Fixture</a></li><li><a href=#%e5%bc%82%e5%b8%b8%e6%b5%8b%e8%af%95 aria-label=异常测试>异常测试</a></li><li><a href=#%e6%9d%a1%e4%bb%b6%e6%b5%8b%e8%af%95 aria-label=条件测试>条件测试</a></li><li><a href=#%e5%8f%82%e6%95%b0%e5%8c%96%e6%b5%8b%e8%af%95 aria-label=参数化测试>参数化测试</a></li></ul></li><li><a href=#%e6%b3%a8%e8%a7%a3annotation aria-label=注解Annotation>注解Annotation</a><ul><li><a href=#%e4%bd%bf%e7%94%a8%e6%b3%a8%e8%a7%a3 aria-label=使用注解>使用注解</a></li><li><a href=#%e5%ae%9a%e4%b9%89%e6%b3%a8%e8%a7%a3 aria-label=定义注解>定义注解</a></li><li><a href=#%e5%a4%84%e7%90%86%e6%b3%a8%e8%a7%a3 aria-label=处理注解>处理注解</a></li></ul></li></ul></div></details></div><div class=post-content><h3 id=单元测试>单元测试<a hidden class=anchor aria-hidden=true href=#单元测试>#</a></h3><ul><li><p>单元测试：针对最小的功能单元编写测试代码</p><ul><li><p>Java程序最小的功能单元是方法，对Java程序进行单元测试就是针对单个方法测试</p></li><li><p>测试驱动开发</p><ul><li>先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码</li></ul></li><li><p><strong>举例子</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Factorial</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>fact</span>(<span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> r <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> r <span style=color:#f92672>*</span> i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>测试这方法，一个很自然的想法是编写一个<code>main()</code>方法，然后运行一些测试代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (fact(10) <span style=color:#f92672>==</span> 3628800) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;pass&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;fail&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>只能有一个<code>main()</code>方法，不能把测试代码分离</li><li>是没有打印出测试结果和期望结果，例如，<code>expected: 3628800, but actual: 123456</code></li><li>很难编写一组通用的测试代码</li></ul></li></ul></li><li><h4 id=编写junit测试>编写JUnit测试<a hidden class=anchor aria-hidden=true href=#编写junit测试>#</a></h4><ul><li><p>JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计</p><ul><li>好处：<ul><li>可以非常简单地组织测试代码，并随时运行它们</li><li>给出成功的测试和失败的测试，还可以生成测试报告</li></ul></li></ul></li><li><p>使用操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.itranswarp.learnjava;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import static</span> org.junit.jupiter.api.Assertions.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.junit.jupiter.api.Test;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FactorialTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testFact</span>() {
</span></span><span style=display:flex><span>        assertEquals(1, Factorial.<span style=color:#a6e22e>fact</span>(1));
</span></span><span style=display:flex><span>        assertEquals(2, Factorial.<span style=color:#a6e22e>fact</span>(2));
</span></span><span style=display:flex><span>        assertEquals(6, Factorial.<span style=color:#a6e22e>fact</span>(3));
</span></span><span style=display:flex><span>        assertEquals(3628800, Factorial.<span style=color:#a6e22e>fact</span>(10));
</span></span><span style=display:flex><span>        assertEquals(2432902008176640000L, Factorial.<span style=color:#a6e22e>fact</span>(20));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>还有其他断言操作，以下错误结果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>org.opentest4j.AssertionFailedError: expected: &lt;3628800&gt; but was: &lt;362880&gt;
</span></span><span style=display:flex><span>	at org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:55)
</span></span><span style=display:flex><span>	at org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:195)
</span></span><span style=display:flex><span>	at org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:168)
</span></span><span style=display:flex><span>	at org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:163)
</span></span><span style=display:flex><span>	at org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:611)
</span></span><span style=display:flex><span>	at com.itranswarp.learnjava.FactorialTest.testFact(FactorialTest.java:14)
</span></span><span style=display:flex><span>	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
</span></span><span style=display:flex><span>	at ...
</span></span></code></pre></div><p>失败信息的意思是期待结果<code>3628800</code>但是实际返回是<code>362880</code>，此时，我们要么修正实现代码，要么修正测试代码，直到测试通过为止</p></li><li><p><strong>单元测试规范：</strong></p><ul><li>一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试；</li><li>二是每个单元测试应当互相独立，不依赖运行的顺序；</li><li>三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为<code>0</code>，<code>null</code>，空字符串<code>""</code>等情况</li></ul></li></ul></li><li><h4 id=使用fixture>使用Fixture<a hidden class=anchor aria-hidden=true href=#使用fixture>#</a></h4><ul><li><p>一个单元测试中，我们经常编写多个<code>@Test</code>方法，来分组、分类对目标代码进行测试
测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况</p><p><strong>JUnit提供了编写测试前准备、测试后清理的固定代码：：Fixture</strong></p></li><li><p>举例子</p><p>一个具体的<code>Calculator</code>的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Calculator</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>long</span> n <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>long</span> x) {
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> n <span style=color:#f92672>+</span> x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> n;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>sub</span>(<span style=color:#66d9ef>long</span> x) {
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> n;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>测试的时候，我们要先初始化对象，我们不必在每个测试方法中都写上初始化代码，而是通过<code>@BeforeEach</code>来初始化，通过<code>@AfterEach</code>来清理资源</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CalculatorTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Calculator calculator;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@BeforeEach</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setUp</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>calculator</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Calculator();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@AfterEach</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>tearDown</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>calculator</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAdd</span>() {
</span></span><span style=display:flex><span>        assertEquals(100, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>calculator</span>.<span style=color:#a6e22e>add</span>(100));
</span></span><span style=display:flex><span>        assertEquals(150, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>calculator</span>.<span style=color:#a6e22e>add</span>(50));
</span></span><span style=display:flex><span>        assertEquals(130, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>calculator</span>.<span style=color:#a6e22e>add</span>(<span style=color:#f92672>-</span>20));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testSub</span>() {
</span></span><span style=display:flex><span>        assertEquals(<span style=color:#f92672>-</span>100, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>calculator</span>.<span style=color:#a6e22e>sub</span>(100));
</span></span><span style=display:flex><span>        assertEquals(<span style=color:#f92672>-</span>150, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>calculator</span>.<span style=color:#a6e22e>sub</span>(50));
</span></span><span style=display:flex><span>        assertEquals(<span style=color:#f92672>-</span>130, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>calculator</span>.<span style=color:#a6e22e>sub</span>(<span style=color:#f92672>-</span>20));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>CalculatorTest</code>测试中，<strong>有两个标记为<code>@BeforeEach</code>和<code>@AfterEach</code>的方法，它们会在运行每个<code>@Test</code>方法前后自动运行</strong></p><p>**细节：**测试代码在JUnit中运行顺序如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>invokeBeforeAll(CalculatorTest.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (Method testMethod : findTestMethods(CalculatorTest.<span style=color:#a6e22e>class</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> test <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CalculatorTest(); <span style=color:#75715e>// 创建Test实例</span>
</span></span><span style=display:flex><span>    invokeBeforeEach(test);
</span></span><span style=display:flex><span>        invokeTestMethod(test, testMethod);
</span></span><span style=display:flex><span>    invokeAfterEach(test);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>invokeAfterAll(CalculatorTest.<span style=color:#a6e22e>class</span>);
</span></span></code></pre></div><p>一些资源初始化和清理可能更加繁琐，而且会耗费较长的时间，<strong>例如初始化数据库。JUnit还提供了<code>@BeforeAll</code>和<code>@AfterAll</code></strong></p><p><strong><code>@BeforeAll</code>和<code>@AfterAll</code>在所有<code>@Test</code>方法运行前后仅运行一次，因此，它们只能初始化静态变量</strong>，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DatabaseTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> Database db;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@BeforeAll</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initDatabase</span>() {
</span></span><span style=display:flex><span>        db <span style=color:#f92672>=</span> createDb(...);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@AfterAll</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dropDatabase</span>() {
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>总结使用</strong></p><ul><li>对于实例变量，在<code>@BeforeEach</code>中初始化，在<code>@AfterEach</code>中清理，它们<strong>在各个<code>@Test</code>方法中互不影响，因为是不同的实例</strong></li><li>对于静态变量，在<code>@BeforeAll</code>中初始化，在<code>@AfterAll</code>中清理，它们在各个<code>@Test</code>方法中均是唯一实例，会影响各个<code>@Test</code>方法</li></ul></li></ul></li><li><h4 id=异常测试>异常测试<a hidden class=anchor aria-hidden=true href=#异常测试>#</a></h4><ul><li><p>编写JUnit测试，除了正常的输入输出，还要特别针对可能导致异常的情况进行测试</p></li><li><p><strong><code>Factorial</code>举例</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Factorial</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>fact</span>(<span style=color:#66d9ef>long</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> r <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> r <span style=color:#f92672>*</span> i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对异常进行测试。JUnit测试中，我们可以编写一个<code>@Test</code>方法专门测试异常：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testNegative</span>() {
</span></span><span style=display:flex><span>    assertThrows(IllegalArgumentException.<span style=color:#a6e22e>class</span>, <span style=color:#66d9ef>new</span> Executable() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>() <span style=color:#66d9ef>throws</span> Throwable {
</span></span><span style=display:flex><span>            Factorial.<span style=color:#a6e22e>fact</span>(<span style=color:#f92672>-</span>1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>assertThrows()</code>来期望捕获一个指定的异常。第二个参数<code>Executable</code>封装要执行的会产生异常的代码</p></li></ul></li><li><h4 id=条件测试>条件测试<a hidden class=anchor aria-hidden=true href=#条件测试>#</a></h4><ul><li><p><strong>JUnit根据不同条件注解，决定是否运行当前<code>@Test</code>方法</strong>。类似<code>@Disabled</code>这种注解</p></li><li><p><code>@Disabled</code>使用</p><ul><li><p>需要排出某些<code>@Test</code>方法，不要让它运行，就可标记一个<code>@Disabled</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Disabled</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testBug101</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 这个测试不会运行</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>加上<code>@Disabled</code>，JUnit仍然识别是测试方法，只是暂时不运行。测试结果中显示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>Tests run: 68, Failures: 2, Errors: 0, Skipped: 5
</span></span></code></pre></div></li></ul></li><li><p>举例子</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Config</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getConfigFile</span>(String filename) {
</span></span><span style=display:flex><span>        String os <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;os.name&#34;</span>).<span style=color:#a6e22e>toLowerCase</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (os.<span style=color:#a6e22e>contains</span>(<span style=color:#e6db74>&#34;win&#34;</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;C:\\&#34;</span> <span style=color:#f92672>+</span> filename;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (os.<span style=color:#a6e22e>contains</span>(<span style=color:#e6db74>&#34;mac&#34;</span>) <span style=color:#f92672>||</span> os.<span style=color:#a6e22e>contains</span>(<span style=color:#e6db74>&#34;linux&#34;</span>) <span style=color:#f92672>||</span> os.<span style=color:#a6e22e>contains</span>(<span style=color:#e6db74>&#34;unix&#34;</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;/usr/local/&#34;</span> <span style=color:#f92672>+</span> filename;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnsupportedOperationException();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>测试<code>getConfigFile()</code>这方法，但是Windows上跑，和Linux上跑的代码路径不同</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnabledOnOs</span>(OS.<span style=color:#a6e22e>WINDOWS</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testWindows</span>() {
</span></span><span style=display:flex><span>    assertEquals(<span style=color:#e6db74>&#34;C:\\test.ini&#34;</span>, config.<span style=color:#a6e22e>getConfigFile</span>(<span style=color:#e6db74>&#34;test.ini&#34;</span>));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnabledOnOs</span>({ OS.<span style=color:#a6e22e>LINUX</span>, OS.<span style=color:#a6e22e>MAC</span> })
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testLinuxAndMac</span>() {
</span></span><span style=display:flex><span>    assertEquals(<span style=color:#e6db74>&#34;/usr/local/test.cfg&#34;</span>, config.<span style=color:#a6e22e>getConfigFile</span>(<span style=color:#e6db74>&#34;test.cfg&#34;</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>条件测试是根据某些注解在运行期让JUnit自动忽略某些测试</strong></p></li></ul></li><li><h4 id=参数化测试>参数化测试<a hidden class=anchor aria-hidden=true href=#参数化测试>#</a></h4><ul><li><p>含义：<strong>待测试的输入和输出是一组数据，可以把测试数据组织起来，用不同的测试数据调用相同的测试</strong></p></li><li><p><code>@ParameterizedTest</code>注解，用来进行参数化测试</p><ul><li><p>想对<code>Math.abs()</code>进行测试，先用一组正数进行测试：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@ParameterizedTest</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ValueSource</span>(ints <span style=color:#f92672>=</span> { 0, 1, 5, 100 })
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAbs</span>(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>    assertEquals(x, Math.<span style=color:#a6e22e>abs</span>(x));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>再用一组负数进行测试：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@ParameterizedTest</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ValueSource</span>(ints <span style=color:#f92672>=</span> { <span style=color:#f92672>-</span>1, <span style=color:#f92672>-</span>5, <span style=color:#f92672>-</span>100 })
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAbsNegative</span>(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>    assertEquals(<span style=color:#f92672>-</span>x, Math.<span style=color:#a6e22e>abs</span>(x));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>实际的测试场景</strong></p><p>编写<code>StringUtils.capitalize()</code>方法，把字符串的第一个字母变为大写，后续字母变为小写：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StringUtils</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>capitalize</span>(String s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (s.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> s;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Character.<span style=color:#a6e22e>toUpperCase</span>(s.<span style=color:#a6e22e>charAt</span>(0)) <span style=color:#f92672>+</span> s.<span style=color:#a6e22e>substring</span>(1).<span style=color:#a6e22e>toLowerCase</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>参数化测试的方法来测试，不但要给出输入，还要给出预期输出：</p><ul><li>参数传入方法通过<code>@MethodSource</code>注解，允许编写同名的静态方法来测试参数：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@ParameterizedTest</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@MethodSource</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testCapitalize</span>(String input, String result) {
</span></span><span style=display:flex><span>    assertEquals(result, StringUtils.<span style=color:#a6e22e>capitalize</span>(input));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> List<span style=color:#f92672>&lt;</span>Arguments<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>testCapitalize</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> List.<span style=color:#a6e22e>of</span>( <span style=color:#75715e>// arguments:</span>
</span></span><span style=display:flex><span>            Arguments.<span style=color:#a6e22e>of</span>(<span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#e6db74>&#34;Abc&#34;</span>), <span style=color:#75715e>//</span>
</span></span><span style=display:flex><span>            Arguments.<span style=color:#a6e22e>of</span>(<span style=color:#e6db74>&#34;APPLE&#34;</span>, <span style=color:#e6db74>&#34;Apple&#34;</span>), <span style=color:#75715e>//</span>
</span></span><span style=display:flex><span>            Arguments.<span style=color:#a6e22e>of</span>(<span style=color:#e6db74>&#34;gooD&#34;</span>, <span style=color:#e6db74>&#34;Good&#34;</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>参数传入方法是使用<code>@CsvSource</code>，每一个字符串表示一行，一行包含的若干参数用<code>,</code>分隔，因此可改写为：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@ParameterizedTest</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@CsvSource</span>({ <span style=color:#e6db74>&#34;abc, Abc&#34;</span>, <span style=color:#e6db74>&#34;APPLE, Apple&#34;</span>, <span style=color:#e6db74>&#34;gooD, Good&#34;</span> })
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testCapitalize</span>(String input, String result) {
</span></span><span style=display:flex><span>    assertEquals(result, StringUtils.<span style=color:#a6e22e>capitalize</span>(input));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>成百上千的测试输入，直接写<code>@CsvSource</code>很不方便。这个时候，可以把测试数据提到一个独立的CSV文件中，标注上<code>@CsvFileSource</code>：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@ParameterizedTest</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@CsvFileSource</span>(resources <span style=color:#f92672>=</span> { <span style=color:#e6db74>&#34;/test-capitalize.csv&#34;</span> })
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testCapitalizeUsingCsvFile</span>(String input, String result) {
</span></span><span style=display:flex><span>    assertEquals(result, StringUtils.<span style=color:#a6e22e>capitalize</span>(input));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在classpath中查找指定的CSV文件，内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>apple, Apple
</span></span><span style=display:flex><span>HELLO, Hello
</span></span><span style=display:flex><span>JUnit, Junit
</span></span><span style=display:flex><span>reSource, Resource
</span></span></code></pre></div></li></ul></li></ul></li></ul><h3 id=注解annotation>注解Annotation<a hidden class=anchor aria-hidden=true href=#注解annotation>#</a></h3><ul><li><h4 id=使用注解>使用注解<a hidden class=anchor aria-hidden=true href=#使用注解>#</a></h4><ul><li><p><strong>注解：放在Java源码的类、方法、字段、参数前的一种特殊“注释”：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// this is a component:</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Resource</span>(<span style=color:#e6db74>&#34;hello&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Inject</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@PostConstruct</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>(<span style=color:#a6e22e>@Param</span> String name) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定</p></li><li><p><strong>注解作用：</strong></p><ul><li>第一类是由编译器使用的注解，例如：<ul><li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写</li><li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告</li></ul></li><li>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能</li><li>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用</li></ul></li><li><p>举个栗子，对以下代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Check</span>(min<span style=color:#f92672>=</span>0, max<span style=color:#f92672>=</span>100, value<span style=color:#f92672>=</span>55)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Check</span>(value<span style=color:#f92672>=</span>99)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> p;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Check</span>(99) <span style=color:#75715e>// @Check(value=99)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Check</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> y;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p><ul><li>所有基本类型；</li><li>String；</li><li>枚举类型；</li><li>基本类型、String、Class以及枚举的数组</li></ul><p>大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数；如只写注解，相当于全部使用默认值</p></li></ul></li><li><h4 id=定义注解>定义注解<a hidden class=anchor aria-hidden=true href=#定义注解>#</a></h4><ul><li><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>@interface</span> Report {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>type</span>() <span style=color:#66d9ef>default</span> 0;
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>level</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;info&#34;</span>;
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>value</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>元注解</strong></p><ul><li><p>有一些注解可以修饰其他注解，这些注解称为<strong>元注解</strong></p></li><li><p><code>@Target</code></p><ul><li><p>使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p><ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code></li></ul><p>定义注解<code>@Report</code>可用在方法或字段上，可以把<code>@Target</code>注解参数变为数组<code>{ ElementType.METHOD, ElementType.FIELD }</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Target</span>({
</span></span><span style=display:flex><span>    ElementType.<span style=color:#a6e22e>METHOD</span>,
</span></span><span style=display:flex><span>    ElementType.<span style=color:#a6e22e>FIELD</span>
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>@interface</span> Report {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p><code>@Repeatable</code></p><p>使用<code>@Repeatable</code>这个元注解可以定义<code>Annotation</code>是否可重复。这个注解应用不是特别广泛。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Repeatable</span>(Reports.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Target</span>(ElementType.<span style=color:#a6e22e>TYPE</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>@interface</span> Report {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>type</span>() <span style=color:#66d9ef>default</span> 0;
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>level</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;info&#34;</span>;
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>value</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Target</span>(ElementType.<span style=color:#a6e22e>TYPE</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>@interface</span> Reports {
</span></span><span style=display:flex><span>    Report<span style=color:#f92672>[]</span> <span style=color:#a6e22e>value</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Report</span>(type<span style=color:#f92672>=</span>1, level<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;debug&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Report</span>(type<span style=color:#f92672>=</span>2, level<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;warning&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>lnherited</code></p><p><code>@Inherited</code>定义<strong>子类是否可继承父类定义的<code>Annotation</code></strong>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Inherited</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Target</span>(ElementType.<span style=color:#a6e22e>TYPE</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>@interface</span> Report {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>type</span>() <span style=color:#66d9ef>default</span> 0;
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>level</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;info&#34;</span>;
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>value</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在使用的时候，如果一个类用到了<code>@Report</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Report</span>(type<span style=color:#f92672>=</span>1)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>则它的子类默认也定义了该注解：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p><strong>总结方法</strong></p><p>第一步，用<code>@interface</code>定义注解：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>@interface</span> Report {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>第二步，添加参数、默认值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>@interface</span> Report {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>type</span>() <span style=color:#66d9ef>default</span> 0;
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>level</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;info&#34;</span>;
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>value</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p><p>第三步，用元注解配置注解：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Target</span>(ElementType.<span style=color:#a6e22e>TYPE</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Retention</span>(RetentionPolicy.<span style=color:#a6e22e>RUNTIME</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>@interface</span> Report {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>type</span>() <span style=color:#66d9ef>default</span> 0;
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>level</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;info&#34;</span>;
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>value</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>必须设置<code>@Target</code>来指定<code>Annotation</code>可以应用的范围；</p><p>应当设置<code>@Retention(RetentionPolicy.RUNTIME)</code>便于运行期读取该<code>Annotation</code></p></li></ul></li><li><h4 id=处理注解>处理注解<a hidden class=anchor aria-hidden=true href=#处理注解>#</a></h4><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 判断@Report是否存在于Person类:</span>
</span></span><span style=display:flex><span>Person.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>isAnnotationPresent</span>(Report.<span style=color:#a6e22e>class</span>);
</span></span></code></pre></div><p>使用反射API读取Annotation：</p><ul><li>Class.getAnnotation(Class)</li><li>Field.getAnnotation(Class)</li><li>Method.getAnnotation(Class)</li><li>Constructor.getAnnotation(Class)</li></ul><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 获取Person定义的@Report注解:</span>
</span></span><span style=display:flex><span>Report report <span style=color:#f92672>=</span> Person.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getAnnotation</span>(Report.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> type <span style=color:#f92672>=</span> report.<span style=color:#a6e22e>type</span>();
</span></span><span style=display:flex><span>String level <span style=color:#f92672>=</span> report.<span style=color:#a6e22e>level</span>();
</span></span></code></pre></div><p>使用反射API读取<code>Annotation</code>有两种方法。</p><ul><li>方法一是先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Class cls <span style=color:#f92672>=</span> Person.<span style=color:#a6e22e>class</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (cls.<span style=color:#a6e22e>isAnnotationPresent</span>(Report.<span style=color:#a6e22e>class</span>)) {
</span></span><span style=display:flex><span>    Report report <span style=color:#f92672>=</span> cls.<span style=color:#a6e22e>getAnnotation</span>(Report.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>第二种方法是直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Class cls <span style=color:#f92672>=</span> Person.<span style=color:#a6e22e>class</span>;
</span></span><span style=display:flex><span>Report report <span style=color:#f92672>=</span> cls.<span style=color:#a6e22e>getAnnotation</span>(Report.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (report <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>   ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>要读取方法参数的注解，我们先用反射获取<code>Method</code>实例，然后读取方法参数的所有注解：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 获取Method实例:</span>
</span></span><span style=display:flex><span>Method m <span style=color:#f92672>=</span> ...
</span></span><span style=display:flex><span><span style=color:#75715e>// 获取所有参数的Annotation:</span>
</span></span><span style=display:flex><span>Annotation<span style=color:#f92672>[][]</span> annos <span style=color:#f92672>=</span> m.<span style=color:#a6e22e>getParameterAnnotations</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// 第一个参数（索引为0）的所有Annotation:</span>
</span></span><span style=display:flex><span>Annotation<span style=color:#f92672>[]</span> annosOfName <span style=color:#f92672>=</span> annos<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (Annotation anno : annosOfName) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (anno <span style=color:#66d9ef>instanceof</span> Range r) { <span style=color:#75715e>// @Range注解</span>
</span></span><span style=display:flex><span>        r.<span style=color:#a6e22e>max</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (anno <span style=color:#66d9ef>instanceof</span> NotNull n) { <span style=color:#75715e>// @NotNull注解</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>使用注解</strong></p><ul><li><p>看一个<code>@Range</code>注解，希望用来定义一个<code>String</code>字段的规则：字段长度满足<code>@Range</code>的参数定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Retention</span>(RetentionPolicy.<span style=color:#a6e22e>RUNTIME</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Target</span>(ElementType.<span style=color:#a6e22e>FIELD</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>@interface</span> Range {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>min</span>() <span style=color:#66d9ef>default</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max</span>() <span style=color:#66d9ef>default</span> 255;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在某个JavaBean中，我们可以使用该注解：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Range</span>(min<span style=color:#f92672>=</span>1, max<span style=color:#f92672>=</span>20)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Range</span>(max<span style=color:#f92672>=</span>10)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String city;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>check</span>(Person person) <span style=color:#66d9ef>throws</span> IllegalArgumentException, ReflectiveOperationException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 遍历所有Field:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (Field field : person.<span style=color:#a6e22e>getClass</span>().<span style=color:#a6e22e>getFields</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取Field定义的@Range:</span>
</span></span><span style=display:flex><span>        Range range <span style=color:#f92672>=</span> field.<span style=color:#a6e22e>getAnnotation</span>(Range.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果@Range存在:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (range <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 获取Field的值:</span>
</span></span><span style=display:flex><span>            Object value <span style=color:#f92672>=</span> field.<span style=color:#a6e22e>get</span>(person);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果值是String:</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (value <span style=color:#66d9ef>instanceof</span> String s) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 判断值是否满足@Range的min/max:</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (s.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>&lt;</span> range.<span style=color:#a6e22e>min</span>() <span style=color:#f92672>||</span> s.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>&gt;</span> range.<span style=color:#a6e22e>max</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;Invalid field: &#34;</span> <span style=color:#f92672>+</span> field.<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/network00/><span class=title>« Prev Page</span><br><span>网络基础</span>
</a><a class=next href=https://zwlzls.github.io/posts/java02/><span class=title>Next Page »</span><br><span>Java高级</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>