<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>《软件研发效能提升之美00》 | 我的博客</title>
<meta name=keywords content="软件研发效能提升之美"><meta name=description content='内容《软件研发效能提升之美》之书 总论 研发效能是多⼈组织协同效率的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统
研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视 整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率
**没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍
希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业
敏捷作为⼀种通过创造变化和响应变化在不确定和混乱的环境中取得成功的能力，具备高度的实践性和创造性，这样的特性在赋予敏捷强大适配度的同时，也给落地造成了困难
概述 研发效能提升案例
前端代码的自动生成
我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。
这种方式的引入将大幅提升原型构建环节的效率
临界参数下的API测试
考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值
进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露
例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题
基于流程优化的效能提升
效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便 第一性原理：顺畅、高质量地持续交付有效价值的闭环
顺畅：价值的流动过程必须顺畅，没有阻碍 高质量：如果质量不行，那么流动越快，死得也会越快 **持续：**不能时断时续，小步快跑才是正道 **有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题 **闭环：**强调快速反馈的重要性 鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让 鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋 从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践
举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤
架构相对简单，但是集群规模庞大，则优选金丝雀 架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势 研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的
研发效能提升实践：
找钉子，场景举例：
本地编译耗时长：提供增量编译和分布式编译能力 本地测试困难，测试环境准备复杂且耗时长：基于Kubernetes的Pod提供⼀键搭建测试环境的能力 自动化测试用例数量大，执行回归时间过长：采用并发测试用例执行机制，使用几百、几千台测试执行机并行执行用例，实现用硬件资源换时间 自动化测试用例维护成本高：测试用例采用模块化和分层体系，实现低成本的自动化用例维护 测试数据准备困难：引入统⼀的测试数据服务（Test DataService）能力 集群规模庞大，发布过程耗时过长：各个层级的并发部署能力，集群内节点的并发、集群间的并发等。 项目的过程数据都是后期集中填充，失去度量意义：项目的过程数据由⼯具自动填充，不再依赖⼯程师手工输入。比如，开发完成的时间不再依赖于开发人员手工填写，而是由Jenkins构建完成后自动填写，以保证所有过程数据的真实有效性，从⽽为后面的度量和改进提供可靠的信息输入 全局切入：
软件缺陷的流转，软件需求的实现与交付，软件制品包发布等待 持续改进：
比如，需要在Jenkins中通过hook机制去触发⼀些操作（比如代码静态扫描、单元测试等），最简单的做法就是在hook中实现操作的具体步骤，这种实现在开始时效率很高，也非常容易实现，但却不是最优的⽅案，因为hook中的代码只会被执行⼀次，而且hook越来越多以后，各种实现都散落在各个地方，难以维护，⼀旦有新的需要（比如要加⼊慢SQL扫描），就需要改hook实现，而且这种做法也违背了IaC（Infrastructure as Code）原则。
更好的做法是引入研发效能的消息中心，通过下游操作的订阅模式来实现未来的可扩展性
效能平台的灵活性
将Jenkins持续集成⼯具视为⼀个平台，在这个平台上支持安装各种插件，以增强平台功能，从而实现平台架构的灵活性 杜绝"掩耳盗铃"
代码质量门禁Sonar设而不卡 单元测试只是执行，不写断⾔Assert 代码覆盖率形同虚设 Peer Review走过场 代码递交过于随意 监控超配，有报警但无人认领 发展方向与未来展望
研发各个环节的全链路横向打通 CI/CD和测试不再是⼀个个独立的环节，软件研发从需求开始到最终线上交付采用⼀站式的研发效能平台，实现统⼀的研发⼯具和流程 研发全流程的可视化 研发流程的可视化在后期⼀定会成为⾏业的标配，通过流程的可视化，可以展示各个需求的进展情况，让各级管理者和⼀线⼯程师清楚地知道项目目前所处的状态。 “稳态”和“敏态”齐头并进 研发效能的提升并不⼀定都要绑定到敏捷开发实践上，事实上，对于那些需求明确并且稳定的项目，传统的瀑布模型依然是最佳的选择，此时采用“稳态”实践才是获得最佳效率的途径。只有那些需求变更频繁的项目才是践行敏捷实践的最佳选择。因此，敏捷对传统瀑布而言并不是取代，⽽是互补，“稳态”和“敏态”会在长时期内和谐共存。 研发能力的中台化沉淀 研发各阶段的垂直能⼒必然会沉淀到中台，以统⼀服务化的形式对外提供服务。⽐如，代码覆盖率的统计能⼒会统⼀到⼀个单⼀的服务中，为各个语⾔的业务提供代码覆盖率的统计；再如，分布式编译加速的能⼒也会成为企业级的服务，为各种⼤型项目提供编译加速。 数据驱动下的效能提升 以后的决策⼀定会基于数据来开展。效能提升实践的效果衡量也会⾼度依赖于数据。研发效能数据中台的建设必定会被提上⽇程，通过收集存储研发各阶段的各种过程数据，实现基于研发效能⼤数据平台的决策体系 进阶解读 软件生产作为智⼒密集型活动，掺杂着⼤量人的因素，很难严格地标准化 质量和效能是“既要、也要”的关系，效能的提升能够将软件研发中的⻛险更快、更及时地暴露出来，同时减轻⼈脑负担，反过来⼜ 能提升质量本身 渴望尊重和欣赏，是⼈性的需求之⼀。适度的关注和赞美能够产⽣强烈的心理暗示，继而带来效能的提升 反摩尔定律告诉我们，越迟交付的价值其价值越低 信息熵衰减对研发效能的影响是巨⼤的，要想方设法将信息传递的效率提升上去 自解释的代码不是无注释和无文档的代码，而是伴随着⾼信息熵的代码体系。内容简洁合理的注释与⽂档，同样也是优秀代码的⼀部分，能够给效能的提升带来帮助 基于流程优化，打破各个环节看不见的墙，去除不必要的等待，提升价值流动速度，这些是研发效能试图解决的一大类问题 项目管理提效 敏捷宣言'><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/efficiency00/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/efficiency00/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="《软件研发效能提升之美00》"><meta property="og:description" content='内容《软件研发效能提升之美》之书 总论 研发效能是多⼈组织协同效率的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统
研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视 整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率
**没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍
希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业
敏捷作为⼀种通过创造变化和响应变化在不确定和混乱的环境中取得成功的能力，具备高度的实践性和创造性，这样的特性在赋予敏捷强大适配度的同时，也给落地造成了困难
概述 研发效能提升案例
前端代码的自动生成
我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。
这种方式的引入将大幅提升原型构建环节的效率
临界参数下的API测试
考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值
进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露
例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题
基于流程优化的效能提升
效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便 第一性原理：顺畅、高质量地持续交付有效价值的闭环
顺畅：价值的流动过程必须顺畅，没有阻碍 高质量：如果质量不行，那么流动越快，死得也会越快 **持续：**不能时断时续，小步快跑才是正道 **有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题 **闭环：**强调快速反馈的重要性 鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让 鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋 从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践
举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤
架构相对简单，但是集群规模庞大，则优选金丝雀 架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势 研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的
研发效能提升实践：
找钉子，场景举例：
本地编译耗时长：提供增量编译和分布式编译能力 本地测试困难，测试环境准备复杂且耗时长：基于Kubernetes的Pod提供⼀键搭建测试环境的能力 自动化测试用例数量大，执行回归时间过长：采用并发测试用例执行机制，使用几百、几千台测试执行机并行执行用例，实现用硬件资源换时间 自动化测试用例维护成本高：测试用例采用模块化和分层体系，实现低成本的自动化用例维护 测试数据准备困难：引入统⼀的测试数据服务（Test DataService）能力 集群规模庞大，发布过程耗时过长：各个层级的并发部署能力，集群内节点的并发、集群间的并发等。 项目的过程数据都是后期集中填充，失去度量意义：项目的过程数据由⼯具自动填充，不再依赖⼯程师手工输入。比如，开发完成的时间不再依赖于开发人员手工填写，而是由Jenkins构建完成后自动填写，以保证所有过程数据的真实有效性，从⽽为后面的度量和改进提供可靠的信息输入 全局切入：
软件缺陷的流转，软件需求的实现与交付，软件制品包发布等待 持续改进：
比如，需要在Jenkins中通过hook机制去触发⼀些操作（比如代码静态扫描、单元测试等），最简单的做法就是在hook中实现操作的具体步骤，这种实现在开始时效率很高，也非常容易实现，但却不是最优的⽅案，因为hook中的代码只会被执行⼀次，而且hook越来越多以后，各种实现都散落在各个地方，难以维护，⼀旦有新的需要（比如要加⼊慢SQL扫描），就需要改hook实现，而且这种做法也违背了IaC（Infrastructure as Code）原则。
更好的做法是引入研发效能的消息中心，通过下游操作的订阅模式来实现未来的可扩展性
效能平台的灵活性
将Jenkins持续集成⼯具视为⼀个平台，在这个平台上支持安装各种插件，以增强平台功能，从而实现平台架构的灵活性 杜绝"掩耳盗铃"
代码质量门禁Sonar设而不卡 单元测试只是执行，不写断⾔Assert 代码覆盖率形同虚设 Peer Review走过场 代码递交过于随意 监控超配，有报警但无人认领 发展方向与未来展望
研发各个环节的全链路横向打通 CI/CD和测试不再是⼀个个独立的环节，软件研发从需求开始到最终线上交付采用⼀站式的研发效能平台，实现统⼀的研发⼯具和流程 研发全流程的可视化 研发流程的可视化在后期⼀定会成为⾏业的标配，通过流程的可视化，可以展示各个需求的进展情况，让各级管理者和⼀线⼯程师清楚地知道项目目前所处的状态。 “稳态”和“敏态”齐头并进 研发效能的提升并不⼀定都要绑定到敏捷开发实践上，事实上，对于那些需求明确并且稳定的项目，传统的瀑布模型依然是最佳的选择，此时采用“稳态”实践才是获得最佳效率的途径。只有那些需求变更频繁的项目才是践行敏捷实践的最佳选择。因此，敏捷对传统瀑布而言并不是取代，⽽是互补，“稳态”和“敏态”会在长时期内和谐共存。 研发能力的中台化沉淀 研发各阶段的垂直能⼒必然会沉淀到中台，以统⼀服务化的形式对外提供服务。⽐如，代码覆盖率的统计能⼒会统⼀到⼀个单⼀的服务中，为各个语⾔的业务提供代码覆盖率的统计；再如，分布式编译加速的能⼒也会成为企业级的服务，为各种⼤型项目提供编译加速。 数据驱动下的效能提升 以后的决策⼀定会基于数据来开展。效能提升实践的效果衡量也会⾼度依赖于数据。研发效能数据中台的建设必定会被提上⽇程，通过收集存储研发各阶段的各种过程数据，实现基于研发效能⼤数据平台的决策体系 进阶解读 软件生产作为智⼒密集型活动，掺杂着⼤量人的因素，很难严格地标准化 质量和效能是“既要、也要”的关系，效能的提升能够将软件研发中的⻛险更快、更及时地暴露出来，同时减轻⼈脑负担，反过来⼜ 能提升质量本身 渴望尊重和欣赏，是⼈性的需求之⼀。适度的关注和赞美能够产⽣强烈的心理暗示，继而带来效能的提升 反摩尔定律告诉我们，越迟交付的价值其价值越低 信息熵衰减对研发效能的影响是巨⼤的，要想方设法将信息传递的效率提升上去 自解释的代码不是无注释和无文档的代码，而是伴随着⾼信息熵的代码体系。内容简洁合理的注释与⽂档，同样也是优秀代码的⼀部分，能够给效能的提升带来帮助 基于流程优化，打破各个环节看不见的墙，去除不必要的等待，提升价值流动速度，这些是研发效能试图解决的一大类问题 项目管理提效 敏捷宣言'><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/efficiency00/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-01T18:54:14+08:00"><meta property="article:modified_time" content="2025-03-01T18:54:14+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="《软件研发效能提升之美00》"><meta name=twitter:description content='内容《软件研发效能提升之美》之书 总论 研发效能是多⼈组织协同效率的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统
研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视 整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率
**没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍
希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业
敏捷作为⼀种通过创造变化和响应变化在不确定和混乱的环境中取得成功的能力，具备高度的实践性和创造性，这样的特性在赋予敏捷强大适配度的同时，也给落地造成了困难
概述 研发效能提升案例
前端代码的自动生成
我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。
这种方式的引入将大幅提升原型构建环节的效率
临界参数下的API测试
考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值
进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露
例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题
基于流程优化的效能提升
效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便 第一性原理：顺畅、高质量地持续交付有效价值的闭环
顺畅：价值的流动过程必须顺畅，没有阻碍 高质量：如果质量不行，那么流动越快，死得也会越快 **持续：**不能时断时续，小步快跑才是正道 **有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题 **闭环：**强调快速反馈的重要性 鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让 鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋 从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践
举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤
架构相对简单，但是集群规模庞大，则优选金丝雀 架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势 研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的
研发效能提升实践：
找钉子，场景举例：
本地编译耗时长：提供增量编译和分布式编译能力 本地测试困难，测试环境准备复杂且耗时长：基于Kubernetes的Pod提供⼀键搭建测试环境的能力 自动化测试用例数量大，执行回归时间过长：采用并发测试用例执行机制，使用几百、几千台测试执行机并行执行用例，实现用硬件资源换时间 自动化测试用例维护成本高：测试用例采用模块化和分层体系，实现低成本的自动化用例维护 测试数据准备困难：引入统⼀的测试数据服务（Test DataService）能力 集群规模庞大，发布过程耗时过长：各个层级的并发部署能力，集群内节点的并发、集群间的并发等。 项目的过程数据都是后期集中填充，失去度量意义：项目的过程数据由⼯具自动填充，不再依赖⼯程师手工输入。比如，开发完成的时间不再依赖于开发人员手工填写，而是由Jenkins构建完成后自动填写，以保证所有过程数据的真实有效性，从⽽为后面的度量和改进提供可靠的信息输入 全局切入：
软件缺陷的流转，软件需求的实现与交付，软件制品包发布等待 持续改进：
比如，需要在Jenkins中通过hook机制去触发⼀些操作（比如代码静态扫描、单元测试等），最简单的做法就是在hook中实现操作的具体步骤，这种实现在开始时效率很高，也非常容易实现，但却不是最优的⽅案，因为hook中的代码只会被执行⼀次，而且hook越来越多以后，各种实现都散落在各个地方，难以维护，⼀旦有新的需要（比如要加⼊慢SQL扫描），就需要改hook实现，而且这种做法也违背了IaC（Infrastructure as Code）原则。
更好的做法是引入研发效能的消息中心，通过下游操作的订阅模式来实现未来的可扩展性
效能平台的灵活性
将Jenkins持续集成⼯具视为⼀个平台，在这个平台上支持安装各种插件，以增强平台功能，从而实现平台架构的灵活性 杜绝"掩耳盗铃"
代码质量门禁Sonar设而不卡 单元测试只是执行，不写断⾔Assert 代码覆盖率形同虚设 Peer Review走过场 代码递交过于随意 监控超配，有报警但无人认领 发展方向与未来展望
研发各个环节的全链路横向打通 CI/CD和测试不再是⼀个个独立的环节，软件研发从需求开始到最终线上交付采用⼀站式的研发效能平台，实现统⼀的研发⼯具和流程 研发全流程的可视化 研发流程的可视化在后期⼀定会成为⾏业的标配，通过流程的可视化，可以展示各个需求的进展情况，让各级管理者和⼀线⼯程师清楚地知道项目目前所处的状态。 “稳态”和“敏态”齐头并进 研发效能的提升并不⼀定都要绑定到敏捷开发实践上，事实上，对于那些需求明确并且稳定的项目，传统的瀑布模型依然是最佳的选择，此时采用“稳态”实践才是获得最佳效率的途径。只有那些需求变更频繁的项目才是践行敏捷实践的最佳选择。因此，敏捷对传统瀑布而言并不是取代，⽽是互补，“稳态”和“敏态”会在长时期内和谐共存。 研发能力的中台化沉淀 研发各阶段的垂直能⼒必然会沉淀到中台，以统⼀服务化的形式对外提供服务。⽐如，代码覆盖率的统计能⼒会统⼀到⼀个单⼀的服务中，为各个语⾔的业务提供代码覆盖率的统计；再如，分布式编译加速的能⼒也会成为企业级的服务，为各种⼤型项目提供编译加速。 数据驱动下的效能提升 以后的决策⼀定会基于数据来开展。效能提升实践的效果衡量也会⾼度依赖于数据。研发效能数据中台的建设必定会被提上⽇程，通过收集存储研发各阶段的各种过程数据，实现基于研发效能⼤数据平台的决策体系 进阶解读 软件生产作为智⼒密集型活动，掺杂着⼤量人的因素，很难严格地标准化 质量和效能是“既要、也要”的关系，效能的提升能够将软件研发中的⻛险更快、更及时地暴露出来，同时减轻⼈脑负担，反过来⼜ 能提升质量本身 渴望尊重和欣赏，是⼈性的需求之⼀。适度的关注和赞美能够产⽣强烈的心理暗示，继而带来效能的提升 反摩尔定律告诉我们，越迟交付的价值其价值越低 信息熵衰减对研发效能的影响是巨⼤的，要想方设法将信息传递的效率提升上去 自解释的代码不是无注释和无文档的代码，而是伴随着⾼信息熵的代码体系。内容简洁合理的注释与⽂档，同样也是优秀代码的⼀部分，能够给效能的提升带来帮助 基于流程优化，打破各个环节看不见的墙，去除不必要的等待，提升价值流动速度，这些是研发效能试图解决的一大类问题 项目管理提效 敏捷宣言'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"《软件研发效能提升之美00》","item":"https://zwlzls.github.io/posts/efficiency00/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"《软件研发效能提升之美00》","name":"《软件研发效能提升之美00》","description":"内容《软件研发效能提升之美》之书 总论 研发效能是多⼈组织协同效率的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统\n研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视 整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率\n**没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍\n希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业\n敏捷作为⼀种通过创造变化和响应变化在不确定和混乱的环境中取得成功的能力，具备高度的实践性和创造性，这样的特性在赋予敏捷强大适配度的同时，也给落地造成了困难\n概述 研发效能提升案例\n前端代码的自动生成\n我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。\n这种方式的引入将大幅提升原型构建环节的效率\n临界参数下的API测试\n考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值\n进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露\n例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题\n基于流程优化的效能提升\n效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便 第一性原理：顺畅、高质量地持续交付有效价值的闭环\n顺畅：价值的流动过程必须顺畅，没有阻碍 高质量：如果质量不行，那么流动越快，死得也会越快 **持续：**不能时断时续，小步快跑才是正道 **有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题 **闭环：**强调快速反馈的重要性 鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让 鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋 从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践\n举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤\n架构相对简单，但是集群规模庞大，则优选金丝雀 架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势 研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的\n研发效能提升实践：\n找钉子，场景举例：\n本地编译耗时长：提供增量编译和分布式编译能力 本地测试困难，测试环境准备复杂且耗时长：基于Kubernetes的Pod提供⼀键搭建测试环境的能力 自动化测试用例数量大，执行回归时间过长：采用并发测试用例执行机制，使用几百、几千台测试执行机并行执行用例，实现用硬件资源换时间 自动化测试用例维护成本高：测试用例采用模块化和分层体系，实现低成本的自动化用例维护 测试数据准备困难：引入统⼀的测试数据服务（Test DataService）能力 集群规模庞大，发布过程耗时过长：各个层级的并发部署能力，集群内节点的并发、集群间的并发等。 项目的过程数据都是后期集中填充，失去度量意义：项目的过程数据由⼯具自动填充，不再依赖⼯程师手工输入。比如，开发完成的时间不再依赖于开发人员手工填写，而是由Jenkins构建完成后自动填写，以保证所有过程数据的真实有效性，从⽽为后面的度量和改进提供可靠的信息输入 全局切入：\n软件缺陷的流转，软件需求的实现与交付，软件制品包发布等待 持续改进：\n比如，需要在Jenkins中通过hook机制去触发⼀些操作（比如代码静态扫描、单元测试等），最简单的做法就是在hook中实现操作的具体步骤，这种实现在开始时效率很高，也非常容易实现，但却不是最优的⽅案，因为hook中的代码只会被执行⼀次，而且hook越来越多以后，各种实现都散落在各个地方，难以维护，⼀旦有新的需要（比如要加⼊慢SQL扫描），就需要改hook实现，而且这种做法也违背了IaC（Infrastructure as Code）原则。\n更好的做法是引入研发效能的消息中心，通过下游操作的订阅模式来实现未来的可扩展性\n效能平台的灵活性\n将Jenkins持续集成⼯具视为⼀个平台，在这个平台上支持安装各种插件，以增强平台功能，从而实现平台架构的灵活性 杜绝\u0026quot;掩耳盗铃\u0026quot;\n代码质量门禁Sonar设而不卡 单元测试只是执行，不写断⾔Assert 代码覆盖率形同虚设 Peer Review走过场 代码递交过于随意 监控超配，有报警但无人认领 发展方向与未来展望\n研发各个环节的全链路横向打通 CI/CD和测试不再是⼀个个独立的环节，软件研发从需求开始到最终线上交付采用⼀站式的研发效能平台，实现统⼀的研发⼯具和流程 研发全流程的可视化 研发流程的可视化在后期⼀定会成为⾏业的标配，通过流程的可视化，可以展示各个需求的进展情况，让各级管理者和⼀线⼯程师清楚地知道项目目前所处的状态。 “稳态”和“敏态”齐头并进 研发效能的提升并不⼀定都要绑定到敏捷开发实践上，事实上，对于那些需求明确并且稳定的项目，传统的瀑布模型依然是最佳的选择，此时采用“稳态”实践才是获得最佳效率的途径。只有那些需求变更频繁的项目才是践行敏捷实践的最佳选择。因此，敏捷对传统瀑布而言并不是取代，⽽是互补，“稳态”和“敏态”会在长时期内和谐共存。 研发能力的中台化沉淀 研发各阶段的垂直能⼒必然会沉淀到中台，以统⼀服务化的形式对外提供服务。⽐如，代码覆盖率的统计能⼒会统⼀到⼀个单⼀的服务中，为各个语⾔的业务提供代码覆盖率的统计；再如，分布式编译加速的能⼒也会成为企业级的服务，为各种⼤型项目提供编译加速。 数据驱动下的效能提升 以后的决策⼀定会基于数据来开展。效能提升实践的效果衡量也会⾼度依赖于数据。研发效能数据中台的建设必定会被提上⽇程，通过收集存储研发各阶段的各种过程数据，实现基于研发效能⼤数据平台的决策体系 进阶解读 软件生产作为智⼒密集型活动，掺杂着⼤量人的因素，很难严格地标准化 质量和效能是“既要、也要”的关系，效能的提升能够将软件研发中的⻛险更快、更及时地暴露出来，同时减轻⼈脑负担，反过来⼜ 能提升质量本身 渴望尊重和欣赏，是⼈性的需求之⼀。适度的关注和赞美能够产⽣强烈的心理暗示，继而带来效能的提升 反摩尔定律告诉我们，越迟交付的价值其价值越低 信息熵衰减对研发效能的影响是巨⼤的，要想方设法将信息传递的效率提升上去 自解释的代码不是无注释和无文档的代码，而是伴随着⾼信息熵的代码体系。内容简洁合理的注释与⽂档，同样也是优秀代码的⼀部分，能够给效能的提升带来帮助 基于流程优化，打破各个环节看不见的墙，去除不必要的等待，提升价值流动速度，这些是研发效能试图解决的一大类问题 项目管理提效 敏捷宣言","keywords":["软件研发效能提升之美"],"articleBody":"内容《软件研发效能提升之美》之书 总论 研发效能是多⼈组织协同效率的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统\n研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视 整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率\n**没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍\n希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业\n敏捷作为⼀种通过创造变化和响应变化在不确定和混乱的环境中取得成功的能力，具备高度的实践性和创造性，这样的特性在赋予敏捷强大适配度的同时，也给落地造成了困难\n概述 研发效能提升案例\n前端代码的自动生成\n我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。\n这种方式的引入将大幅提升原型构建环节的效率\n临界参数下的API测试\n考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值\n进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露\n例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题\n基于流程优化的效能提升\n效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便 第一性原理：顺畅、高质量地持续交付有效价值的闭环\n顺畅：价值的流动过程必须顺畅，没有阻碍 高质量：如果质量不行，那么流动越快，死得也会越快 **持续：**不能时断时续，小步快跑才是正道 **有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题 **闭环：**强调快速反馈的重要性 鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让 鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋 从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践\n举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤\n架构相对简单，但是集群规模庞大，则优选金丝雀 架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势 研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的\n研发效能提升实践：\n找钉子，场景举例：\n本地编译耗时长：提供增量编译和分布式编译能力 本地测试困难，测试环境准备复杂且耗时长：基于Kubernetes的Pod提供⼀键搭建测试环境的能力 自动化测试用例数量大，执行回归时间过长：采用并发测试用例执行机制，使用几百、几千台测试执行机并行执行用例，实现用硬件资源换时间 自动化测试用例维护成本高：测试用例采用模块化和分层体系，实现低成本的自动化用例维护 测试数据准备困难：引入统⼀的测试数据服务（Test DataService）能力 集群规模庞大，发布过程耗时过长：各个层级的并发部署能力，集群内节点的并发、集群间的并发等。 项目的过程数据都是后期集中填充，失去度量意义：项目的过程数据由⼯具自动填充，不再依赖⼯程师手工输入。比如，开发完成的时间不再依赖于开发人员手工填写，而是由Jenkins构建完成后自动填写，以保证所有过程数据的真实有效性，从⽽为后面的度量和改进提供可靠的信息输入 全局切入：\n软件缺陷的流转，软件需求的实现与交付，软件制品包发布等待 持续改进：\n比如，需要在Jenkins中通过hook机制去触发⼀些操作（比如代码静态扫描、单元测试等），最简单的做法就是在hook中实现操作的具体步骤，这种实现在开始时效率很高，也非常容易实现，但却不是最优的⽅案，因为hook中的代码只会被执行⼀次，而且hook越来越多以后，各种实现都散落在各个地方，难以维护，⼀旦有新的需要（比如要加⼊慢SQL扫描），就需要改hook实现，而且这种做法也违背了IaC（Infrastructure as Code）原则。\n更好的做法是引入研发效能的消息中心，通过下游操作的订阅模式来实现未来的可扩展性\n效能平台的灵活性\n将Jenkins持续集成⼯具视为⼀个平台，在这个平台上支持安装各种插件，以增强平台功能，从而实现平台架构的灵活性 杜绝\"掩耳盗铃\"\n代码质量门禁Sonar设而不卡 单元测试只是执行，不写断⾔Assert 代码覆盖率形同虚设 Peer Review走过场 代码递交过于随意 监控超配，有报警但无人认领 发展方向与未来展望\n研发各个环节的全链路横向打通 CI/CD和测试不再是⼀个个独立的环节，软件研发从需求开始到最终线上交付采用⼀站式的研发效能平台，实现统⼀的研发⼯具和流程 研发全流程的可视化 研发流程的可视化在后期⼀定会成为⾏业的标配，通过流程的可视化，可以展示各个需求的进展情况，让各级管理者和⼀线⼯程师清楚地知道项目目前所处的状态。 “稳态”和“敏态”齐头并进 研发效能的提升并不⼀定都要绑定到敏捷开发实践上，事实上，对于那些需求明确并且稳定的项目，传统的瀑布模型依然是最佳的选择，此时采用“稳态”实践才是获得最佳效率的途径。只有那些需求变更频繁的项目才是践行敏捷实践的最佳选择。因此，敏捷对传统瀑布而言并不是取代，⽽是互补，“稳态”和“敏态”会在长时期内和谐共存。 研发能力的中台化沉淀 研发各阶段的垂直能⼒必然会沉淀到中台，以统⼀服务化的形式对外提供服务。⽐如，代码覆盖率的统计能⼒会统⼀到⼀个单⼀的服务中，为各个语⾔的业务提供代码覆盖率的统计；再如，分布式编译加速的能⼒也会成为企业级的服务，为各种⼤型项目提供编译加速。 数据驱动下的效能提升 以后的决策⼀定会基于数据来开展。效能提升实践的效果衡量也会⾼度依赖于数据。研发效能数据中台的建设必定会被提上⽇程，通过收集存储研发各阶段的各种过程数据，实现基于研发效能⼤数据平台的决策体系 进阶解读 软件生产作为智⼒密集型活动，掺杂着⼤量人的因素，很难严格地标准化 质量和效能是“既要、也要”的关系，效能的提升能够将软件研发中的⻛险更快、更及时地暴露出来，同时减轻⼈脑负担，反过来⼜ 能提升质量本身 渴望尊重和欣赏，是⼈性的需求之⼀。适度的关注和赞美能够产⽣强烈的心理暗示，继而带来效能的提升 反摩尔定律告诉我们，越迟交付的价值其价值越低 信息熵衰减对研发效能的影响是巨⼤的，要想方设法将信息传递的效率提升上去 自解释的代码不是无注释和无文档的代码，而是伴随着⾼信息熵的代码体系。内容简洁合理的注释与⽂档，同样也是优秀代码的⼀部分，能够给效能的提升带来帮助 基于流程优化，打破各个环节看不见的墙，去除不必要的等待，提升价值流动速度，这些是研发效能试图解决的一大类问题 项目管理提效 敏捷宣言\n个体和互动 高于 流程和⼯具 工作的软件 高于 详尽的⽂档 客户合作 高于 合同谈判 响应变化 高于 遵循计划 敏捷项目提升五大要素 自组织团队 自组织是指⼀个系统在内在机制的驱动下，自行从简单向复杂、从粗糙向细致方向发展，不断地提高自身的复杂度和精细度的过程 首先，团队成员可以在迭代过程中选择自己擅长的任务，而非硬性分配，在这 种自适应的过程中，团队很容易形成更优的分工安排，这有助于发挥 每个⼈的⼒量，达成全局效率最优 其次，自组织团队倡导人人有责，弱化职级和职位，每个⼈都要提升⾃我，为组织出力，形成正向交互 最后，自组织团队天然的自由氛围，为团队的每个人提供了充分发表意见和想法的机会，这往往会带来更好的解决方案，促进效能的提升 持续改进 鼓励团队花时间反思，并勇于抛出问题，能够有效避免当前迭代中已经发⽣的问题流入下⼀个迭代周期，从⻓远的⾓度看，这样持续改进的团队⼀定会成为⼀个高效的团队 频繁交付 团队需要转变观念，摒弃以自我为中心的思考方式 要做好迭代周期的管理、任务的拆解等⼯作 消除对立 敏捷团队的所有角色需要朝着共同的目标前进，荣辱与共 在实践上，尽量避免针对不同的⾓⾊制定可能会产⽣冲突的KPI 对测试人员制定Bug数量的KPI，针对研发人员则制定相反（解决Bug数 量）的KPI。我们甚至建议对整个项目的参与人员制定共同的KPI 如果项目失败或延期，那么整个团队都应该为此负责，并持续改进 未雨绸缪 敏捷管理模式是拥抱变化的，其中⼀项重要的特点就是风险管控，提高对项目有利的事件发生的可能性及其影响力，同时减少对项目不利的事件发生的可能性，并尽可能减少其负面效应 实践常见误区 敏捷开发就是快速开发 如果我们回过头重新阅读⼀下敏捷宣言，就会发现敏捷开发最⼤的关注点其实是价值交付，而价值交付最核心的⼀点就是质量 敏捷开发应当抛弃文档 文档传递的信息熵⼀般比语音沟通更⾼，因此文字是⼀种非常好的信息传输介质。但同时，文档作为⼀种持久化的媒体，需要进行同步和维护，这些隐性的代价也是 需要重视的 敏捷开发只适合小微团队 大型团队可以通过合理的组织拆分，建立多个负责相对独⽴功能模块的Scrum团队，达成全局敏捷的目标 敏捷开发论为小瀑布开发 迭代开发将一个大任务，分解成多次连续的开发，本质就是逐步改进，开发者先快速发布一个有效但不完美的最简版本，然后不断迭代。每一次迭代都包含规划、设计、编码、测试、评估五个步骤，不断改进产品，添加新功能。通过频繁的发布，以及跟踪对前一次迭代的反馈，最终接近较完善的产品形态 所谓\"增量开发\"，指的是软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代 敏捷没有约束的 在⼀个迭代周期内，团队只负责完成当前迭代计划的任务，如果有其他任务加进 来，比如需求变更，只能延迟到下⼀个迭代周期 建立度量体系（之后可视化等等写，这种不太重要对我现在） 之后写 ","wordCount":"130","inLanguage":"en","datePublished":"2025-03-01T18:54:14+08:00","dateModified":"2025-03-01T18:54:14+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/efficiency00/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>《软件研发效能提升之美00》</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%86%85%e5%ae%b9%e8%bd%af%e4%bb%b6%e7%a0%94%e5%8f%91%e6%95%88%e8%83%bd%e6%8f%90%e5%8d%87%e4%b9%8b%e7%be%8e%e4%b9%8b%e4%b9%a6 aria-label=内容《软件研发效能提升之美》之书>内容《软件研发效能提升之美》之书</a><ul><li><a href=#%e6%80%bb%e8%ae%ba aria-label=总论>总论</a></li><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a></li><li><a href=#%e8%bf%9b%e9%98%b6%e8%a7%a3%e8%af%bb aria-label=进阶解读>进阶解读</a></li><li><a href=#%e9%a1%b9%e7%9b%ae%e7%ae%a1%e7%90%86%e6%8f%90%e6%95%88 aria-label=项目管理提效>项目管理提效</a><ul><li><a href=#%e6%95%8f%e6%8d%b7%e9%a1%b9%e7%9b%ae%e6%8f%90%e5%8d%87%e4%ba%94%e5%a4%a7%e8%a6%81%e7%b4%a0 aria-label=敏捷项目提升五大要素><strong>敏捷项目提升五大要素</strong></a></li><li><a href=#%e5%ae%9e%e8%b7%b5%e5%b8%b8%e8%a7%81%e8%af%af%e5%8c%ba aria-label=实践常见误区><strong>实践常见误区</strong></a></li><li><a href=#%e5%bb%ba%e7%ab%8b%e5%ba%a6%e9%87%8f%e4%bd%93%e7%b3%bb%e4%b9%8b%e5%90%8e%e5%8f%af%e8%a7%86%e5%8c%96%e7%ad%89%e7%ad%89%e5%86%99%e8%bf%99%e7%a7%8d%e4%b8%8d%e5%a4%aa%e9%87%8d%e8%a6%81%e5%af%b9%e6%88%91%e7%8e%b0%e5%9c%a8 aria-label=建立度量体系（之后可视化等等写，这种不太重要对我现在）>建立度量体系（之后可视化等等写，这种不太重要对我现在）</a></li></ul></li><li><a href=#%e4%b9%8b%e5%90%8e%e5%86%99 aria-label=之后写>之后写</a></li></ul></li></ul></div></details></div><div class=post-content><h3 id=内容软件研发效能提升之美之书>内容《软件研发效能提升之美》之书<a hidden class=anchor aria-hidden=true href=#内容软件研发效能提升之美之书>#</a></h3><h4 id=总论>总论<a hidden class=anchor aria-hidden=true href=#总论>#</a></h4><ul><li><p>研发效能是<strong>多⼈组织协同效率</strong>的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统</p></li><li><p>研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视
整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率</p></li><li><p>**没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍</p></li><li><p><strong>希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业</strong></p></li><li><p>敏捷作为⼀种通过创造变化和响应变化在不确定和混乱的环境中取得成功的能力，具备高度的实践性和创造性，这样的特性在赋予敏捷强大适配度的同时，也给落地造成了困难</p></li></ul><h4 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h4><ul><li><p><strong>研发效能提升案例</strong></p><ul><li><p>前端代码的自动生成</p><ul><li><p>我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。</p><p><strong>这种方式的引入将大幅提升原型构建环节的效率</strong></p></li></ul></li><li><p>临界参数下的API测试</p><ul><li><p>考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值</p><p><strong>进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露</strong></p></li><li><p>例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题</p></li></ul></li><li><p>基于流程优化的效能提升</p><ul><li>效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便</li></ul></li></ul></li><li><p><strong>第一性原理：顺畅、高质量地持续交付有效价值的闭环</strong></p><ul><li><strong>顺畅</strong>：价值的流动过程必须顺畅，没有阻碍
<strong>高质量</strong>：如果质量不行，那么流动越快，死得也会越快
**持续：**不能时断时续，小步快跑才是正道
**有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题
**闭环：**强调快速反馈的重要性</li><li>鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让
鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋</li></ul></li><li><p>从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践</p><p><img loading=lazy src=../../static/png/image-20250301214927395.png alt=image-20250301214927395></p><p><strong>举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤</strong></p><ul><li>架构相对简单，但是集群规模庞大，则优选金丝雀</li><li>架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势</li></ul></li><li><p>研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的</p></li><li><p><strong>研发效能提升实践：</strong></p><ul><li><p><strong>找钉子</strong>，场景举例：</p><ul><li>本地编译耗时长：提供增量编译和分布式编译能力</li><li>本地测试困难，测试环境准备复杂且耗时长：基于Kubernetes的Pod提供⼀键搭建测试环境的能力</li><li>自动化测试用例数量大，执行回归时间过长：采用并发测试用例执行机制，使用几百、几千台测试执行机并行执行用例，实现用硬件资源换时间</li><li>自动化测试用例维护成本高：测试用例采用模块化和分层体系，实现低成本的自动化用例维护</li><li>测试数据准备困难：引入统⼀的测试数据服务（Test DataService）能力</li><li>集群规模庞大，发布过程耗时过长：各个层级的并发部署能力，集群内节点的并发、集群间的并发等。</li><li>项目的过程数据都是后期集中填充，失去度量意义：项目的过程数据由⼯具自动填充，不再依赖⼯程师手工输入。比如，开发完成的时间不再依赖于开发人员手工填写，而是由Jenkins构建完成后自动填写，以保证所有过程数据的真实有效性，从⽽为后面的度量和改进提供可靠的信息输入</li></ul></li><li><p><strong>全局切入：</strong></p><ul><li>软件缺陷的流转，软件需求的实现与交付，软件制品包发布等待</li></ul></li><li><p><strong>持续改进：</strong></p><ul><li><p>比如，需要在Jenkins中通过hook机制去触发⼀些操作（比如代码静态扫描、单元测试等），最简单的做法就是在hook中实现操作的具体步骤，这种实现在开始时效率很高，也非常容易实现，但却不是最优的⽅案，因为hook中的代码只会被执行⼀次，而且hook越来越多以后，各种实现都散落在各个地方，难以维护，⼀旦有新的需要（比如要加⼊慢SQL扫描），就需要改hook实现，而且这种做法也违背了IaC（Infrastructure as Code）原则。</p><p>更好的做法是引入研发效能的消息中心，通过下游操作的订阅模式来实现未来的可扩展性</p></li></ul></li><li><p><strong>效能平台的灵活性</strong></p><ul><li>将Jenkins持续集成⼯具视为⼀个平台，在这个平台上支持安装各种插件，以增强平台功能，从而实现平台架构的灵活性</li></ul></li><li><p><strong>杜绝"掩耳盗铃"</strong></p><ul><li>代码质量门禁Sonar设而不卡</li><li>单元测试只是执行，不写断⾔Assert</li><li>代码覆盖率形同虚设</li><li>Peer Review走过场</li><li>代码递交过于随意</li><li>监控超配，有报警但无人认领</li></ul></li><li><p><strong>发展方向与未来展望</strong></p><ul><li>研发各个环节的全链路横向打通
CI/CD和测试不再是⼀个个独立的环节，软件研发从需求开始到最终线上交付采用⼀站式的研发效能平台，实现统⼀的研发⼯具和流程</li><li>研发全流程的可视化
研发流程的可视化在后期⼀定会成为⾏业的标配，通过流程的可视化，可以展示各个需求的进展情况，让各级管理者和⼀线⼯程师清楚地知道项目目前所处的状态。</li><li>“稳态”和“敏态”齐头并进
研发效能的提升并不⼀定都要绑定到敏捷开发实践上，事实上，对于那些需求明确并且稳定的项目，传统的瀑布模型依然是最佳的选择，此时采用“稳态”实践才是获得最佳效率的途径。只有那些需求变更频繁的项目才是践行敏捷实践的最佳选择。因此，敏捷对传统瀑布而言并不是取代，⽽是互补，“稳态”和“敏态”会在长时期内和谐共存。</li><li>研发能力的中台化沉淀
研发各阶段的垂直能⼒必然会沉淀到中台，以统⼀服务化的形式对外提供服务。⽐如，代码覆盖率的统计能⼒会统⼀到⼀个单⼀的服务中，为各个语⾔的业务提供代码覆盖率的统计；再如，分布式编译加速的能⼒也会成为企业级的服务，为各种⼤型项目提供编译加速。</li><li>数据驱动下的效能提升
以后的决策⼀定会基于数据来开展。效能提升实践的效果衡量也会⾼度依赖于数据。研发效能数据中台的建设必定会被提上⽇程，通过收集存储研发各阶段的各种过程数据，实现基于研发效能⼤数据平台的决策体系</li></ul></li></ul></li></ul><h4 id=进阶解读>进阶解读<a hidden class=anchor aria-hidden=true href=#进阶解读>#</a></h4><ul><li>软件生产作为智⼒密集型活动，掺杂着⼤量人的因素，很难严格地标准化</li><li>质量和效能是“既要、也要”的关系，效能的提升能够将软件研发中的⻛险更快、更及时地暴露出来，同时减轻⼈脑负担，反过来⼜
能提升质量本身</li><li>渴望尊重和欣赏，是⼈性的需求之⼀。适度的关注和赞美能够产⽣强烈的心理暗示，继而带来效能的提升</li><li>反摩尔定律告诉我们，越迟交付的价值其价值越低</li><li>信息熵衰减对研发效能的影响是巨⼤的，要想方设法将信息传递的效率提升上去</li><li>自解释的代码不是无注释和无文档的代码，而是伴随着⾼信息熵的代码体系。内容简洁合理的注释与⽂档，同样也是优秀代码的⼀部分，能够给效能的提升带来帮助</li><li>基于流程优化，打破各个环节看不见的墙，去除不必要的等待，提升价值流动速度，这些是研发效能试图解决的一大类问题</li></ul><h4 id=项目管理提效>项目管理提效<a hidden class=anchor aria-hidden=true href=#项目管理提效>#</a></h4><ul><li><p><strong>敏捷宣言</strong></p><ul><li>个体和互动 高于 流程和⼯具
工作的软件 高于 详尽的⽂档
客户合作 高于 合同谈判
响应变化 高于 遵循计划</li></ul></li><li><h5 id=敏捷项目提升五大要素><strong>敏捷项目提升五大要素</strong><a hidden class=anchor aria-hidden=true href=#敏捷项目提升五大要素>#</a></h5><ul><li>自组织团队<ul><li>自组织是指⼀个系统在内在机制的驱动下，自行从简单向复杂、从粗糙向细致方向发展，不断地提高自身的复杂度和精细度的过程</li><li>首先，团队成员可以在迭代过程中选择自己擅长的任务，而非硬性分配，在这
种自适应的过程中，团队很容易形成更优的分工安排，这有助于发挥
每个⼈的⼒量，达成全局效率最优</li><li>其次，自组织团队倡导人人有责，弱化职级和职位，每个⼈都要提升⾃我，为组织出力，形成正向交互</li><li>最后，自组织团队天然的自由氛围，为团队的每个人提供了充分发表意见和想法的机会，这往往会带来更好的解决方案，促进效能的提升</li></ul></li><li>持续改进<ul><li>鼓励团队花时间反思，并勇于抛出问题，能够有效避免当前迭代中已经发⽣的问题流入下⼀个迭代周期，从⻓远的⾓度看，这样持续改进的团队⼀定会成为⼀个高效的团队</li></ul></li><li>频繁交付<ol><li>团队需要转变观念，摒弃以自我为中心的思考方式</li><li>要做好迭代周期的管理、任务的拆解等⼯作</li></ol></li><li>消除对立<ul><li>敏捷团队的所有角色需要朝着共同的目标前进，荣辱与共</li><li>在实践上，尽量避免针对不同的⾓⾊制定可能会产⽣冲突的KPI<ul><li>对测试人员制定Bug数量的KPI，针对研发人员则制定相反（解决Bug数
量）的KPI。我们甚至建议对整个项目的参与人员制定共同的KPI</li><li>如果项目失败或延期，那么整个团队都应该为此负责，并持续改进</li></ul></li></ul></li><li>未雨绸缪<ul><li>敏捷管理模式是拥抱变化的，其中⼀项重要的特点就是风险管控，提高对项目有利的事件发生的可能性及其影响力，同时减少对项目不利的事件发生的可能性，并尽可能减少其负面效应</li></ul></li></ul></li><li><h5 id=实践常见误区><strong>实践常见误区</strong><a hidden class=anchor aria-hidden=true href=#实践常见误区>#</a></h5><ul><li>敏捷开发就是快速开发<ul><li>如果我们回过头重新阅读⼀下敏捷宣言，就会发现敏捷开发最⼤的关注点其实是价值交付，而价值交付最核心的⼀点就是质量</li></ul></li><li>敏捷开发应当抛弃文档<ul><li>文档传递的信息熵⼀般比语音沟通更⾼，因此文字是⼀种非常好的信息传输介质。但同时，文档作为⼀种持久化的媒体，需要进行同步和维护，这些隐性的代价也是
需要重视的</li></ul></li><li>敏捷开发只适合小微团队<ul><li>大型团队可以通过合理的组织拆分，建立多个负责相对独⽴功能模块的Scrum团队，达成全局敏捷的目标</li></ul></li><li>敏捷开发论为小瀑布开发<ul><li><strong>迭代开发将一个大任务，分解成多次连续的开发，本质就是逐步改进</strong>，开发者先快速发布一个有效但不完美的最简版本，然后不断迭代。每一次迭代都包含规划、设计、编码、测试、评估五个步骤，不断改进产品，添加新功能。通过频繁的发布，以及跟踪对前一次迭代的反馈，最终接近较完善的产品形态</li><li><strong>所谓"增量开发"，指的是软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代</strong></li></ul></li><li>敏捷没有约束的<ul><li>在⼀个迭代周期内，团队只负责完成当前迭代计划的任务，如果有其他任务加进
来，比如需求变更，只能延迟到下⼀个迭代周期</li></ul></li></ul></li><li><h5 id=建立度量体系之后可视化等等写这种不太重要对我现在>建立度量体系（之后可视化等等写，这种不太重要对我现在）<a hidden class=anchor aria-hidden=true href=#建立度量体系之后可视化等等写这种不太重要对我现在>#</a></h5></li></ul><h4 id=之后写>之后写<a hidden class=anchor aria-hidden=true href=#之后写>#</a></h4></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E6%95%88%E8%83%BD%E6%8F%90%E5%8D%87%E4%B9%8B%E7%BE%8E/>软件研发效能提升之美</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/efficiency01/><span class=title>« Prev Page</span><br><span>《软件研发效能提升之美01》</span>
</a><a class=next href=https://zwlzls.github.io/posts/algorithm06/><span class=title>Next Page »</span><br><span>数据结构知识</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>