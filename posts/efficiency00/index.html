<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>《软件研发效能提升之美00》 | 我的博客</title>
<meta name=keywords content="软件研发效能提升之美"><meta name=description content="内容《软件研发效能提升之美》之书 总论 研发效能是多⼈组织协同效率的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统 研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视 整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率 **没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍 希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业 概述 研发效能提升案例
前端代码的自动生成
我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。
这种方式的引入将大幅提升原型构建环节的效率
临界参数下的API测试
考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值
进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露
例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题
基于流程优化的效能提升
效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便 第一性原理：顺畅、高质量地持续交付有效价值的闭环
顺畅：价值的流动过程必须顺畅，没有阻碍 高质量：如果质量不行，那么流动越快，死得也会越快 **持续：**不能时断时续，小步快跑才是正道 **有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题 **闭环：**强调快速反馈的重要性 鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让 鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋 从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践
举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤
架构相对简单，但是集群规模庞大，则优选金丝雀 架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势 研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的
研发效能提升实践： +"><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/efficiency00/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/efficiency00/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="《软件研发效能提升之美00》"><meta property="og:description" content="内容《软件研发效能提升之美》之书 总论 研发效能是多⼈组织协同效率的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统 研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视 整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率 **没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍 希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业 概述 研发效能提升案例
前端代码的自动生成
我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。
这种方式的引入将大幅提升原型构建环节的效率
临界参数下的API测试
考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值
进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露
例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题
基于流程优化的效能提升
效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便 第一性原理：顺畅、高质量地持续交付有效价值的闭环
顺畅：价值的流动过程必须顺畅，没有阻碍 高质量：如果质量不行，那么流动越快，死得也会越快 **持续：**不能时断时续，小步快跑才是正道 **有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题 **闭环：**强调快速反馈的重要性 鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让 鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋 从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践
举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤
架构相对简单，但是集群规模庞大，则优选金丝雀 架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势 研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的
研发效能提升实践： +"><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/efficiency00/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-01T18:54:14+08:00"><meta property="article:modified_time" content="2025-03-01T18:54:14+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="《软件研发效能提升之美00》"><meta name=twitter:description content="内容《软件研发效能提升之美》之书 总论 研发效能是多⼈组织协同效率的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统 研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视 整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率 **没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍 希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业 概述 研发效能提升案例
前端代码的自动生成
我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。
这种方式的引入将大幅提升原型构建环节的效率
临界参数下的API测试
考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值
进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露
例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题
基于流程优化的效能提升
效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便 第一性原理：顺畅、高质量地持续交付有效价值的闭环
顺畅：价值的流动过程必须顺畅，没有阻碍 高质量：如果质量不行，那么流动越快，死得也会越快 **持续：**不能时断时续，小步快跑才是正道 **有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题 **闭环：**强调快速反馈的重要性 鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让 鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋 从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践
举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤
架构相对简单，但是集群规模庞大，则优选金丝雀 架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势 研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的
研发效能提升实践： +"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"《软件研发效能提升之美00》","item":"https://zwlzls.github.io/posts/efficiency00/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"《软件研发效能提升之美00》","name":"《软件研发效能提升之美00》","description":"内容《软件研发效能提升之美》之书 总论 研发效能是多⼈组织协同效率的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统 研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视 整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率 **没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍 希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业 概述 研发效能提升案例\n前端代码的自动生成\n我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。\n这种方式的引入将大幅提升原型构建环节的效率\n临界参数下的API测试\n考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值\n进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露\n例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题\n基于流程优化的效能提升\n效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便 第一性原理：顺畅、高质量地持续交付有效价值的闭环\n顺畅：价值的流动过程必须顺畅，没有阻碍 高质量：如果质量不行，那么流动越快，死得也会越快 **持续：**不能时断时续，小步快跑才是正道 **有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题 **闭环：**强调快速反馈的重要性 鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让 鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋 从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践\n举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤\n架构相对简单，但是集群规模庞大，则优选金丝雀 架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势 研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的\n研发效能提升实践： +","keywords":["软件研发效能提升之美"],"articleBody":"内容《软件研发效能提升之美》之书 总论 研发效能是多⼈组织协同效率的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统 研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视 整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率 **没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍 希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业 概述 研发效能提升案例\n前端代码的自动生成\n我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。\n这种方式的引入将大幅提升原型构建环节的效率\n临界参数下的API测试\n考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值\n进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露\n例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题\n基于流程优化的效能提升\n效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便 第一性原理：顺畅、高质量地持续交付有效价值的闭环\n顺畅：价值的流动过程必须顺畅，没有阻碍 高质量：如果质量不行，那么流动越快，死得也会越快 **持续：**不能时断时续，小步快跑才是正道 **有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题 **闭环：**强调快速反馈的重要性 鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让 鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋 从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践\n举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤\n架构相对简单，但是集群规模庞大，则优选金丝雀 架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势 研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的\n研发效能提升实践： +\n","wordCount":"33","inLanguage":"en","datePublished":"2025-03-01T18:54:14+08:00","dateModified":"2025-03-01T18:54:14+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/efficiency00/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>《软件研发效能提升之美00》</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%86%85%e5%ae%b9%e8%bd%af%e4%bb%b6%e7%a0%94%e5%8f%91%e6%95%88%e8%83%bd%e6%8f%90%e5%8d%87%e4%b9%8b%e7%be%8e%e4%b9%8b%e4%b9%a6 aria-label=内容《软件研发效能提升之美》之书>内容《软件研发效能提升之美》之书</a><ul><li><a href=#%e6%80%bb%e8%ae%ba aria-label=总论>总论</a></li><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a></li></ul></li></ul></div></details></div><div class=post-content><h3 id=内容软件研发效能提升之美之书>内容《软件研发效能提升之美》之书<a hidden class=anchor aria-hidden=true href=#内容软件研发效能提升之美之书>#</a></h3><h4 id=总论>总论<a hidden class=anchor aria-hidden=true href=#总论>#</a></h4><ul><li>研发效能是<strong>多⼈组织协同效率</strong>的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统</li><li>研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视
整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率</li><li>**没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍</li><li><strong>希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业</strong></li></ul><h4 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h4><ul><li><p><strong>研发效能提升案例</strong></p><ul><li><p>前端代码的自动生成</p><ul><li><p>我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。</p><p><strong>这种方式的引入将大幅提升原型构建环节的效率</strong></p></li></ul></li><li><p>临界参数下的API测试</p><ul><li><p>考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值</p><p><strong>进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露</strong></p></li><li><p>例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题</p></li></ul></li><li><p>基于流程优化的效能提升</p><ul><li>效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便</li></ul></li></ul></li><li><p><strong>第一性原理：顺畅、高质量地持续交付有效价值的闭环</strong></p><ul><li><strong>顺畅</strong>：价值的流动过程必须顺畅，没有阻碍
<strong>高质量</strong>：如果质量不行，那么流动越快，死得也会越快
**持续：**不能时断时续，小步快跑才是正道
**有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题
**闭环：**强调快速反馈的重要性</li><li>鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让
鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋</li></ul></li><li><p>从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践</p><p><img loading=lazy src=../../static/png/image-20250301214927395.png alt=image-20250301214927395></p><p><strong>举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤</strong></p><ul><li>架构相对简单，但是集群规模庞大，则优选金丝雀</li><li>架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势</li></ul></li><li><p>研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的</p></li><li><p><strong>研发效能提升实践：</strong>
+</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E6%95%88%E8%83%BD%E6%8F%90%E5%8D%87%E4%B9%8B%E7%BE%8E/>软件研发效能提升之美</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/efficiency01/><span class=title>« Prev Page</span><br><span>Efficiency01</span>
</a><a class=next href=https://zwlzls.github.io/posts/algorithm06/><span class=title>Next Page »</span><br><span>数据结构知识</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>