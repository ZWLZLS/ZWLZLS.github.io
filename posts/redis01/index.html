<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis(持久化一致性淘汰) | 我的博客</title>
<meta name=keywords content="Redis"><meta name=description content="持久化 AOF 文件的内容是操作命令； RDB 文件的内容是二进制数据 AOF Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 redis.conf
Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里
这保存写操作命令到日志的持久化方式，是 Redis 里的 AOF(Append Only File) 持久化功能，注意只会记录写操作命令，读操作命令是不会被记录的
Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的
避免额外的检查开销 不会阻塞当前写操作命令的执行，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志 风险：
执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险 写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是可能会给「下一个」命令带来阻塞风险 执行过程：
Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区； 通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘； 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定 写回硬盘策略： Always，「总是」，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘； Everysec，「每秒」，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，每隔一秒将缓冲区里的内容写回到硬盘； No，不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘 AOF重写机制
AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大 Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制 机制是在重写时，读取当前数据库中的所有键值对，将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件 妙处在于：尽管某个键值对被多条写命令反复修改，最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对 AOF后台重写"><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/redis01/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/redis01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Redis(持久化一致性淘汰)"><meta property="og:description" content="持久化 AOF 文件的内容是操作命令； RDB 文件的内容是二进制数据 AOF Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 redis.conf
Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里
这保存写操作命令到日志的持久化方式，是 Redis 里的 AOF(Append Only File) 持久化功能，注意只会记录写操作命令，读操作命令是不会被记录的
Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的
避免额外的检查开销 不会阻塞当前写操作命令的执行，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志 风险：
执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险 写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是可能会给「下一个」命令带来阻塞风险 执行过程：
Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区； 通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘； 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定 写回硬盘策略： Always，「总是」，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘； Everysec，「每秒」，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，每隔一秒将缓冲区里的内容写回到硬盘； No，不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘 AOF重写机制
AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大 Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制 机制是在重写时，读取当前数据库中的所有键值对，将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件 妙处在于：尽管某个键值对被多条写命令反复修改，最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对 AOF后台重写"><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/redis01/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-10T15:11:19+08:00"><meta property="article:modified_time" content="2025-02-10T15:11:19+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis(持久化一致性淘汰)"><meta name=twitter:description content="持久化 AOF 文件的内容是操作命令； RDB 文件的内容是二进制数据 AOF Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 redis.conf
Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里
这保存写操作命令到日志的持久化方式，是 Redis 里的 AOF(Append Only File) 持久化功能，注意只会记录写操作命令，读操作命令是不会被记录的
Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的
避免额外的检查开销 不会阻塞当前写操作命令的执行，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志 风险：
执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险 写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是可能会给「下一个」命令带来阻塞风险 执行过程：
Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区； 通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘； 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定 写回硬盘策略： Always，「总是」，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘； Everysec，「每秒」，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，每隔一秒将缓冲区里的内容写回到硬盘； No，不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘 AOF重写机制
AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大 Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制 机制是在重写时，读取当前数据库中的所有键值对，将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件 妙处在于：尽管某个键值对被多条写命令反复修改，最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对 AOF后台重写"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Redis(持久化一致性淘汰)","item":"https://zwlzls.github.io/posts/redis01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis(持久化一致性淘汰)","name":"Redis(持久化一致性淘汰)","description":"持久化 AOF 文件的内容是操作命令； RDB 文件的内容是二进制数据 AOF Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 redis.conf\nRedis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里\n这保存写操作命令到日志的持久化方式，是 Redis 里的 AOF(Append Only File) 持久化功能，注意只会记录写操作命令，读操作命令是不会被记录的\nRedis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的\n避免额外的检查开销 不会阻塞当前写操作命令的执行，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志 风险：\n执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险 写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是可能会给「下一个」命令带来阻塞风险 执行过程：\nRedis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区； 通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘； 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定 写回硬盘策略： Always，「总是」，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘； Everysec，「每秒」，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，每隔一秒将缓冲区里的内容写回到硬盘； No，不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘 AOF重写机制\nAOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大 Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制 机制是在重写时，读取当前数据库中的所有键值对，将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件 妙处在于：尽管某个键值对被多条写命令反复修改，最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对 AOF后台重写","keywords":["Redis"],"articleBody":"持久化 AOF 文件的内容是操作命令； RDB 文件的内容是二进制数据 AOF Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 redis.conf\nRedis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里\n这保存写操作命令到日志的持久化方式，是 Redis 里的 AOF(Append Only File) 持久化功能，注意只会记录写操作命令，读操作命令是不会被记录的\nRedis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的\n避免额外的检查开销 不会阻塞当前写操作命令的执行，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志 风险：\n执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险 写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是可能会给「下一个」命令带来阻塞风险 执行过程：\nRedis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区； 通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘； 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定 写回硬盘策略： Always，「总是」，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘； Everysec，「每秒」，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，每隔一秒将缓冲区里的内容写回到硬盘； No，不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘 AOF重写机制\nAOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大 Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制 机制是在重写时，读取当前数据库中的所有键值对，将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件 妙处在于：尽管某个键值对被多条写命令反复修改，最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对 AOF后台重写\n写入 AOF 日志的操作是在主进程完成的，因为写入的内容不多，不太影响命令操作 Redis 的重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，避免阻塞主进程 子进程带有主进程的数据副本 重写 AOF 期间，当 Redis 执行完一个写命令之后，它会同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」 AOF 缓冲区：用于临时存储写命令，定期或根据策略写入 AOF 文件。 AOF 重写缓冲区：用于在 AOF 重写过程中临时存储新的写命令，确保重写期间的数据不丢失 RDB Redis 提供两个命令生成 RDB 文件，分别是 save 和 bgsave，区别是否在「主线程」里执行：\n执行了 save 命令，会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会阻塞主线程； 执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，可以避免主线程的阻塞 Redis 通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令\nsave 900 1 save 300 10 save 60 10000 满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：\n900 秒之内，对数据库进行了至少 1 次修改； 300 秒之内，对数据库进行了至少 10 次修改； 60 秒之内，对数据库进行了至少 10000 次修改 Redis 快照是全量快照，每次执行快照，是把内存中的「所有数据」都记录到磁盘中\nRDB 快照的缺点，在服务器发生故障时，丢失的数据会比 AOF 持久化的方式更多\n执行快照，数据能被修改吗\n执行 bgsave 过程，Redis 依然可以继续处理操作命令的，也就是数据是能被修改 主线程（父进程）要修改共享数据里的某一块数据（比如键值对 A）时，就会发生写时复制，于是这块数据的物理内存就会被复制一份（键值对 A'），然后主线程在这个数据副本（键值对 A'）进行修改操作。与此同时，bgsave 子进程可以继续把原来的数据（键值对 A）写入到 RDB 文件 bgsave 快照过程中，主线程修改了共享数据，发生了写时复制后，RDB 快照保存的是原本的内存数据，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照 RDB和AOF合体 RDB 恢复速度快的优点和有 AOF 丢失数据少的优点\n开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：\naof-use-rdb-preamble yes AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件\n使用了混合持久化，AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据\nRedis大key 对AOF持久化影响 当使用 Always 策略的时候，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的 对AOF重写和RDB影响 都会分别通过 fork() 函数创建子进程来处理任务。会有两个阶段会导致阻塞父进程（主线程） 创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长； 创建完子进程后，如果父进程修改了共享数据中的大 Key，就会发生写时复制，这期间会拷贝物理内存，由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程 其他影响 客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，很久很久都没有响应。 引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。 阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。 内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多 避免： 设计阶段，就把大 key 拆分成一个一个小 key 删除和淘汰策略 过期删除策略 Redis 是可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除\n设置过期时间\nexpire ：设置 key 在 n 秒后过期\n设置 key 在 100 秒后过期；\nexpire key 100 pexpire ：设置 key 在 n 毫秒后过期\n设置 key2 在 100000 毫秒（100 秒）后过期。\npexpire key2 100000 expireat ：设置 key 在某个时间戳（精确到秒）之后过期\nkey3 在时间戳 1655654400 后过期（精确到秒）；\nexpireat key3 1655654400 pexpireat ：设置 key 在某个时间戳（精确到毫秒）之后过期\nkey4 在时间戳 1655654400000 后过期（精确到毫秒）\npexpireat key4 1655654400000 在设置字符串时，同时对 key 设置过期时间\nset ex ：设置键值对的时候，同时指定过期时间（精确到秒）； set px ：设置键值对的时候，同时指定过期时间（精确到毫秒）； setex ：设置键值对的时候，同时指定过期时间（精确到秒） 查看某个 key 剩余的存活时间，可以使用 TTL 命令\n# 设置键值对的时候，同时指定过期时间位 60 秒 \u003e setex key1 60 value1 OK # 查看 key1 过期时间还剩多少 \u003e ttl key1 (integer) 56 \u003e ttl key1 (integer) 52 取消 key 的过期时间，使用 PERSIST 命令。\n# 取消 key1 的过期时间 \u003e persist key1 (integer) 1 # 使用完 persist 命令之后， # 查下 key1 的存活时间结果是 -1，表明 key1 永不过期 \u003e ttl key1 (integer) -1 常见三种过期删除策略，并不是redis会用\n定时删除： 在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作 优点： 保证过期 key 会被尽快删除，内存可以被尽快地释放 缺点： 过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间 惰性删除： 不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key 优点： 每次访问时，才会检查 key 是否过期，只会使用很少的系统资源 缺点： 如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费 定期删除： 每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key 优点： 通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用 缺点： 内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少 Redis过期删除\nRedis 选择「惰性删除+定期删除」这两种策略配和使用，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡\nRedis 实现惰性删除\nint expireIfNeeded(redisDb *db, robj *key) { // 判断 key 是否过期 if (!keyIsExpired(db,key)) return 0; .... /* 删除过期键 */ .... // 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除； return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key); } Redis 在访问或者修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期：\n如果过期，则删除该 key，至于选择异步删除，还是选择同步删除，根据 lazyfree_lazy_expire 参数配置决定（Redis 4.0版本开始提供参数），然后返回 null 客户端； 如果没有过期，不做任何处理，然后返回正常的键值对给客户端 Redis实现定期删除\ndo { //已过期的数量 expired = 0； //随机抽取的数量 num = 20; while (num--) { //1. 从过期字典中随机抽取 1 个 key //2. 判断该 key 是否过期，如果已过期则进行删除，同时对 expired++ } // 超过时间限制则退出 if (timelimit_exit) return; /* 如果本轮检查的已过期 key 的数量，超过 25%，则继续随机抽查，否则退出本轮检查 */ } while (expired \u003e 20/4); 每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key\n在 Redis 中，默认每秒进行 10 次过期检查一次数据库 可通过 Redis 的配置文件 redis.conf 进行配置 数据库每轮抽查时，会随机选择 20 个 key 判断是否过期 内存淘汰策略 配置文件 redis.conf 中，可以通过参数 maxmemory 来设定最大运行内存，只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略\n不进行数据淘汰的策略\nnoeviction（Redis3.0之后，默认的内存淘汰策略） ：当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入 进行数据淘汰的策略\n在设置了过期时间的数据中进行淘汰： volatile-random：随机淘汰设置了过期时间的任意键值； volatile-ttl：优先淘汰更早过期的键值。 volatile-lru（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值； volatile-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值； 在所有数据范围内进行淘汰： allkeys-random：随机淘汰任意键值; allkeys-lru：淘汰整个键值中最久未使用的键值； allkeys-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值 查看redis使用的内存淘汰策略\n使用 config get maxmemory-policy ，查看当前 Redis 的内存淘汰策略 ：\n127.0.0.1:6379\u003e config get maxmemory-policy 1) \"maxmemory-policy\" 2) \"noeviction\" LRU算法和LFU算法 LRU Least Recently Used 翻译为最近最少使用，会选择淘汰最近最少使用的数据 传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素 LFU Least Frequently Used 翻译为最近最不常用，LFU 算法是根据数据访问次数来淘汰数据的，核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高” 缓存异常 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能\n在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的缓存预热，后台更新缓存的机制刚好也适合干这个事情\n缓存雪崩 为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存 大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，就是缓存雪崩 原因及解决方案： 大量数据同时过期 均匀设置过期时间 给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间,对缓存数据设置过期时间时，给这些数据的过期时间加上一个随机数 互斥锁: 当业务线程在处理用户请求时，如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存 实现互斥锁的时候，最好设置超时时间，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象 后台更新缓存: 让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新 缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为当系统内存紧张的时候，有些缓存数据会被“淘汰” Redis故障宕机： 服务熔断或请求限流机制 启动服务熔断机制，暂停业务应用对缓存服务的访问，直接返回错误 为了减少对业务的影响，我们可以启用请求限流机制，只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制 构建 Redis 缓存高可靠集群 主从节点的方式构建 Redis 缓存高可靠集群 缓存击穿 业务通常会有几个数据被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据 缓存中的某个热点数据过期，大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，缓存击穿 解决方案: 互斥锁方案： 保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值 不给热点数据设置过期时间： 后台异步更新缓存 在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间 缓存穿透 当用户访问的数据，既不在缓存中，也不在数据库中，就是缓存穿透的问题\n发送原因\n业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据； 黑客恶意攻击，故意大量访问某些读取不存在数据的业务 解决方案：\n非法请求的限制 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误 缓存空值或者默认值 可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用 使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在： 布隆过滤器工作过程：\n布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。\n布隆过滤器通过 3 个操作完成标记：\n使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；\n将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。\n将每个哈希值在位图数组的对应位置的值设置为 1；\n数据库缓存一致性 ","wordCount":"716","inLanguage":"en","datePublished":"2025-02-10T15:11:19+08:00","dateModified":"2025-02-10T15:11:19+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/redis01/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Redis(持久化一致性淘汰)</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%8c%81%e4%b9%85%e5%8c%96 aria-label=持久化>持久化</a><ul><li><a href=#aof aria-label=AOF>AOF</a></li><li><a href=#rdb aria-label=RDB>RDB</a></li><li><a href=#rdb%e5%92%8caof%e5%90%88%e4%bd%93 aria-label=RDB和AOF合体>RDB和AOF合体</a></li><li><a href=#redis%e5%a4%a7key aria-label=Redis大key>Redis大key</a></li></ul></li><li><a href=#%e5%88%a0%e9%99%a4%e5%92%8c%e6%b7%98%e6%b1%b0%e7%ad%96%e7%95%a5 aria-label=删除和淘汰策略>删除和淘汰策略</a><ul><li><a href=#%e8%bf%87%e6%9c%9f%e5%88%a0%e9%99%a4%e7%ad%96%e7%95%a5 aria-label=过期删除策略>过期删除策略</a></li><li><a href=#%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e7%ad%96%e7%95%a5 aria-label=内存淘汰策略>内存淘汰策略</a></li><li><a href=#lru%e7%ae%97%e6%b3%95%e5%92%8clfu%e7%ae%97%e6%b3%95 aria-label=LRU算法和LFU算法>LRU算法和LFU算法</a></li></ul></li><li><a href=#%e7%bc%93%e5%ad%98%e5%bc%82%e5%b8%b8 aria-label=缓存异常>缓存异常</a><ul><li><a href=#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9 aria-label=缓存雪崩>缓存雪崩</a></li><li><a href=#%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf aria-label=缓存击穿>缓存击穿</a></li><li><a href=#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f aria-label=缓存穿透>缓存穿透</a></li></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7 aria-label=数据库缓存一致性>数据库缓存一致性</a></li></ul></div></details></div><div class=post-content><h3 id=持久化>持久化<a hidden class=anchor aria-hidden=true href=#持久化>#</a></h3><ul><li><strong>AOF 文件的内容是操作命令；</strong></li><li><strong>RDB 文件的内容是二进制数据</strong></li></ul><ul><li><h4 id=aof>AOF<a hidden class=anchor aria-hidden=true href=#aof>#</a></h4><ul><li><p>Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 <code>redis.conf</code></p></li><li><p>Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里</p><p>这保存写操作命令到日志的持久化方式，是 Redis 里的 <strong>AOF(Append Only File)</strong> 持久化功能，<strong>注意只会记录写操作命令，读操作命令是不会被记录的</strong></p></li><li><p>Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的</p><ul><li><strong>避免额外的检查开销</strong></li><li><strong>不会阻塞当前写操作命令的执行</strong>，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志</li></ul></li><li><p>风险：</p><ul><li>执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有<strong>丢失的风险</strong></li><li>写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是<strong>可能会给「下一个」命令带来阻塞风险</strong></li></ul></li><li><p>执行过程：</p><ul><li>Redis 执行完写操作命令后，会将命令追加到 <code>server.aof_buf</code> 缓冲区；</li><li>通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li><li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定<ul><li>写回硬盘策略：<ul><li><strong>Always</strong>，「总是」，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li><li><strong>Everysec</strong>，「每秒」，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，每隔一秒将缓冲区里的内容写回到硬盘；</li><li><strong>No</strong>，不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘</li></ul></li></ul></li></ul></li><li><p>AOF重写机制</p><ul><li>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大
Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong></li><li>机制是在重写时，读取当前数据库中的所有键值对，将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件</li><li>妙处在于：尽管某个键值对被多条写命令反复修改，<strong>最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对</strong></li></ul></li><li><p>AOF后台重写</p><ul><li>写入 AOF 日志的操作是在主进程完成的，因为写入的内容不多，不太影响命令操作</li><li>Redis 的<strong>重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的</strong><ul><li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，避免阻塞主进程</li><li>子进程带有主进程的数据副本</li></ul></li><li>重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong><ul><li><strong>AOF 缓冲区</strong>：用于临时存储写命令，定期或根据策略写入 AOF 文件。</li><li><strong>AOF 重写缓冲区</strong>：用于在 AOF 重写过程中临时存储新的写命令，确保重写期间的数据不丢失</li></ul></li></ul></li></ul></li><li><h4 id=rdb>RDB<a hidden class=anchor aria-hidden=true href=#rdb>#</a></h4><ul><li><p>Redis 提供两个命令生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>，区别是否在「主线程」里执行：</p><ul><li>执行了 save 命令，会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li><li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，可以<strong>避免主线程的阻塞</strong></li></ul></li><li><p>Redis 通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>save 900 1
</span></span><span style=display:flex><span>save 300 10
</span></span><span style=display:flex><span>save 60 10000
</span></span></code></pre></div><p>满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：</p><ul><li>900 秒之内，对数据库进行了至少 1 次修改；</li><li>300 秒之内，对数据库进行了至少 10 次修改；</li><li>60 秒之内，对数据库进行了至少 10000 次修改</li></ul></li></ul></li><li><p>Redis 快照是<strong>全量快照</strong>，每次执行快照，是把内存中的「所有数据」都记录到磁盘中</p><p>RDB 快照的缺点，在服务器发生故障时，丢失的数据会比 AOF 持久化的方式更多</p></li><li><p>执行快照，数据能被修改吗</p><ul><li>执行 bgsave 过程，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改</li><li>主线程（父进程）要<strong>修改共享数据里的某一块数据</strong>（比如键值对 <code>A</code>）时，就会发生写时复制，于是这块数据的<strong>物理内存就会被复制一份（键值对 <code>A'</code>）</strong>，然后<strong>主线程在这个数据副本（键值对 <code>A'</code>）进行修改操作</strong>。与此同时，<strong>bgsave 子进程可以继续把原来的数据（键值对 <code>A</code>）写入到 RDB 文件</strong></li><li>bgsave 快照过程中，主线程修改了共享数据，<strong>发生了写时复制后，RDB 快照保存的是原本的内存数据</strong>，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照</li></ul></li></ul></li><li><h4 id=rdb和aof合体>RDB和AOF合体<a hidden class=anchor aria-hidden=true href=#rdb和aof合体>#</a></h4><ul><li><p>RDB 恢复速度快的优点和有 AOF 丢失数据少的优点</p></li><li><p>开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>aof-use-rdb-preamble yes
</span></span></code></pre></div></li><li><p>AOF 重写日志时，<code>fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件</p><p>使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong></p></li></ul></li><li><h4 id=redis大key>Redis大key<a hidden class=anchor aria-hidden=true href=#redis大key>#</a></h4><ul><li>对AOF持久化影响<ul><li><strong>当使用 Always 策略的时候，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的</strong></li></ul></li><li>对AOF重写和RDB影响<ul><li>都会分别通过 <code>fork()</code> 函数创建子进程来处理任务。会有两个阶段会导致阻塞父进程（主线程）<ul><li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li><li>创建完子进程后，如果父进程修改了共享数据中的大 Key，就会发生写时复制，这期间会拷贝物理内存，由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程</li></ul></li></ul></li><li>其他影响<ul><li>客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，很久很久都没有响应。</li><li>引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li>阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li>内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多</li></ul></li><li>避免：<ul><li>设计阶段，就把大 key 拆分成一个一个小 key</li></ul></li></ul></li></ul><h3 id=删除和淘汰策略>删除和淘汰策略<a hidden class=anchor aria-hidden=true href=#删除和淘汰策略>#</a></h3><ul><li><h4 id=过期删除策略>过期删除策略<a hidden class=anchor aria-hidden=true href=#过期删除策略>#</a></h4><ul><li><p>Redis 是可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除</p></li><li><p>设置过期时间</p><ul><li><p><code>expire &lt;key> &lt;n></code>：设置 key 在 n 秒后过期</p><p>设置 key 在 100 秒后过期；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>expire key <span style=color:#ae81ff>100</span> 
</span></span></code></pre></div></li><li><p><code>pexpire &lt;key> &lt;n></code>：设置 key 在 n 毫秒后过期</p><p>设置 key2 在 100000 毫秒（100 秒）后过期。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pexpire key2 <span style=color:#ae81ff>100000</span>
</span></span></code></pre></div></li><li><p><code>expireat &lt;key> &lt;n></code>：设置 key 在某个时间戳（精确到秒）之后过期</p><p>key3 在时间戳 1655654400 后过期（精确到秒）；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>expireat key3 <span style=color:#ae81ff>1655654400</span> 
</span></span></code></pre></div></li><li><p><code>pexpireat &lt;key> &lt;n></code>：设置 key 在某个时间戳（精确到毫秒）之后过期</p><p>key4 在时间戳 1655654400000 后过期（精确到毫秒）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pexpireat key4 <span style=color:#ae81ff>1655654400000</span>
</span></span></code></pre></div><p>在设置字符串时，同时对 key 设置过期时间</p><ul><li><code>set &lt;key> &lt;value> ex &lt;n></code> ：设置键值对的时候，同时指定过期时间（精确到秒）；</li><li><code>set &lt;key> &lt;value> px &lt;n></code> ：设置键值对的时候，同时指定过期时间（精确到毫秒）；</li><li><code>setex &lt;key> &lt;n> &lt;valule></code> ：设置键值对的时候，同时指定过期时间（精确到秒）</li></ul></li><li><p>查看某个 key 剩余的存活时间，可以使用 <code>TTL &lt;key></code> 命令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 设置键值对的时候，同时指定过期时间位 60 秒</span>
</span></span><span style=display:flex><span>&gt; setex key1 <span style=color:#ae81ff>60</span> value1
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看 key1 过期时间还剩多少</span>
</span></span><span style=display:flex><span>&gt; ttl key1
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>56</span>
</span></span><span style=display:flex><span>&gt; ttl key1
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>52</span>
</span></span></code></pre></div></li><li><p>取消 key 的过期时间，使用 <code>PERSIST &lt;key></code> 命令。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 取消 key1 的过期时间</span>
</span></span><span style=display:flex><span>&gt; persist key1
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用完 persist 命令之后，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查下 key1 的存活时间结果是 -1，表明 key1 永不过期 </span>
</span></span><span style=display:flex><span>&gt; ttl key1 
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> -1
</span></span></code></pre></div></li></ul></li><li><p>常见三种过期删除策略，并不是redis会用</p><ul><li>定时删除：<ul><li><strong>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作</strong></li><li>优点：<ul><li>保证过期 key 会被尽快删除，内存可以被尽快地释放</li></ul></li><li>缺点：<ul><li>过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间</li></ul></li></ul></li><li>惰性删除：<ul><li><strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key</strong></li><li>优点：<ul><li>每次访问时，才会检查 key 是否过期，只会使用很少的系统资源</li></ul></li><li>缺点：<ul><li>如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费</li></ul></li></ul></li><li>定期删除：<ul><li><strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key</strong></li><li>优点：<ul><li>通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用</li></ul></li><li>缺点：<ul><li>内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少</li></ul></li></ul></li></ul></li><li><p>Redis过期删除</p><ul><li><p><strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡</p></li><li><p>Redis 实现惰性删除</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>expireIfNeeded</span>(redisDb <span style=color:#f92672>*</span>db, robj <span style=color:#f92672>*</span>key) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 判断 key 是否过期
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>keyIsExpired</span>(db,key)) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    ....
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 删除过期键 */</span>
</span></span><span style=display:flex><span>    ....
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> server.lazyfree_lazy_expire <span style=color:#f92672>?</span> <span style=color:#a6e22e>dbAsyncDelete</span>(db,key) <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dbSyncDelete</span>(db,key);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>Redis 在访问或者修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期：</p><ul><li>如果过期，则删除该 key，至于选择异步删除，还是选择同步删除，根据 <code>lazyfree_lazy_expire</code> 参数配置决定（Redis 4.0版本开始提供参数），然后返回 null 客户端；</li><li>如果没有过期，不做任何处理，然后返回正常的键值对给客户端</li></ul></li></ul></li><li><p>Redis实现定期删除</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//已过期的数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    expired <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#960050;background-color:#1e0010>；</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//随机抽取的数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    num <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (num<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//1. 从过期字典中随机抽取 1 个 key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//2. 判断该 key 是否过期，如果已过期则进行删除，同时对 expired++
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 超过时间限制则退出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (timelimit_exit) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* 如果本轮检查的已过期 key 的数量，超过 25%，则继续随机抽查，否则退出本轮检查 */</span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>while</span> (expired <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>20</span><span style=color:#f92672>/</span><span style=color:#ae81ff>4</span>); 
</span></span></code></pre></div></li><li><p><strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key</strong></p><ul><li>在 Redis 中，默认每秒进行 10 次过期检查一次数据库<ul><li>可通过 Redis 的配置文件 redis.conf 进行配置</li></ul></li><li>数据库每轮抽查时，会随机选择 20 个 key 判断是否过期</li></ul></li></ul></li></ul></li></ul></li><li><h4 id=内存淘汰策略>内存淘汰策略<a hidden class=anchor aria-hidden=true href=#内存淘汰策略>#</a></h4><p>配置文件 redis.conf 中，可以通过参数 <code>maxmemory &lt;bytes></code> 来设定最大运行内存，只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略</p><ul><li><p><em>不进行数据淘汰的策略</em></p><ul><li><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入</li></ul></li><li><p><em>进行数据淘汰的策略</em></p><ul><li>在设置了过期时间的数据中进行淘汰：<ul><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li><li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li><li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li></ul></li><li>在所有数据范围内进行淘汰：<ul><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li><li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值</li></ul></li></ul></li><li><p>查看redis使用的内存淘汰策略</p><ul><li><p>使用 <code>config get maxmemory-policy</code> ，查看当前 Redis 的内存淘汰策略 ：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>127.0.0.1:6379&gt; config get maxmemory-policy
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;maxmemory-policy&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;noeviction&#34;</span>
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=lru算法和lfu算法>LRU算法和LFU算法<a hidden class=anchor aria-hidden=true href=#lru算法和lfu算法>#</a></h4><ul><li><strong>LRU</strong><ul><li>Least Recently Used 翻译为<strong>最近最少使用</strong>，会选择淘汰最近最少使用的数据</li><li>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素</li></ul></li><li><strong>LFU</strong></li><li>Least Frequently Used 翻译为<strong>最近最不常用</strong>，LFU 算法是根据数据访问次数来淘汰数据的，核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”</li></ul></li></ul><h3 id=缓存异常>缓存异常<a hidden class=anchor aria-hidden=true href=#缓存异常>#</a></h3><p><strong>Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能</strong></p><p><strong>在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的缓存预热，后台更新缓存的机制刚好也适合干这个事情</strong></p><ul><li><h4 id=缓存雪崩>缓存雪崩<a hidden class=anchor aria-hidden=true href=#缓存雪崩>#</a></h4><ul><li>为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存</li><li><strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，就是<strong>缓存雪崩</strong></li><li>原因及解决方案：<ul><li><strong>大量数据同时过期</strong><ul><li>均匀设置过期时间<ul><li>给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间,对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong></li></ul></li><li>互斥锁:<ul><li>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong></li><li>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象</li></ul></li><li>后台更新缓存:<ul><li><strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>
缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被“淘汰”</strong></li></ul></li></ul></li><li><strong>Redis故障宕机：</strong><ul><li>服务熔断或请求限流机制<ul><li>启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong></li><li>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制</li></ul></li><li>构建 Redis 缓存高可靠集群<ul><li><strong>主从节点的方式构建 Redis 缓存高可靠集群</strong></li></ul></li></ul></li></ul></li></ul></li><li><h4 id=缓存击穿>缓存击穿<a hidden class=anchor aria-hidden=true href=#缓存击穿>#</a></h4><ul><li>业务通常会有几个数据被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据</li><li>缓存中的<strong>某个热点数据过期</strong>，大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，<strong>缓存击穿</strong></li><li>解决方案:<ul><li>互斥锁方案：<ul><li>保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值</li></ul></li><li>不给热点数据设置过期时间：<ul><li>后台异步更新缓存</li><li>在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间</li></ul></li></ul></li></ul></li><li><h4 id=缓存穿透>缓存穿透<a hidden class=anchor aria-hidden=true href=#缓存穿透>#</a></h4><ul><li><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，就是<strong>缓存穿透</strong>的问题</p></li><li><p>发送原因</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务</li></ul></li><li><p>解决方案：</p><ul><li>非法请求的限制<ul><li>API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误</li></ul></li><li>缓存空值或者默认值<ul><li>可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用</li></ul></li><li>使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在：</li></ul></li><li><p><strong>布隆过滤器工作过程：</strong></p><ul><li><p>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p><p>布隆过滤器通过 3 个操作完成标记：</p><ol><li><p>使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</p></li><li><p>将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</p></li><li><p>将每个哈希值在位图数组的对应位置的值设置为 1；</p></li></ol></li></ul></li></ul></li></ul><h3 id=数据库缓存一致性>数据库缓存一致性<a hidden class=anchor aria-hidden=true href=#数据库缓存一致性>#</a></h3><ul><li></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/redis/>Redis</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/docker00/><span class=title>« Prev Page</span><br><span>Docker介绍</span>
</a><a class=next href=https://zwlzls.github.io/posts/redis00/><span class=title>Next Page »</span><br><span>Redis(类型)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>