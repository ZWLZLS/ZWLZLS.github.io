<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis00 | 我的博客</title>
<meta name=keywords content="Redis"><meta name=description content='数据类型及应用 https://onecompiler.com/redis可以进行实践
String String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值
数据结构实现主要是int和SDS
SDS 不仅可以保存文本数据，还可以保存二进制数据 因为 SDS 使用 len 属性的值判断字符串是否结束 SDS 获取字符串长度的时间复杂度是 O(1) SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1) Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容 常用指令
# 设置 key-value 类型的值 > SET name lin OK # 根据 key 获得对应的 value > GET name "lin" # 判断某个 key 是否存在 > EXISTS name (integer) 1 # 返回 key 所储存的字符串值的长度 > STRLEN name (integer) 3 # 删除某个 key 对应的值 > DEL name (integer) 1 批量设置 :'><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/redis00/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/redis00/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Redis00"><meta property="og:description" content='数据类型及应用 https://onecompiler.com/redis可以进行实践
String String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值
数据结构实现主要是int和SDS
SDS 不仅可以保存文本数据，还可以保存二进制数据 因为 SDS 使用 len 属性的值判断字符串是否结束 SDS 获取字符串长度的时间复杂度是 O(1) SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1) Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容 常用指令
# 设置 key-value 类型的值 > SET name lin OK # 根据 key 获得对应的 value > GET name "lin" # 判断某个 key 是否存在 > EXISTS name (integer) 1 # 返回 key 所储存的字符串值的长度 > STRLEN name (integer) 3 # 删除某个 key 对应的值 > DEL name (integer) 1 批量设置 :'><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/redis00/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-10T15:11:14+08:00"><meta property="article:modified_time" content="2025-02-10T15:11:14+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis00"><meta name=twitter:description content='数据类型及应用 https://onecompiler.com/redis可以进行实践
String String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值
数据结构实现主要是int和SDS
SDS 不仅可以保存文本数据，还可以保存二进制数据 因为 SDS 使用 len 属性的值判断字符串是否结束 SDS 获取字符串长度的时间复杂度是 O(1) SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1) Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容 常用指令
# 设置 key-value 类型的值 > SET name lin OK # 根据 key 获得对应的 value > GET name "lin" # 判断某个 key 是否存在 > EXISTS name (integer) 1 # 返回 key 所储存的字符串值的长度 > STRLEN name (integer) 3 # 删除某个 key 对应的值 > DEL name (integer) 1 批量设置 :'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Redis00","item":"https://zwlzls.github.io/posts/redis00/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis00","name":"Redis00","description":"数据类型及应用 https://onecompiler.com/redis可以进行实践\nString String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值\n数据结构实现主要是int和SDS\nSDS 不仅可以保存文本数据，还可以保存二进制数据 因为 SDS 使用 len 属性的值判断字符串是否结束 SDS 获取字符串长度的时间复杂度是 O(1) SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1) Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容 常用指令\n# 设置 key-value 类型的值 \u0026gt; SET name lin OK # 根据 key 获得对应的 value \u0026gt; GET name \u0026#34;lin\u0026#34; # 判断某个 key 是否存在 \u0026gt; EXISTS name (integer) 1 # 返回 key 所储存的字符串值的长度 \u0026gt; STRLEN name (integer) 3 # 删除某个 key 对应的值 \u0026gt; DEL name (integer) 1 批量设置 :","keywords":["Redis"],"articleBody":"数据类型及应用 https://onecompiler.com/redis可以进行实践\nString String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值\n数据结构实现主要是int和SDS\nSDS 不仅可以保存文本数据，还可以保存二进制数据 因为 SDS 使用 len 属性的值判断字符串是否结束 SDS 获取字符串长度的时间复杂度是 O(1) SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1) Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容 常用指令\n# 设置 key-value 类型的值 \u003e SET name lin OK # 根据 key 获得对应的 value \u003e GET name \"lin\" # 判断某个 key 是否存在 \u003e EXISTS name (integer) 1 # 返回 key 所储存的字符串值的长度 \u003e STRLEN name (integer) 3 # 删除某个 key 对应的值 \u003e DEL name (integer) 1 批量设置 :\n# 批量设置 key-value 类型的值 \u003e MSET key1 value1 key2 value2 OK # 批量获取多个 key 对应的 value \u003e MGET key1 key2 1) \"value1\" 2) \"value2\" 计数器（字符串的内容为整数的时候可以使用）：\n# 设置 key-value 类型的值 \u003e SET number 0 OK # 将 key 中储存的数字值增一 \u003e INCR number (integer) 1 # 将key中存储的数字值加 10 \u003e INCRBY number 10 (integer) 11 # 将 key 中储存的数字值减一 \u003e DECR number (integer) 10 # 将key中存储的数字值键 10 \u003e DECRBY number 10 (integer) 0 过期（默认为永不过期）：\n# 设置 key 在 60 秒后过期（该方法是针对已经存在的key设置过期时间） \u003e EXPIRE name 60 (integer) 1 # 查看数据还有多久过期 \u003e TTL name (integer) 51 #设置 key-value 类型的值，并设置该key的过期时间为 60 秒 \u003e SET key value EX 60 OK \u003e SETEX key 60 value OK 不存在就插入：\n# 不存在就插入（not exists） \u003eSETNX key value (integer) 1 应用场景\n缓存对象\n直接缓存整个对象的 JSON\nSET user:1 '{\"name\":\"xiaolin\", \"age\":18}'。\n采用 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值\nMSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20\n常规计数\nRedis 处理命令是单线程，执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等\n计算文章的阅读量： # 初始化文章的阅读量 \u003e SET aritcle:readcount:1001 0 OK #阅读量+1 \u003e INCR aritcle:readcount:1001 (integer) 1 #阅读量+1 \u003e INCR aritcle:readcount:1001 (integer) 2 #阅读量+1 \u003e INCR aritcle:readcount:1001 (integer) 3 # 获取对应文章的阅读量 \u003e GET aritcle:readcount:1001 \"3\" 分布式锁\nSET 命令有个 NX 参数可以实现「key不存在才插入」，可以用来实现分布式锁：\n如果 key 不存在，则显示插入成功，可以用来表示加锁成功 如果 key 存在，则会显示插入失败，可以用来表示加锁失败 SET lock_key unique_value NX PX 10000 lock_key 就是 key 键 unique_value 是客户端生成的唯一的标识 NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作 PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁 共享Session信息\n使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息 List List 简单的字符串列表，按照插入顺序排序，可从头部或尾部向 List 列表添加元素\nList 类型的底层数据结构是由双向链表或压缩列表实现的\n元素个数少使用压缩列表，元素个数多使用双向链表 常用命令\n# 将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面 LPUSH key value [value ...] # 将一个或多个值value插入到key列表的表尾(最右边) RPUSH key value [value ...] # 移除并返回key列表的头元素 LPOP key # 移除并返回key列表的尾元素 RPOP key # 返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始 LRANGE key start stop # 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞 BLPOP key [key ...] timeout # 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞 BRPOP key [key ...] timeout 应用场景\n消息队列\n存取消息时：消息保序、处理重复的消息和保证消息可靠性\n如何满足消息保序需求？\nList 本身就是按先进先出的顺序对数据进行存取的，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了\n生产者使用 LPUSH key value[value...] 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。 消费者使用 RPOP key 依次读取队列的消息，先进先出 Redis提供了 BRPOP 命令。BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据 如何处理重复的消息？\n每个消息都有一个全局的 ID 消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理 如何保证消息可靠性？\n从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了 为留存消息，List 类型提供 BRPOPLPUSH ，作用是让消费者程序从一个 List 中读取消息，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存 Hash Hash 是一个键值对（key - value）集合，其中 value 的形式如： value=[{field1，value1}，...{fieldN，valueN}]。Hash 特别适合用于存储对象\n实现：\n元素个数少使用压缩列表，元素个数多使用哈希表 常用命令\n# 存储一个哈希表key的键值 HSET key field value # 获取哈希表key对应的field键值 HGET key field # 在一个哈希表key中存储多个键值对 HMSET key field value [field value...] # 批量获取哈希表key中多个field键值 HMGET key field [field ...] # 删除哈希表key中的field键值 HDEL key field [field ...] # 返回哈希表key中field的数量 HLEN key # 返回哈希表key中所有的键值 HGETALL key # 为哈希表key中field键的值加上增量n HINCRBY key field n 应用场景\n缓存对象\nHash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象\n# 存储一个哈希表uid:1的键值 \u003e HMSET uid:1 name Tom age 15 2 # 存储一个哈希表uid:2的键值 \u003e HMSET uid:2 name Jerry age 13 2 # 获取哈希表用户id为1中所有的键值 \u003e HGETALL uid:1 1) \"name\" 2) \"Tom\" 3) \"age\" 4) \"15\" 购物车\n用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3要素\n添加商品：HSET cart:{用户id} {商品id} 1 添加数量：HINCRBY cart:{用户id} {商品id} 1 商品总数：HLEN cart:{用户id} 删除商品：HDEL cart:{用户id} {商品id} 获取购物车所有商品：HGETALL cart:{用户id} Set 一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储\n特性：无序、不可重复\n内部实现\n元素个数少使用整数集合，元素个数多使用哈希表 常用命令\n# 往集合key中存入元素，元素存在则忽略，若key不存在则新建 SADD key member [member ...] # 从集合key中删除元素 SREM key member [member ...] # 获取集合key中所有元素 SMEMBERS key # 获取集合key中的元素个数 SCARD key # 判断member元素是否存在于集合key中 SISMEMBER key member # 从集合key中随机选出count个元素，元素不从key中删除 SRANDMEMBER key [count] # 从集合key中随机选出count个元素，元素从key中删除 SPOP key [count] Set运算操作\n# 交集运算 SINTER key [key ...] # 将交集结果存入新集合destination中 SINTERSTORE destination key [key ...] # 并集运算 SUNION key [key ...] # 将并集结果存入新集合destination中 SUNIONSTORE destination key [key ...] # 差集运算 SDIFF key [key ...] # 将差集结果存入新集合destination中 SDIFFSTORE destination key [key ...] 应用场景\n点赞\nSet 类型可以保证一个用户只能点一个赞。场景：key 是文章id，value 是用户id\nuid:1 、uid:2、uid:3 三个用户分别对 article:1 文章点赞了。\n# uid:1 用户对文章 article:1 点赞 \u003e SADD article:1 uid:1 (integer) 1 # uid:2 用户对文章 article:1 点赞 \u003e SADD article:1 uid:2 (integer) 1 # uid:3 用户对文章 article:1 点赞 \u003e SADD article:1 uid:3 (integer) 1 uid:1 取消了对 article:1 文章点赞。\n\u003e SREM article:1 uid:1 (integer) 1 获取 article:1 文章所有点赞用户 :\n\u003e SMEMBERS article:1 1) \"uid:3\" 2) \"uid:2\" 获取 article:1 文章的点赞用户数量：\n\u003e SCARD article:1 (integer) 2 判断用户 uid:1 是否对文章 article:1 点赞了：\n\u003e SISMEMBER article:1 uid:1 (integer) 0 # 返回0说明没点赞，返回1则说明点赞了 共同关注\nSet 类型支持交集运算，key 可以是用户id，value 则是已关注的公众号的id\nuid:1 用户关注公众号 id 为 5、6、7、8、9\nuid:2 用户关注公众号 id 为 7、8、9、10、11。\n# uid:1 用户关注公众号 id 为 5、6、7、8、9 \u003e SADD uid:1 5 6 7 8 9 (integer) 5 # uid:2 用户关注公众号 id 为 7、8、9、10、11 \u003e SADD uid:2 7 8 9 10 11 (integer) 5 uid:1 和 uid:2 共同关注的公众号： # 获取共同关注 \u003e SINTER uid:1 uid:2 1) \"7\" 2) \"8\" 3) \"9\" 给 uid:2 推荐 uid:1 关注的公众号： \u003e SDIFF uid:1 uid:2 1) \"5\" 2) \"6\" 验证某个公众号是否同时被 uid:1 或 uid:2 关注: \u003e SISMEMBER uid:1 5 (integer) 1 # 返回0，说明关注了 \u003e SISMEMBER uid:2 5 (integer) 0 # 返回0，说明没关注 抽奖文化\n存储某活动中中奖的用户名\n如果允许重复中奖，可以使用 SRANDMEMBER 命令。 # 抽取 1 个一等奖： \u003e SRANDMEMBER lucky 1 1) \"Tom\" # 抽取 2 个二等奖： \u003e SRANDMEMBER lucky 2 1) \"Mark\" 2) \"Jerry\" # 抽取 3 个三等奖： \u003e SRANDMEMBER lucky 3 1) \"Sary\" 2) \"Tom\" 3) \"Jerry\" 如果不允许重复中奖，可以使用 SPOP 命令。 # 抽取一等奖1个 \u003e SPOP lucky 1 1) \"Sary\" # 抽取二等奖2个 \u003e SPOP lucky 2 1) \"Jerry\" 2) \"Mark\" # 抽取三等奖3个 \u003e SPOP lucky 3 1) \"John\" 2) \"Sean\" 3) \"Lindy\" Zset Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值） 对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值\n内部实现\n元素个数少使用压缩列表，元素个数多使用跳表 常用命令\n# 往有序集合key中加入带分值元素 ZADD key score member [[score member]...] # 往有序集合key中删除元素 ZREM key member [member...] # 返回有序集合key中元素member的分值 ZSCORE key member # 返回有序集合key中元素个数 ZCARD key # 为有序集合key中元素member的分值加上increment ZINCRBY key increment member # 正序获取有序集合key从start下标到stop下标的元素 ZRANGE key start stop [WITHSCORES] # 倒序获取有序集合key从start下标到stop下标的元素 ZREVRANGE key start stop [WITHSCORES] # 返回有序集合中指定分数区间内的成员，分数由低到高排序。 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] # 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。 ZRANGEBYLEX key min max [LIMIT offset count] # 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同 ZREVRANGEBYLEX key max min [LIMIT offset count] Zset 运算操作（相比于 Set 类型，ZSet 类型没有支持差集运算）：\n# 并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积 ZUNIONSTORE destkey numberkeys key [key...] # 交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积 ZINTERSTORE destkey numberkeys key [key...] 应用场景\n排行榜\n我们以博文点赞排名为例，小小发表了五篇博文，分别获得赞为 200、40、100、50、150。\n# arcticle:1 文章获得了200个赞 \u003e ZADD user:xiaoxiao:ranking 200 arcticle:1 (integer) 1 # arcticle:2 文章获得了40个赞 \u003e ZADD user:xiaoxiao:ranking 40 arcticle:2 (integer) 1 # arcticle:3 文章获得了100个赞 \u003e ZADD user:xiaoxiao:ranking 100 arcticle:3 (integer) 1 # arcticle:4 文章获得了50个赞 \u003e ZADD user:xiaoxiao:ranking 50 arcticle:4 (integer) 1 # arcticle:5 文章获得了150个赞 \u003e ZADD user:xiaoxiao:ranking 150 arcticle:5 (integer) 1 文章 arcticle:4 新增一个赞，可以使用 ZINCRBY 命令\n\u003e ZINCRBY user:xiaoxiao:ranking 1 arcticle:4 \"51\" 查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：\n\u003e ZSCORE user:xiaoxiao:ranking arcticle:4 \"50\" 获取小林文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从start下标到stop下标的元素）：\n# WITHSCORES 表示把 score 也显示出来 \u003e ZREVRANGE user:xiaoxiao:ranking 0 2 WITHSCORES 1) \"arcticle:1\" 2) \"200\" 3) \"arcticle:5\" 4) \"150\" 5) \"arcticle:3\" 6) \"100\" 获取小林 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：\n\u003e ZRANGEBYSCORE user:xiaoxiao:ranking 100 200 WITHSCORES 1) \"arcticle:3\" 2) \"100\" 3) \"arcticle:5\" 4) \"150\" 5) \"arcticle:1\" 6) \"200\" 电话,姓名排序\n使用有序集合的 ZRANGEBYLEX 或 ZREVRANGEBYLEX 可以帮助我们实现电话号码或姓名的排序\n不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令\n1、电话排序\n将电话号码存储到 SortSet 中，然后根据需要来获取号段：\n\u003e ZADD phone 0 13100111100 0 13110114300 0 13132110901 (integer) 3 \u003e ZADD phone 0 13200111100 0 13210414300 0 13252110901 (integer) 3 \u003e ZADD phone 0 13300111100 0 13310414300 0 13352110901 (integer) 3 获取所有号码:\n\u003e ZRANGEBYLEX phone - + 1) \"13100111100\" 2) \"13110114300\" 3) \"13132110901\" 4) \"13200111100\" 5) \"13210414300\" 6) \"13252110901\" 7) \"13300111100\" 8) \"13310414300\" 9) \"13352110901\" 获取 132 号段的号码：\n\u003e ZRANGEBYLEX phone [132 (133 1) \"13200111100\" 2) \"13210414300\" 3) \"13252110901\" 获取132、133号段的号码：\n\u003e ZRANGEBYLEX phone [132 (134 1) \"13200111100\" 2) \"13210414300\" 3) \"13252110901\" 4) \"13300111100\" 5) \"13310414300\" 6) \"13352110901\" 2、姓名排序\n\u003e zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua (integer) 6 获取所有人的名字:\n\u003e ZRANGEBYLEX names - + 1) \"Aidehua\" 2) \"Aimini\" 3) \"Bluetuo\" 4) \"Gaodeng\" 5) \"Jake\" 6) \"Toumas\" 获取名字中大写字母A开头的所有人：\n\u003e ZRANGEBYLEX names [A (B 1) \"Aidehua\" 2) \"Aimini\" 获取名字中大写字母 C 到 Z 的所有人：\n\u003e ZRANGEBYLEX names [C [Z 1) \"Gaodeng\" 2) \"Jake\" 3) \"Toumas\" BitMap Bitmap，位图，是一串连续的二进制数组（0和1），可通过偏移量（offset）定位元素\n特别适合一些数据量大且使用二值统计的场景\n内部实现\nBitmap 本身是String 类型作为底层数据结构实现的一种统计二值状态的数据类型 常用命令\n# 设置值，其中value只能是 0 和 1 SETBIT key offset value # 获取值 GETBIT key offset # 获取指定范围内值为 1 的个数 # start 和 end 以字节为单位 BITCOUNT key start end bitmap 运算操作： # BitMap间的运算 # operations 位移操作符，枚举值 AND 与运算 \u0026 OR 或运算 | XOR 异或 ^ NOT 取反 ~ # result 计算的结果，会存储在该key中 # key1 … keyn 参与运算的key，可以有多个，空格分割，not运算只能一个key # 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0。返回值是保存到 destkey 的字符串的长度（以字节byte为单位），和输入 key 中最长的字符串长度相等。 BITOP [operations] [result] [key1] [keyn…] # 返回指定key中第一次出现指定value(0/1)的位置 BITPOS [key] [value] 应用场景\n签到统计\n用记录签到（1）或未签到（0）就是非常典型的二值状态\n统计 ID 100 的用户在 2022 年 6 月份的签到情况，可以按照下面步骤进行操作。\n执行下面的命令，记录该用户 6 月 3 号已签到。 SETBIT uid:sign:100:202206 2 1 检查该用户 6 月 3 日是否签到。 GETBIT uid:sign:100:202206 2 统计该用户在 6 月份的签到次数。 BITCOUNT uid:sign:100:202206 数据结构 在 Redis 3.0 版本中 List 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，List 数据类型底层数据结构是由 quicklist 实现的； 核心：双向链表变为quicklist，压缩列表变为listpack SDS C语言字符串缺陷：\n获取字符串长度的时间复杂度为 O（N）； 字符串结尾以 “\\0” 字符标识，字符串里面不能包含 “\\0” 字符，不能保存二进制数据； 字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止 SDS结构设计\nlen，记录了字符串长度。时间复杂度只需要 O（1）\nalloc，分配给字符数组的空间长度。这样在修改字符串的时候，可以通过 alloc - len 计算出剩余的空间大小，可以用来判断空间是否满足修改需求\nflags，用来表示不同类型的 SDS。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。\nbuf[]，字节数组，用来保存实际数据。不仅可以保存字符串，也可以保存二进制数据\nSDS 扩容的规则代码如下：\nhisds hi_sdsMakeRoomFor(hisds s, size_t addlen) { ... ... // s目前的剩余空间已足够，无需扩展，直接返回 if (avail \u003e= addlen) return s; //获取目前s的长度 len = hi_sdslen(s); sh = (char *)s - hi_sdsHdrSize(oldtype); //扩展之后 s 至少需要的长度 newlen = (len + addlen); //根据新长度，为s分配新空间所需要的大小 if (newlen \u003c HI_SDS_MAX_PREALLOC) //新长度","wordCount":"1825","inLanguage":"en","datePublished":"2025-02-10T15:11:14+08:00","dateModified":"2025-02-10T15:11:14+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/redis00/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Redis00</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%8f%8a%e5%ba%94%e7%94%a8 aria-label=数据类型及应用>数据类型及应用</a><ul><li><a href=#string aria-label=String>String</a></li><li><a href=#list aria-label=List>List</a></li><li><a href=#hash aria-label=Hash>Hash</a></li><li><a href=#set aria-label=Set>Set</a></li><li><a href=#zset aria-label=Zset>Zset</a></li><li><a href=#bitmap aria-label=BitMap>BitMap</a></li></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=数据结构>数据结构</a><ul><li><a href=#sds aria-label=SDS>SDS</a></li><li><a href=#%e9%93%be%e8%a1%a8 aria-label=链表>链表</a></li><li><a href=#%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8 aria-label=压缩列表>压缩列表</a></li><li><a href=#%e5%93%88%e5%b8%8c%e8%a1%a8 aria-label=哈希表>哈希表</a></li><li><a href=#%e6%95%b4%e6%95%b0%e9%9b%86%e5%90%88 aria-label=整数集合>整数集合</a></li><li><a href=#%e8%b7%b3%e8%a1%a8 aria-label=跳表>跳表</a></li></ul></li></ul></div></details></div><div class=post-content><h3 id=数据类型及应用>数据类型及应用<a hidden class=anchor aria-hidden=true href=#数据类型及应用>#</a></h3><p><a href=https://onecompiler.com/redis>https://onecompiler.com/redis</a>可以进行实践</p><ul><li><h4 id=string>String<a hidden class=anchor aria-hidden=true href=#string>#</a></h4><ul><li><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值</p></li><li><p>数据结构实现主要是<code>int</code>和<code>SDS</code></p><ul><li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong><ul><li>因为 <code>SDS</code> 使用 <code>len</code> 属性的值判断字符串是否结束</li></ul></li><li><strong>SDS 获取字符串长度的时间复杂度是 O(1)</strong><ul><li>SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code></li></ul></li><li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong><ul><li>SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容</li></ul></li></ul></li><li><p>常用指令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 设置 key-value 类型的值</span>
</span></span><span style=display:flex><span>&gt; SET name lin
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span><span style=color:#75715e># 根据 key 获得对应的 value</span>
</span></span><span style=display:flex><span>&gt; GET name
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;lin&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 判断某个 key 是否存在</span>
</span></span><span style=display:flex><span>&gt; EXISTS name
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 返回 key 所储存的字符串值的长度</span>
</span></span><span style=display:flex><span>&gt; STRLEN name
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 删除某个 key 对应的值</span>
</span></span><span style=display:flex><span>&gt; DEL name
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>批量设置 :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 批量设置 key-value 类型的值</span>
</span></span><span style=display:flex><span>&gt; MSET key1 value1 key2 value2 
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span><span style=color:#75715e># 批量获取多个 key 对应的 value</span>
</span></span><span style=display:flex><span>&gt; MGET key1 key2 
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;value1&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;value2&#34;</span>
</span></span></code></pre></div><p>计数器（字符串的内容为整数的时候可以使用）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 设置 key-value 类型的值</span>
</span></span><span style=display:flex><span>&gt; SET number <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span><span style=color:#75715e># 将 key 中储存的数字值增一</span>
</span></span><span style=display:flex><span>&gt; INCR number
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将key中存储的数字值加 10</span>
</span></span><span style=display:flex><span>&gt; INCRBY number <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将 key 中储存的数字值减一</span>
</span></span><span style=display:flex><span>&gt; DECR number
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将key中存储的数字值键 10</span>
</span></span><span style=display:flex><span>&gt; DECRBY number <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>过期（默认为永不过期）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 设置 key 在 60 秒后过期（该方法是针对已经存在的key设置过期时间）</span>
</span></span><span style=display:flex><span>&gt; EXPIRE name  <span style=color:#ae81ff>60</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看数据还有多久过期</span>
</span></span><span style=display:flex><span>&gt; TTL name 
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>51</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#设置 key-value 类型的值，并设置该key的过期时间为 60 秒</span>
</span></span><span style=display:flex><span>&gt; SET key  value EX <span style=color:#ae81ff>60</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>&gt; SETEX key  <span style=color:#ae81ff>60</span> value
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><p>不存在就插入：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 不存在就插入（not exists）</span>
</span></span><span style=display:flex><span>&gt;SETNX key value
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div></li><li><p>应用场景</p><ul><li><p>缓存对象</p><ul><li><p>直接缓存整个对象的 JSON</p><p><code>SET user:1 '{"name":"xiaolin", "age":18}'</code>。</p></li><li><p>采用 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值</p><p><code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20</code></p></li></ul></li><li><p>常规计数</p><p>Redis 处理命令是单线程，执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等</p><ul><li>计算文章的阅读量：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 初始化文章的阅读量</span>
</span></span><span style=display:flex><span>&gt; SET aritcle:readcount:1001 <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span><span style=color:#75715e>#阅读量+1</span>
</span></span><span style=display:flex><span>&gt; INCR aritcle:readcount:1001
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#阅读量+1</span>
</span></span><span style=display:flex><span>&gt; INCR aritcle:readcount:1001
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#阅读量+1</span>
</span></span><span style=display:flex><span>&gt; INCR aritcle:readcount:1001
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取对应文章的阅读量</span>
</span></span><span style=display:flex><span>&gt; GET aritcle:readcount:1001
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;3&#34;</span>
</span></span></code></pre></div></li><li><p>分布式锁</p><p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用来实现分布式锁：</p><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>SET lock_key unique_value NX PX <span style=color:#ae81ff>10000</span>
</span></span></code></pre></div><ul><li>lock_key 就是 key 键</li><li>unique_value 是客户端生成的唯一的标识</li><li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作</li><li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁</li></ul></li><li><p>共享Session信息</p><ul><li>使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息</li></ul></li></ul></li></ul></li><li><h4 id=list>List<a hidden class=anchor aria-hidden=true href=#list>#</a></h4><ul><li><p>List 简单的字符串列表，<strong>按照插入顺序排序</strong>，可从头部或尾部向 List 列表添加元素</p></li><li><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的</p><ul><li>元素个数少使用压缩列表，元素个数多使用双向链表</li></ul></li><li><p>常用命令</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span>
</span></span><span style=display:flex><span>LPUSH key value <span style=color:#f92672>[</span>value ...<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span><span style=color:#75715e># 将一个或多个值value插入到key列表的表尾(最右边)</span>
</span></span><span style=display:flex><span>RPUSH key value <span style=color:#f92672>[</span>value ...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 移除并返回key列表的头元素</span>
</span></span><span style=display:flex><span>LPOP key     
</span></span><span style=display:flex><span><span style=color:#75715e># 移除并返回key列表的尾元素</span>
</span></span><span style=display:flex><span>RPOP key 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span>
</span></span><span style=display:flex><span>LRANGE key start stop
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span>
</span></span><span style=display:flex><span>BLPOP key <span style=color:#f92672>[</span>key ...<span style=color:#f92672>]</span> timeout
</span></span><span style=display:flex><span><span style=color:#75715e># 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span>
</span></span><span style=display:flex><span>BRPOP key <span style=color:#f92672>[</span>key ...<span style=color:#f92672>]</span> timeout
</span></span></code></pre></div></li></ul></li><li><p>应用场景</p><ul><li><p>消息队列</p><p>存取消息时：<strong>消息保序、处理重复的消息和保证消息可靠性</strong></p><ol><li><p><em>如何满足消息保序需求？</em></p><p>List 本身就是按先进先出的顺序对数据进行存取的，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了</p><ul><li>生产者使用 <code>LPUSH key value[value...]</code> 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</li><li>消费者使用 <code>RPOP key</code> 依次读取队列的消息，先进先出
Redis提供了 BRPOP 命令。<strong>BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong></li></ul></li><li><p><em>如何处理重复的消息？</em></p><ul><li>每个消息都有一个全局的 ID</li><li>消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理</li></ul></li><li><p><em>如何保证消息可靠性？</em></p><ul><li>从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了</li><li>为留存消息，List 类型提供 <code>BRPOPLPUSH</code> ，<strong>作用是让消费者程序从一个 List 中读取消息，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong></li></ul></li></ol></li></ul></li></ul></li><li><h4 id=hash>Hash<a hidden class=anchor aria-hidden=true href=#hash>#</a></h4><ul><li><p>Hash 是一个键值对（key - value）集合，其中 value 的形式如： <code>value=[{field1，value1}，...{fieldN，valueN}]</code>。Hash 特别适合用于存储对象</p></li><li><p>实现：</p><ul><li>元素个数少使用压缩列表，元素个数多使用<strong>哈希表</strong></li></ul></li><li><p>常用命令</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 存储一个哈希表key的键值</span>
</span></span><span style=display:flex><span>HSET key field value   
</span></span><span style=display:flex><span><span style=color:#75715e># 获取哈希表key对应的field键值</span>
</span></span><span style=display:flex><span>HGET key field
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 在一个哈希表key中存储多个键值对</span>
</span></span><span style=display:flex><span>HMSET key field value <span style=color:#f92672>[</span>field value...<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span><span style=color:#75715e># 批量获取哈希表key中多个field键值</span>
</span></span><span style=display:flex><span>HMGET key field <span style=color:#f92672>[</span>field ...<span style=color:#f92672>]</span>       
</span></span><span style=display:flex><span><span style=color:#75715e># 删除哈希表key中的field键值</span>
</span></span><span style=display:flex><span>HDEL key field <span style=color:#f92672>[</span>field ...<span style=color:#f92672>]</span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 返回哈希表key中field的数量</span>
</span></span><span style=display:flex><span>HLEN key       
</span></span><span style=display:flex><span><span style=color:#75715e># 返回哈希表key中所有的键值</span>
</span></span><span style=display:flex><span>HGETALL key 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 为哈希表key中field键的值加上增量n</span>
</span></span><span style=display:flex><span>HINCRBY key field n          
</span></span></code></pre></div></li></ul></li><li><p>应用场景</p><ul><li><p>缓存对象</p><p>Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 存储一个哈希表uid:1的键值</span>
</span></span><span style=display:flex><span>&gt; HMSET uid:1 name Tom age <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 存储一个哈希表uid:2的键值</span>
</span></span><span style=display:flex><span>&gt; HMSET uid:2 name Jerry age <span style=color:#ae81ff>13</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取哈希表用户id为1中所有的键值</span>
</span></span><span style=display:flex><span>&gt; HGETALL uid:1
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;name&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Tom&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;age&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;15&#34;</span>
</span></span></code></pre></div></li><li><p>购物车</p><p>用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3要素</p><ul><li>添加商品：<code>HSET cart:{用户id} {商品id} 1</code></li><li>添加数量：<code>HINCRBY cart:{用户id} {商品id} 1</code></li><li>商品总数：<code>HLEN cart:{用户id}</code></li><li>删除商品：<code>HDEL cart:{用户id} {商品id}</code></li><li>获取购物车所有商品：<code>HGETALL cart:{用户id}</code></li></ul></li></ul></li></ul></li><li><h4 id=set>Set<a hidden class=anchor aria-hidden=true href=#set>#</a></h4><ul><li><p>一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储</p></li><li><p>特性：无序、不可重复</p></li><li><p>内部实现</p><ul><li>元素个数少使用整数集合，元素个数多使用<strong>哈希表</strong></li></ul></li><li><p>常用命令</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 往集合key中存入元素，元素存在则忽略，若key不存在则新建</span>
</span></span><span style=display:flex><span>SADD key member <span style=color:#f92672>[</span>member ...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 从集合key中删除元素</span>
</span></span><span style=display:flex><span>SREM key member <span style=color:#f92672>[</span>member ...<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span><span style=color:#75715e># 获取集合key中所有元素</span>
</span></span><span style=display:flex><span>SMEMBERS key
</span></span><span style=display:flex><span><span style=color:#75715e># 获取集合key中的元素个数</span>
</span></span><span style=display:flex><span>SCARD key
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 判断member元素是否存在于集合key中</span>
</span></span><span style=display:flex><span>SISMEMBER key member
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 从集合key中随机选出count个元素，元素不从key中删除</span>
</span></span><span style=display:flex><span>SRANDMEMBER key <span style=color:#f92672>[</span>count<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 从集合key中随机选出count个元素，元素从key中删除</span>
</span></span><span style=display:flex><span>SPOP key <span style=color:#f92672>[</span>count<span style=color:#f92672>]</span>
</span></span></code></pre></div></li><li><p>Set运算操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 交集运算</span>
</span></span><span style=display:flex><span>SINTER key <span style=color:#f92672>[</span>key ...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将交集结果存入新集合destination中</span>
</span></span><span style=display:flex><span>SINTERSTORE destination key <span style=color:#f92672>[</span>key ...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 并集运算</span>
</span></span><span style=display:flex><span>SUNION key <span style=color:#f92672>[</span>key ...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将并集结果存入新集合destination中</span>
</span></span><span style=display:flex><span>SUNIONSTORE destination key <span style=color:#f92672>[</span>key ...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 差集运算</span>
</span></span><span style=display:flex><span>SDIFF key <span style=color:#f92672>[</span>key ...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将差集结果存入新集合destination中</span>
</span></span><span style=display:flex><span>SDIFFSTORE destination key <span style=color:#f92672>[</span>key ...<span style=color:#f92672>]</span>
</span></span></code></pre></div></li></ul></li><li><p>应用场景</p><ul><li><p>点赞</p><p>Set 类型可以保证一个用户只能点一个赞。场景：key 是文章id，value 是用户id</p><p><code>uid:1</code> 、<code>uid:2</code>、<code>uid:3</code> 三个用户分别对 article:1 文章点赞了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># uid:1 用户对文章 article:1 点赞</span>
</span></span><span style=display:flex><span>&gt; SADD article:1 uid:1
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># uid:2 用户对文章 article:1 点赞</span>
</span></span><span style=display:flex><span>&gt; SADD article:1 uid:2
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># uid:3 用户对文章 article:1 点赞</span>
</span></span><span style=display:flex><span>&gt; SADD article:1 uid:3
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p><code>uid:1</code> 取消了对 article:1 文章点赞。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>&gt; SREM article:1 uid:1
</span></span><span style=display:flex><span>(integer) 1
</span></span></code></pre></div><p>获取 article:1 文章所有点赞用户 :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; SMEMBERS article:1
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;uid:3&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;uid:2&#34;</span>
</span></span></code></pre></div><p>获取 article:1 文章的点赞用户数量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; SCARD article:1
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>判断用户 <code>uid:1</code> 是否对文章 article:1 点赞了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; SISMEMBER article:1 uid:1
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span>  <span style=color:#75715e># 返回0说明没点赞，返回1则说明点赞了</span>
</span></span></code></pre></div></li><li><p>共同关注</p><p>Set 类型支持交集运算，key 可以是用户id，value 则是已关注的公众号的id</p><p><code>uid:1</code> 用户关注公众号 id 为 5、6、7、8、9</p><p><code>uid:2</code> 用户关注公众号 id 为 7、8、9、10、11。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># uid:1 用户关注公众号 id 为 5、6、7、8、9</span>
</span></span><span style=display:flex><span>&gt; SADD uid:1 <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>7</span> <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span><span style=color:#75715e># uid:2  用户关注公众号 id 为 7、8、9、10、11</span>
</span></span><span style=display:flex><span>&gt; SADD uid:2 <span style=color:#ae81ff>7</span> <span style=color:#ae81ff>8</span> <span style=color:#ae81ff>9</span> <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>5</span>
</span></span></code></pre></div><ul><li><code>uid:1</code> 和 <code>uid:2</code> 共同关注的公众号：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 获取共同关注</span>
</span></span><span style=display:flex><span>&gt; SINTER uid:1 uid:2
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;7&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;8&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;9&#34;</span>
</span></span></code></pre></div><ul><li>给 <code>uid:2</code> 推荐 <code>uid:1</code> 关注的公众号：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; SDIFF uid:1 uid:2
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;5&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;6&#34;</span>
</span></span></code></pre></div><ul><li>验证某个公众号是否同时被 <code>uid:1</code> 或 <code>uid:2</code> 关注:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; SISMEMBER uid:1 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># 返回0，说明关注了</span>
</span></span><span style=display:flex><span>&gt; SISMEMBER uid:2 <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e># 返回0，说明没关注</span>
</span></span></code></pre></div></li><li><p>抽奖文化</p><ul><li><p>存储某活动中中奖的用户名</p><ul><li>如果允许重复中奖，可以使用 SRANDMEMBER 命令。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 抽取 1 个一等奖：</span>
</span></span><span style=display:flex><span>&gt; SRANDMEMBER lucky <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Tom&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 抽取 2 个二等奖：</span>
</span></span><span style=display:flex><span>&gt; SRANDMEMBER lucky <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Mark&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Jerry&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 抽取 3 个三等奖：</span>
</span></span><span style=display:flex><span>&gt; SRANDMEMBER lucky <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Sary&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Tom&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Jerry&#34;</span>
</span></span></code></pre></div><ul><li>如果不允许重复中奖，可以使用 SPOP 命令。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 抽取一等奖1个</span>
</span></span><span style=display:flex><span>&gt; SPOP lucky <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Sary&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 抽取二等奖2个</span>
</span></span><span style=display:flex><span>&gt; SPOP lucky <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Jerry&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Mark&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 抽取三等奖3个</span>
</span></span><span style=display:flex><span>&gt; SPOP lucky <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;John&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Sean&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Lindy&#34;</span>
</span></span></code></pre></div></li></ul></li></ul></li></ul></li><li><h4 id=zset>Zset<a hidden class=anchor aria-hidden=true href=#zset>#</a></h4><ul><li><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值）
对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值</p></li><li><p>内部实现</p><ul><li>元素个数少使用压缩列表，元素个数多使用<strong>跳表</strong></li></ul></li><li><p>常用命令</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 往有序集合key中加入带分值元素</span>
</span></span><span style=display:flex><span>ZADD key score member <span style=color:#f92672>[[</span>score member<span style=color:#f92672>]</span>...<span style=color:#f92672>]</span>   
</span></span><span style=display:flex><span><span style=color:#75715e># 往有序集合key中删除元素</span>
</span></span><span style=display:flex><span>ZREM key member <span style=color:#f92672>[</span>member...<span style=color:#f92672>]</span>                 
</span></span><span style=display:flex><span><span style=color:#75715e># 返回有序集合key中元素member的分值</span>
</span></span><span style=display:flex><span>ZSCORE key member
</span></span><span style=display:flex><span><span style=color:#75715e># 返回有序集合key中元素个数</span>
</span></span><span style=display:flex><span>ZCARD key 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 为有序集合key中元素member的分值加上increment</span>
</span></span><span style=display:flex><span>ZINCRBY key increment member 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 正序获取有序集合key从start下标到stop下标的元素</span>
</span></span><span style=display:flex><span>ZRANGE key start stop <span style=color:#f92672>[</span>WITHSCORES<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 倒序获取有序集合key从start下标到stop下标的元素</span>
</span></span><span style=display:flex><span>ZREVRANGE key start stop <span style=color:#f92672>[</span>WITHSCORES<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 返回有序集合中指定分数区间内的成员，分数由低到高排序。</span>
</span></span><span style=display:flex><span>ZRANGEBYSCORE key min max <span style=color:#f92672>[</span>WITHSCORES<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>LIMIT offset count<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span>
</span></span><span style=display:flex><span>ZRANGEBYLEX key min max <span style=color:#f92672>[</span>LIMIT offset count<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span>
</span></span><span style=display:flex><span>ZREVRANGEBYLEX key max min <span style=color:#f92672>[</span>LIMIT offset count<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Zset 运算操作（相比于 Set 类型，ZSet 类型没有支持差集运算）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span>
</span></span><span style=display:flex><span>ZUNIONSTORE destkey numberkeys key <span style=color:#f92672>[</span>key...<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span><span style=color:#75715e># 交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span>
</span></span><span style=display:flex><span>ZINTERSTORE destkey numberkeys key <span style=color:#f92672>[</span>key...<span style=color:#f92672>]</span>
</span></span></code></pre></div></li></ul></li><li><p>应用场景</p><ul><li><p>排行榜</p><p>我们以博文点赞排名为例，小小发表了五篇博文，分别获得赞为 200、40、100、50、150。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># arcticle:1 文章获得了200个赞</span>
</span></span><span style=display:flex><span>&gt; ZADD user:xiaoxiao:ranking <span style=color:#ae81ff>200</span> arcticle:1
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># arcticle:2 文章获得了40个赞</span>
</span></span><span style=display:flex><span>&gt; ZADD user:xiaoxiao:ranking <span style=color:#ae81ff>40</span> arcticle:2
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># arcticle:3 文章获得了100个赞</span>
</span></span><span style=display:flex><span>&gt; ZADD user:xiaoxiao:ranking <span style=color:#ae81ff>100</span> arcticle:3
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># arcticle:4 文章获得了50个赞</span>
</span></span><span style=display:flex><span>&gt; ZADD user:xiaoxiao:ranking <span style=color:#ae81ff>50</span> arcticle:4
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># arcticle:5 文章获得了150个赞</span>
</span></span><span style=display:flex><span>&gt; ZADD user:xiaoxiao:ranking <span style=color:#ae81ff>150</span> arcticle:5
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>文章 arcticle:4 新增一个赞，可以使用 ZINCRBY 命令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; ZINCRBY user:xiaoxiao:ranking <span style=color:#ae81ff>1</span> arcticle:4
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;51&#34;</span>
</span></span></code></pre></div><p>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; ZSCORE user:xiaoxiao:ranking arcticle:4
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;50&#34;</span>
</span></span></code></pre></div><p>获取小林文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从start下标到stop下标的元素）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># WITHSCORES 表示把 score 也显示出来</span>
</span></span><span style=display:flex><span>&gt; ZREVRANGE user:xiaoxiao:ranking <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>2</span> WITHSCORES
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;arcticle:1&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;200&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;arcticle:5&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;150&#34;</span>
</span></span><span style=display:flex><span>5<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;arcticle:3&#34;</span>
</span></span><span style=display:flex><span>6<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;100&#34;</span>
</span></span></code></pre></div><p>获取小林 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; ZRANGEBYSCORE user:xiaoxiao:ranking <span style=color:#ae81ff>100</span> <span style=color:#ae81ff>200</span> WITHSCORES
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;arcticle:3&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;100&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;arcticle:5&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;150&#34;</span>
</span></span><span style=display:flex><span>5<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;arcticle:1&#34;</span>
</span></span><span style=display:flex><span>6<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;200&#34;</span>
</span></span></code></pre></div></li><li><p>电话,姓名排序</p><p>使用有序集合的 <code>ZRANGEBYLEX</code> 或 <code>ZREVRANGEBYLEX</code> 可以帮助我们实现电话号码或姓名的排序</p><p><strong>不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令</strong></p><p><em>1、电话排序</em></p><p>将电话号码存储到 SortSet 中，然后根据需要来获取号段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; ZADD phone <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>13100111100</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>13110114300</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>13132110901</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>&gt; ZADD phone <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>13200111100</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>13210414300</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>13252110901</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>&gt; ZADD phone <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>13300111100</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>13310414300</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>13352110901</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p>获取所有号码:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; ZRANGEBYLEX phone - +
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13100111100&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13110114300&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13132110901&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13200111100&#34;</span>
</span></span><span style=display:flex><span>5<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13210414300&#34;</span>
</span></span><span style=display:flex><span>6<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13252110901&#34;</span>
</span></span><span style=display:flex><span>7<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13300111100&#34;</span>
</span></span><span style=display:flex><span>8<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13310414300&#34;</span>
</span></span><span style=display:flex><span>9<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13352110901&#34;</span>
</span></span></code></pre></div><p>获取 132 号段的号码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; ZRANGEBYLEX phone <span style=color:#f92672>[</span><span style=color:#ae81ff>132</span> <span style=color:#f92672>(</span><span style=color:#ae81ff>133</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13200111100&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13210414300&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13252110901&#34;</span>
</span></span></code></pre></div><p>获取132、133号段的号码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; ZRANGEBYLEX phone <span style=color:#f92672>[</span><span style=color:#ae81ff>132</span> <span style=color:#f92672>(</span><span style=color:#ae81ff>134</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13200111100&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13210414300&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13252110901&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13300111100&#34;</span>
</span></span><span style=display:flex><span>5<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13310414300&#34;</span>
</span></span><span style=display:flex><span>6<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;13352110901&#34;</span>
</span></span></code></pre></div><p><em>2、姓名排序</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; zadd names <span style=color:#ae81ff>0</span> Toumas <span style=color:#ae81ff>0</span> Jake <span style=color:#ae81ff>0</span> Bluetuo <span style=color:#ae81ff>0</span> Gaodeng <span style=color:#ae81ff>0</span> Aimini <span style=color:#ae81ff>0</span> Aidehua 
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>6</span>
</span></span></code></pre></div><p>获取所有人的名字:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; ZRANGEBYLEX names - +
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Aidehua&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Aimini&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Bluetuo&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Gaodeng&#34;</span>
</span></span><span style=display:flex><span>5<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Jake&#34;</span>
</span></span><span style=display:flex><span>6<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Toumas&#34;</span>
</span></span></code></pre></div><p>获取名字中大写字母A开头的所有人：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; ZRANGEBYLEX names <span style=color:#f92672>[</span>A <span style=color:#f92672>(</span>B
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Aidehua&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Aimini&#34;</span>
</span></span></code></pre></div><p>获取名字中大写字母 C 到 Z 的所有人：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; ZRANGEBYLEX names <span style=color:#f92672>[</span>C <span style=color:#f92672>[</span>Z
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Gaodeng&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Jake&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;Toumas&#34;</span>
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=bitmap>BitMap<a hidden class=anchor aria-hidden=true href=#bitmap>#</a></h4><ul><li><p>Bitmap，位图，是一串连续的二进制数组（0和1），可通过偏移量（offset）定位元素</p></li><li><p>特别适合一些数据量大且使用<strong>二值统计的场景</strong></p></li><li><p>内部实现</p><ul><li>Bitmap 本身是String 类型作为底层数据结构实现的一种统计二值状态的数据类型</li></ul></li><li><p>常用命令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 设置值，其中value只能是 0 和 1</span>
</span></span><span style=display:flex><span>SETBIT key offset value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取值</span>
</span></span><span style=display:flex><span>GETBIT key offset
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取指定范围内值为 1 的个数</span>
</span></span><span style=display:flex><span><span style=color:#75715e># start 和 end 以字节为单位</span>
</span></span><span style=display:flex><span>BITCOUNT key start end
</span></span></code></pre></div><ul><li>bitmap 运算操作：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># BitMap间的运算</span>
</span></span><span style=display:flex><span><span style=color:#75715e># operations 位移操作符，枚举值</span>
</span></span><span style=display:flex><span>  AND 与运算 &amp;
</span></span><span style=display:flex><span>  OR 或运算 |
</span></span><span style=display:flex><span>  XOR 异或 ^
</span></span><span style=display:flex><span>  NOT 取反 ~
</span></span><span style=display:flex><span><span style=color:#75715e># result 计算的结果，会存储在该key中</span>
</span></span><span style=display:flex><span><span style=color:#75715e># key1 … keyn 参与运算的key，可以有多个，空格分割，not运算只能一个key</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0。返回值是保存到 destkey 的字符串的长度（以字节byte为单位），和输入 key 中最长的字符串长度相等。</span>
</span></span><span style=display:flex><span>BITOP <span style=color:#f92672>[</span>operations<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>result<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>key1<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>keyn…<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 返回指定key中第一次出现指定value(0/1)的位置</span>
</span></span><span style=display:flex><span>BITPOS <span style=color:#f92672>[</span>key<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>value<span style=color:#f92672>]</span>
</span></span></code></pre></div></li><li><p>应用场景</p><ul><li><p>签到统计</p><p>用记录签到（1）或未签到（0）就是非常典型的二值状态</p><p>统计 ID 100 的用户在 2022 年 6 月份的签到情况，可以按照下面步骤进行操作。</p><ol><li>执行下面的命令，记录该用户 6 月 3 号已签到。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>SETBIT uid:sign:100:202206 <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><ol start=2><li>检查该用户 6 月 3 日是否签到。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>GETBIT uid:sign:100:202206 <span style=color:#ae81ff>2</span> 
</span></span></code></pre></div><ol start=3><li>统计该用户在 6 月份的签到次数。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>BITCOUNT uid:sign:100:202206
</span></span></code></pre></div></li></ul></li></ul></li></ul><h3 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h3><ul><li>在 Redis 3.0 版本中 List 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，List 数据类型底层数据结构是由 quicklist 实现的；</li><li>核心：<strong>双向链表</strong>变为<strong>quicklist</strong>，<strong>压缩列表</strong>变为<strong>listpack</strong></li><li></li></ul><ul><li><h4 id=sds>SDS<a hidden class=anchor aria-hidden=true href=#sds>#</a></h4><ul><li><p>C语言字符串缺陷：</p><ul><li>获取字符串长度的时间复杂度为 O（N）；</li><li>字符串结尾以 “\0” 字符标识，字符串里面不能包含 “\0” 字符，不能保存二进制数据；</li><li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止</li></ul></li><li><p>SDS结构设计</p><ul><li><p><strong>len，记录了字符串长度</strong>。时间复杂度只需要 O（1）</p></li><li><p><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求</p></li><li><p><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。</p></li><li><p><strong>buf[]，字节数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据</p><p>SDS 扩容的规则代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>hisds <span style=color:#a6e22e>hi_sdsMakeRoomFor</span>(hisds s, <span style=color:#66d9ef>size_t</span> addlen)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ... ...
</span></span><span style=display:flex><span>    <span style=color:#75715e>// s目前的剩余空间已足够，无需扩展，直接返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (avail <span style=color:#f92672>&gt;=</span> addlen)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> s;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//获取目前s的长度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    len <span style=color:#f92672>=</span> <span style=color:#a6e22e>hi_sdslen</span>(s);
</span></span><span style=display:flex><span>    sh <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)s <span style=color:#f92672>-</span> <span style=color:#a6e22e>hi_sdsHdrSize</span>(oldtype);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//扩展之后 s 至少需要的长度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    newlen <span style=color:#f92672>=</span> (len <span style=color:#f92672>+</span> addlen);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//根据新长度，为s分配新空间所需要的大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (newlen <span style=color:#f92672>&lt;</span> HI_SDS_MAX_PREALLOC)
</span></span><span style=display:flex><span>        <span style=color:#75715e>//新长度&lt;HI_SDS_MAX_PREALLOC 则分配所需空间*2的空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        newlen <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//否则，分配长度为目前长度+1MB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        newlen <span style=color:#f92672>+=</span> HI_SDS_MAX_PREALLOC;
</span></span><span style=display:flex><span>       ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>如果所需的 sds 长度<strong>小于 1 MB</strong>，那么最后的扩容是按照<strong>翻倍扩容</strong>来执行的，即 2 倍的newlen</li><li>如果所需的 sds 长度<strong>超过 1 MB</strong>，那么最后的扩容长度应该是 newlen <strong>+ 1MB</strong></li></ul></li></ul></li></ul></li><li><h4 id=链表>链表<a hidden class=anchor aria-hidden=true href=#链表>#</a></h4></li></ul><p>链表结构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> list {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//链表头节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    listNode <span style=color:#f92672>*</span>head;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//链表尾节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    listNode <span style=color:#f92672>*</span>tail;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//节点值复制函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span>dup)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//节点值释放函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>free)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//节点值比较函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>match)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>key);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//链表节点数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> len;
</span></span><span style=display:flex><span>} list;
</span></span></code></pre></div><ul><li><p>优缺点</p><ul><li>优点：<ul><li>listNode 链表节点的结构里带有 prev 和 next 指针，<strong>获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表</strong>；</li><li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以<strong>获取链表的表头节点和表尾节点的时间复杂度只需O(1)</strong>；</li><li>list 结构因为提供了链表节点数量 len，所以<strong>获取链表中的节点数量的时间复杂度只需O(1)</strong>；</li><li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此<strong>链表节点可以保存各种不同类型的值</strong>；</li></ul></li><li>缺点：<ul><li>链表每个节点之间内存都是不连续，<strong>无法很好利用 CPU 缓存</strong>。</li><li>保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong></li></ul></li></ul></li><li><h4 id=压缩列表>压缩列表<a hidden class=anchor aria-hidden=true href=#压缩列表>#</a></h4><ul><li>设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销</li><li>缺陷<ul><li>不能保存过多的元素，否则查询效率就会降低</li><li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题</li></ul></li><li>结构设计<ul><li>压缩列表 Redis 为了节约内存而开发的，<strong>由连续内存块组成的顺序型数据结构</strong></li><li>压缩列表在表头有三个字段：<ul><li><em><strong>zlbytes</strong></em>，记录整个压缩列表占用对内存字节数；</li><li><em><strong>zltail</strong></em>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li><li><em><strong>zllen</strong></em>，记录压缩列表包含的节点数量；</li><li><em><strong>zlend</strong></em>，标记压缩列表的结束点，固定值 0xFF（十进制255）</li></ul></li><li>压缩列表中，如果要查找定位第一个元素和最后一个元素，可通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong></li><li>压缩列表节点包含三部分内容：<ul><li><em><strong>prevlen</strong></em>：记录了「前一个节点」的长度，目的是为了实现从后向前遍历</li><li><em><strong>encoding</strong></em>：记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数</li><li><em><strong>data</strong></em>：记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定</li></ul></li><li>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关<ul><li><strong>前一个节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值</li><li><strong>前一个节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值</li></ul></li></ul></li><li>连锁更新<ul><li><strong>压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降</strong></li></ul></li><li>缺陷：<ul><li>空间扩展操作也就是重新分配内存，因此<strong>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong></li><li><strong>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题</strong></li></ul></li></ul></li><li><h4 id=哈希表>哈希表<a hidden class=anchor aria-hidden=true href=#哈希表>#</a></h4><ul><li><p>一种保存键值对（key-value）的数据结构
当一个键值对的键经过 Hash 函数计算后得到哈希值，再将(哈希值 % 哈希表大小)取模计算，得到的结果值就是该 key-value 对应的数组元素位置，也就是第几个哈希桶</p></li><li><p>哈希冲突：</p><p><strong>当有两个以上数量的 kay 被分配到了哈希表中同一个哈希桶上时，此时称这些 key 发生了冲突</strong></p></li><li><p>链式哈希：</p><p>每个哈希表节点都有一个 next 指针，用于指向下一个哈希表节点，因此多个哈希表节点可以用 next 指针构成一个单项链表，<strong>被分配到同一个哈希桶上的多个节点可以用这个单项链表连接起来</strong></p><p>链式哈希局限性也很明显，随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O(n)</p></li><li><p><strong>rehash</strong></p><ul><li><p>Redis 定义一个 dict 结构体，这个结构体里定义了<strong>两个哈希表（ht[2]）</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> dict {
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>…</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//两个Hash表，交替使用，用于rehash操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    dictht ht[<span style=color:#ae81ff>2</span>]; 
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>…</span>
</span></span><span style=display:flex><span>} dict;
</span></span></code></pre></div></li><li><p>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p><ul><li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大一倍（两倍的意思）；</li><li>将「哈希表 1 」的数据迁移到「哈希表 2」 中<ul><li><strong>「哈希表 1 」的数据量非常大，那迁移至「哈希表 2 」时，会涉及大量的数据拷贝，可能会对 Redis 造成阻塞，无法服务其他请求</strong></li></ul></li><li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备</li></ul></li><li><p><strong>渐进式rehash</strong></p><p>为避免 rehash 在数据迁移过程中，拷贝数据的耗时，采用<strong>渐进式 rehash</strong></p><p>把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作</p><ul><li>步骤如下：<ul><li>给「哈希表 2」 分配空间</li><li><strong>rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</strong></li><li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作</li></ul></li></ul></li></ul></li></ul></li><li><h4 id=整数集合>整数集合<a hidden class=anchor aria-hidden=true href=#整数集合>#</a></h4><ul><li><p>整数集合是 Set 对象的底层实现之一，整数集合本质是一块连续内存空间</p></li><li><p>结构设计：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> intset {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//编码方式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint32_t</span> encoding;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//集合包含的元素数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint32_t</span> length;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//保存元素的数组
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int8_t</span> contents[];
</span></span><span style=display:flex><span>} intset;
</span></span></code></pre></div></li><li><p>升级过程：</p><ul><li>当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性</li><li>整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后在将每个元素按间隔类型大小分割</li></ul></li><li><p><strong>不支持降级操作</strong>，一旦对数组进行了升级，就会一直保持升级后的状态</p></li></ul></li><li><h4 id=跳表>跳表<a hidden class=anchor aria-hidden=true href=#跳表>#</a></h4><ul><li><p>ZSET（有序集合）通常由跳表和哈希表两种数据结构组成：</p><ol><li><strong>跳表（Skip List）</strong>：<ul><li>用于维护元素的顺序，支持高效的范围查询（如ZRANGE、ZRANK等操作）。</li><li>跳表通过多层索引实现近似O(log N)的查找、插入和删除性能。</li></ul></li><li><strong>哈希表（Hash Table）</strong>：<ul><li>用于存储元素到分数的映射，支持O(1)时间复杂度的分数查找（如ZSCORE操作）。</li><li>哈希表通过键值对快速定位元素。</li></ul></li></ol></li><li><p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。</p><ul><li>好处：既能进行高效的范围查询，也能进行高效单点查询。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> zset {
</span></span><span style=display:flex><span>    dict <span style=color:#f92672>*</span>dict;
</span></span><span style=display:flex><span>    zskiplist <span style=color:#f92672>*</span>zsl;
</span></span><span style=display:flex><span>} zset;
</span></span></code></pre></div></li><li><p>结构设计</p><ul><li><p>链表查找元素的时候，需要逐一查找，所以查询效率非常低，时间复杂度是O(N)
<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong></p></li><li><p>「跳表节点」数据结构：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> zskiplistNode {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//Zset 对象的元素值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sds ele;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//元素权重值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> score;
</span></span><span style=display:flex><span>    <span style=color:#75715e>//后向指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> zskiplistNode <span style=color:#f92672>*</span>backward;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//节点的level数组，保存每层上的前向指针和跨度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> zskiplistLevel {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> zskiplistNode <span style=color:#f92672>*</span>forward;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> span;
</span></span><span style=display:flex><span>    } level[];
</span></span><span style=display:flex><span>} zskiplistNode;
</span></span></code></pre></div><p>「跳表」结构体：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> zskiplist {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> zskiplistNode <span style=color:#f92672>*</span>header, <span style=color:#f92672>*</span>tail;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> length;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> level;
</span></span><span style=display:flex><span>} zskiplist;
</span></span></code></pre></div><ul><li>跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；</li><li>跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；</li><li>跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量</li></ul></li></ul></li><li><p>跳表节点查询过程</p><ul><li>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层</li><li>用跳表节点中的 SDS 类型的元素和元素的权重来进行判断<ul><li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点</li><li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点</li></ul></li><li>上面两个条件都不满足，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找</li></ul></li><li><p>跳表节点层数设置</p><ul><li><strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong></li></ul></li><li><p>为什么使用跳表而不是平衡树</p><ul><li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。</li><li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。</li><li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。</li></ul></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/redis/>Redis</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/redis01/><span class=title>« Prev Page</span><br><span>Redis01</span>
</a><a class=next href=https://zwlzls.github.io/posts/mysql01/><span class=title>Next Page »</span><br><span>Mysql01</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>