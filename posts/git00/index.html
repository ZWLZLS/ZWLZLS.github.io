<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git基本 | 我的博客</title>
<meta name=keywords content="git"><meta name=description content="git基本操作 由于学习更偏重点性记录或自己使用角度，深入度可能不足，详细见https://gitee.com/progit/index.html
安装及配置 ：Git · Pro Git 第二版 简体中文
起步 版本控制 ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统
本地版本控制
eg : RCS工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中版本控制 : 不同系统上的开发者协同工作
有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 优点 ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限 缺点 ： 中央服务器的单点故障，只有单独快照 分布式版本控制
客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来 git基础
Git 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容 计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 执行的 Git 操作，几乎只往 Git 数据库中增加数据 三种状态 已提交表示数据已经安全的保存在本地数据库中 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此 三个工作区 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方(github) 工作目录是对项目的某个版本独立提取出来的内容(本地仓库) 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作索引 基本Git工作流程 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 Git基础 获取Git仓库"><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/git00/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/git00/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Git基本"><meta property="og:description" content="git基本操作 由于学习更偏重点性记录或自己使用角度，深入度可能不足，详细见https://gitee.com/progit/index.html
安装及配置 ：Git · Pro Git 第二版 简体中文
起步 版本控制 ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统
本地版本控制
eg : RCS工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中版本控制 : 不同系统上的开发者协同工作
有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 优点 ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限 缺点 ： 中央服务器的单点故障，只有单独快照 分布式版本控制
客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来 git基础
Git 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容 计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 执行的 Git 操作，几乎只往 Git 数据库中增加数据 三种状态 已提交表示数据已经安全的保存在本地数据库中 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此 三个工作区 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方(github) 工作目录是对项目的某个版本独立提取出来的内容(本地仓库) 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作索引 基本Git工作流程 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 Git基础 获取Git仓库"><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/git00/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-05T15:03:12+08:00"><meta property="article:modified_time" content="2025-01-05T15:03:12+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git基本"><meta name=twitter:description content="git基本操作 由于学习更偏重点性记录或自己使用角度，深入度可能不足，详细见https://gitee.com/progit/index.html
安装及配置 ：Git · Pro Git 第二版 简体中文
起步 版本控制 ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统
本地版本控制
eg : RCS工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中版本控制 : 不同系统上的开发者协同工作
有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 优点 ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限 缺点 ： 中央服务器的单点故障，只有单独快照 分布式版本控制
客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来 git基础
Git 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容 计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 执行的 Git 操作，几乎只往 Git 数据库中增加数据 三种状态 已提交表示数据已经安全的保存在本地数据库中 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此 三个工作区 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方(github) 工作目录是对项目的某个版本独立提取出来的内容(本地仓库) 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作索引 基本Git工作流程 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 Git基础 获取Git仓库"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Git基本","item":"https://zwlzls.github.io/posts/git00/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git基本","name":"Git基本","description":"git基本操作 由于学习更偏重点性记录或自己使用角度，深入度可能不足，详细见https://gitee.com/progit/index.html\n安装及配置 ：Git · Pro Git 第二版 简体中文\n起步 版本控制 ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统\n本地版本控制\neg : RCS工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中版本控制 : 不同系统上的开发者协同工作\n有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 优点 ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限 缺点 ： 中央服务器的单点故障，只有单独快照 分布式版本控制\n客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来 git基础\nGit 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容 计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 执行的 Git 操作，几乎只往 Git 数据库中增加数据 三种状态 已提交表示数据已经安全的保存在本地数据库中 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此 三个工作区 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方(github) 工作目录是对项目的某个版本独立提取出来的内容(本地仓库) 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作索引 基本Git工作流程 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 Git基础 获取Git仓库","keywords":["git"],"articleBody":"git基本操作 由于学习更偏重点性记录或自己使用角度，深入度可能不足，详细见https://gitee.com/progit/index.html\n安装及配置 ：Git · Pro Git 第二版 简体中文\n起步 版本控制 ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统\n本地版本控制\neg : RCS工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中版本控制 : 不同系统上的开发者协同工作\n有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 优点 ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限 缺点 ： 中央服务器的单点故障，只有单独快照 分布式版本控制\n客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来 git基础\nGit 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容 计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 执行的 Git 操作，几乎只往 Git 数据库中增加数据 三种状态 已提交表示数据已经安全的保存在本地数据库中 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此 三个工作区 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方(github) 工作目录是对项目的某个版本独立提取出来的内容(本地仓库) 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作索引 基本Git工作流程 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 Git基础 获取Git仓库\n在现有目录中初始化仓库 git init\n在已经存在 文件 的文件夹中初始化\n$ git add *.c $ git commit -m 'initial project version' 克隆现有仓库\ngit clone [url] 记录每次更新到仓库\n工作目录下的每一个文件都不外乎这两种状态：已跟踪(git add)or未跟踪\n已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区\n工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。\n初次克隆(git clone)某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态\n检查当前文件状态 git status\n目录干净 ：所有已跟踪文件在上次提交后都未被更改过 在 Untracked files 下面： 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件 在 Changes to be committed 这行下面 : 是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中 在 Changes not staged for commit 这行下 ： 已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 git add 命令 跟踪新文件 git add newfile\ngit add理解 ：添加内容到下一次提交中 忽略文件 ：总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表\n创建一个名为 .gitignore 的文件，列出要忽略的文件模式 这个可以需要时学习，Tip : https://github.com/github/gitignore 查看已暂存和未暂存的修改 git diff\ngit diff : 修改之后还没有暂存起来的变化内容 git diff --cached : 查看已暂存的将要添加到下次提交里的内容 提交更新\n都已暂存起来了， 然后再运行提交命令 git commit 跳过使用暂存区域\n给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤\n$ git commit -a -m 'added new benchmarks' 移除文件 手工删除 ： 运行 git status 会在 Changes not staged for commit 部分 git rm命令 ： 从已跟踪文件清单中移除，并从工作目录中删除指定的文件，就不会出现在未跟踪文件清单中\n也可以使用 glob 模式 强制删除 ： git rm -f file 使用 --cached 选项：把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中 移动文件 : 不显示跟踪文件移动操作 重命名 ：$ git mv file_from file_to\n查看提交历史\ngit log ：会按提交时间列出所有的更新，最近的更新排在最上面\n作者指的是实际作出修改的人 提交者指的是最后将此工作成果提交到仓库的人 常用的选项是 -p，用来显示每次提交的内容差异。 也可以加上 -2 来仅显示最近两次提交\n其他常见参数，具体学习 查看提交历史 · Pro Git 第二版 简体中文\ngit log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况\n撤销操作\n提交信息写错，可以运行带有 --amend 选项的提交命令尝试重新提交\n$ git commit -m 'initial commit' $ git add forgotten_file $ git commit --amend 取消暂存区文件,将暂存区文件变为暂存状态\ngit reset HEAD ... eg: $ git reset HEAD CONTRIBUTING.md 取消本次修改，还原成上次提交样子\nuse \"git checkout -- ...\" to discard changes in working directory eg :$ git checkout -- CONTRIBUTING.md 远程仓库的使用\n远程仓库 ： 托管在因特网或其他网络中的你的项目的版本库\n查看远程仓库 ：运行 git remote 命令。 它会列出你指定的每一个远程服务器的简写\n可以指定选项 -v，显示需要读写远程仓库使用的 Git 保存的简写与对应的 URL git remote show [remote-name] : 查看某一个远程仓库的更多信息 添加远程仓库 ：运行 git remote add 添加一个新的远程 Git 仓库，同时指定一个轻松引用的简写\n从远程仓库中抓取与拉取 ：\ngit fetch [remote-name] : 访问远程仓库，从中拉取所有你还没有的数据，拥有那个远程仓库中所有分支的引用，可以随时合并或查看 使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 ``origin 为简写。git fetch origin` 会抓取克隆（或上一次抓取）后新推送的所有工作 注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作 git pull 区分如下 ：更简单 如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支 默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支） git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支 推送到远程仓库 ：\ngit push [remote-name] [branch-name]。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字） 远程仓库的移除与重命名 ：\ngit remote rename 去修改一个远程仓库的简写名\n$ git remote rename pb paul 修改你的远程分支名字。 那些过去引用 pb/master 的现在会引用 paul/master\n移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 git remote rm\n打标签\nGit 可以给历史中的某一个提交打上标签，以示重要。 有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）\ngit tag : 列出已有的标签是非常简单直观的\ngit show 命令可以看到标签信息与对应的提交信息 eg : git show v1.4\n创建标签 ：\n轻量标签（lightweight）：像一个不会改变的分支 - 它只是一个特定提交的引用 附注标签（annotated）：存储在 Git 数据库中的一个完整对象及拥有很多信息 如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的 附注标签 ：\n运行 tag 命令时指定 -a 选项，-m 选项指定了一条将会存储在标签中的信息\n$ git tag -a v1.4 -m 'my version 1.4' 轻量标签 ：\n创建轻量标签，不需要使用 -a， -m 选项，只需要提供标签名字\n$ git tag v1.4-lw 后期打标签 ：\n查看过去提交历史，eg :git tag -a \u003c版本\u003e \u003c历史版本hash\u003e 共享标签 ：\ngit push 命令并不会传送标签到远程仓库服务器上，运行 git push origin [tagname]\n一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里\ngit push origin --tags 检出标签 ：\n如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支 但分支被提交会改变，要注意 Git分支 分支简介\nGit 保存的不是文件的变化，而是一系列不同时刻的文件快照\nGit 会保存一个提交对象(commit object)，我们可以想到——该提交对象会包含一个指向暂存内容快照的指针\n分支创建 ：\n为你创建了一个可以移动的新的指针，使用 git branch\n$ git branch testing HEAD 指向当前所在的分支，而且HEAD 分支随着提交操作自动向前移动\n分支切换 ：\n切换到一个已存在的分支，你需要使用 git checkout\n$ git checkout testing 分支切换会改变你工作目录中的文件\n在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。\n如果 Git 不能干净利落地完成这个任务，它将禁止切换分支\n分支新建与合并merge\n新建分支\n运行一个带有 -b 参数的 git checkout：新建并同时切换到那个分支上 合并分支\n如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移）\n$ git checkout master $ git merge hotfix Updating f42c576..3a0874c Fast-forward index.html | 2 ++ 1 file changed, 2 insertions(+) 此时 hotfix 与 master 指向同一快照版本C4\n从一个更早的地方开始分叉开来，进行合并\n$ git checkout master Switched to branch 'master' $ git merge iss53 Merge made by the 'recursive' strategy. index.html | 1 + 1 file changed, 1 insertion(+) 一次典型合并中所用到的三个快照\n删除分支：\n使用带 -d 选项的 git branch 命令 如果分支没有被合并，Git 会阻止你删除该分支，以防止丢失未合并的提交。你可以使用 git branch -D 强制删除分支，但这样做会丢失未合并的提交. 遇到冲突时的分支合并\n如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件，进行修改 分支管理\ngit branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表 查看每一个分支的最后一次提交，运行 git branch -v 查看所有包含未合并工作的分支，可以运行 git branch --no-merged 查看哪些分支已经合并到当前分支，可以运行 git branch --merged 分支开发工作流\n长期分支：有几个固定长期分支 比如只在 master 分支上保留完全稳定的代码——已经发布代码。 还有一些名为 develop 或者 next 的平行分支，被用来做后续开发——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 特性分支 创建一些新分支创作，进行合并，之后删除。 远程分支\ngit push (远程仓库名)/(分支名) 就会改变此远程仓库的分支位置\n远程分支（remote branch）是对远程仓库中的分支的索引，只有在 Git 进行网络交互时才会更新，用 (远程仓库名)/(分支名) 的形式表示远程分支\n如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，那么服务器上的 master 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动\n运行 git fetch origin 来同步远程服务器上的数据到本地\n推送本地分支\n需要和他人一起开发此分支，可以运行 git push (远程仓库名) (分支名)，完整写法git push (远程仓库名) （本地分支名)：(远程分支名)\n值得注意的是，在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支\n要把该远程分支的内容合并到当前分支，可以运行 git merge (远程仓库名)/(远程分支名) 或自己重新一个分支\n跟踪远程分支\n从远程分支 checkout 出来的本地分支，称为 跟踪分支 (tracking branch)。 跟踪分支是一种和某个远程分支有直接联系的本地分支。 在跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。而git clone会自动创建跟踪 git checkout -b [分支名] [远程名]/[分支名] 可以创建跟踪远程分支 删除远程分支\ngit push [远程名] :[分支名]可以理解为 ： 在这里提取空白然后把它变成[远程分支]”。 变基rebase\n在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase\n你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上再应用一次。 在 Git 中，这种操作就叫做 变基\n具体操作如下\n$ git checkout experiment $ git rebase master First, rewinding head to replay your work on top of it... Applying: added staged command $ git checkout master $ git merge experiment 理解如下\n先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。\n更高级的例子\n==想要将 client 中的修改合并到主分支并发布，但暂时并不想合并 server中的修改==，可以使用 git rebase 命令的 --onto 选项，选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重演 $ git rebase --onto master server client 理解方式：取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重演一遍\n快进合并master分支\n$ git checkout master $ git merge client 变基的风险，遵守一条准则\n不要对在 你的仓库外有副本 的分支执行变基 出现风险，解决方法之后学，现在还看不太懂 变基 vs. 合并 具体因人而异\n合并：记录实际发生过什么 变基：项目过程中发生的故事 核心观点 ： 只对尚未 推送或分享 给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作 以上基本操作使用学习完毕 ","wordCount":"846","inLanguage":"en","datePublished":"2025-01-05T15:03:12+08:00","dateModified":"2025-01-05T15:03:12+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/git00/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Git基本</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#git%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c aria-label=git基本操作>git基本操作</a><ul><ul><li><a href=#%e8%b5%b7%e6%ad%a5 aria-label=起步>起步</a></li></ul><li><a href=#git%e5%9f%ba%e7%a1%80 aria-label=Git基础>Git基础</a></li><li><a href=#git%e5%88%86%e6%94%af aria-label=Git分支>Git分支</a></li></ul></li></ul><li><a href=#%e4%bb%a5%e4%b8%8a%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c%e4%bd%bf%e7%94%a8%e5%ad%a6%e4%b9%a0%e5%ae%8c%e6%af%95 aria-label=以上基本操作使用学习完毕>以上基本操作使用学习完毕</a></li></ul></div></details></div><div class=post-content><h2 id=git基本操作>git基本操作<a hidden class=anchor aria-hidden=true href=#git基本操作>#</a></h2><p><strong>由于学习更偏重点性记录或自己使用角度，深入度可能不足，详细见https://gitee.com/progit/index.html</strong></p><p><strong>安装及配置</strong> ：<a href=https://bingohuang.gitbooks.io/progit2/content/01-introduction/sections/installing.html>Git · Pro Git 第二版 简体中文</a></p><h4 id=起步>起步<a hidden class=anchor aria-hidden=true href=#起步>#</a></h4><ul><li><p><strong>版本控制</strong> ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统</p></li><li><p><strong>本地版本控制</strong></p><ul><li>eg : <strong>RCS</strong>工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</li></ul></li><li><p><strong>集中版本控制</strong> : 不同系统上的开发者协同工作</p><ul><li>有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新</li><li><strong>优点</strong> ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限</li><li><strong>缺点</strong> ： 中央服务器的单点故障，只有单独快照</li></ul></li><li><p><strong>分布式版本控制</strong></p><ul><li>客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来</li></ul></li><li><p><strong>git基础</strong></p><ul><li>Git 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong></li><li>Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息</li><li>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容<ul><li>计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来</li><li>实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名</li></ul></li><li>执行的 Git 操作，几乎只往 Git 数据库中增加数据</li><li><strong>三种状态</strong><ul><li><strong>已提交</strong>表示数据已经安全的保存在本地数据库中</li><li><strong>已修改</strong>表示修改了文件，但还没保存到数据库中</li><li><strong>已暂存</strong>表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li></ul></li><li>由此 <strong>三个工作区</strong><ul><li><strong>Git 仓库</strong>目录是 Git 用来保存项目的元数据和对象数据库的地方(<strong>github</strong>)</li><li><strong>工作目录</strong>是对项目的某个版本独立提取出来的内容(<strong>本地仓库</strong>)</li><li><strong>暂存区域</strong>是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作<strong>索引</strong></li></ul></li><li>基本Git工作流程<ul><li>在工作目录中修改文件</li><li>暂存文件，将文件的快照放入暂存区域</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录</li></ul></li></ul></li></ul><h3 id=git基础>Git基础<a hidden class=anchor aria-hidden=true href=#git基础>#</a></h3><ul><li><p><strong>获取Git仓库</strong></p><ul><li><p>在现有目录中初始化仓库 <code>git init</code></p><ul><li><p>在已经存在 <strong>文件</strong> 的文件夹中初始化</p><ul><li><pre tabindex=0><code class=language-git data-lang=git>$ git add *.c
$ git commit -m &#39;initial project version&#39;
</code></pre></li></ul></li></ul></li><li><p>克隆现有仓库</p><ul><li><code>git clone [url]</code></li></ul></li></ul></li><li><p><strong>记录每次更新到仓库</strong></p><p>工作目录下的每一个文件都不外乎这两种状态：<strong>已跟踪</strong>(<strong>git add</strong>)or<strong>未跟踪</strong></p><p><strong>已跟踪的文件</strong>是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区</p><p>工作目录中除已跟踪文件以外的所有其它文件都属于<strong>未跟踪文件</strong>，它们既不存在于上次快照的记录中，也没有放入暂存区。</p><p>初次克隆(<strong>git clone</strong>)某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态</p><ul><li><p><strong>检查当前文件状态</strong> <code>git status</code></p><ul><li>目录干净 ：所有已跟踪文件在上次提交后都未被更改过</li><li>在 <code>Untracked files</code> 下面： 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件</li><li>在 <code>Changes to be committed</code> 这行下面 : 是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中</li><li>在 <code>Changes not staged for commit</code> 这行下 ： 已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令</li></ul></li><li><p><strong>跟踪新文件</strong> <code>git add newfile</code></p><ul><li><code>git add</code>理解 ：<strong>添加内容到下一次提交中</strong></li></ul></li><li><p><strong>忽略文件</strong> ：总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表</p><ul><li>创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式</li><li>这个可以需要时学习，<strong>Tip</strong> : <a href=https://github.com/github/gitignore>https://github.com/github/gitignore</a></li></ul></li><li><p><strong>查看已暂存和未暂存的修改</strong> <code>git diff</code></p><ul><li><code>git diff</code> : 修改之后还没有暂存起来的变化内容</li><li><code>git diff --cached</code> : 查看已暂存的将要添加到下次提交里的内容</li></ul></li><li><p><strong>提交更新</strong></p><ul><li>都已暂存起来了， 然后再运行提交命令 <code>git commit</code></li></ul></li><li><p><strong>跳过使用暂存区域</strong></p><ul><li><p>给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git commit -a -m <span style=color:#e6db74>&#39;added new benchmarks&#39;</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>移除文件</strong>
手工删除 ： 运行 <code>git status</code> 会在 <code>Changes not staged for commit</code> 部分
<code>git rm</code>命令 ： 从已跟踪文件清单中移除，并从工作目录中删除指定的文件，就不会出现在未跟踪文件清单中</p><ul><li>也可以使用 <code>glob</code> 模式</li><li>强制删除 ： <code>git rm -f file</code></li><li>使用 <code>--cached</code> 选项：把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中</li></ul></li><li><p><strong>移动文件</strong> : 不显示跟踪文件移动操作
<strong>重命名</strong> ：<code>$ git mv file_from file_to</code></p></li></ul></li><li><p><strong>查看提交历史</strong></p><ul><li><p><strong>git log</strong> ：会按提交时间列出所有的更新，最近的更新排在最上面</p><p><strong>作者</strong>指的是实际作出修改的人
<strong>提交者</strong>指的是最后将此工作成果提交到仓库的人
常用的选项是 <code>-p</code>，用来显示每次提交的内容差异。
也可以加上 <code>-2</code> 来仅显示最近两次提交</p></li><li><p>其他常见参数，具体学习 <a href=https://bingohuang.gitbooks.io/progit2/content/02-git-basics/sections/viewing-history.html>查看提交历史 · Pro Git 第二版 简体中文</a></p></li><li><p><code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的<strong>分支分叉情况</strong></p></li></ul></li><li><p><strong>撤销操作</strong></p><ul><li><p>提交信息写错，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git commit -m <span style=color:#e6db74>&#39;initial commit&#39;</span>
</span></span><span style=display:flex><span>$ git add forgotten_file
</span></span><span style=display:flex><span>$ git commit --amend
</span></span></code></pre></div></li></ul></li><li><p>取消暂存区文件,将暂存区文件变为暂存状态</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>git reset HEAD &lt;file&gt;...
</span></span><span style=display:flex><span>eg: $ git reset HEAD CONTRIBUTING.md
</span></span></code></pre></div></li></ul></li><li><p>取消本次修改，还原成上次提交样子</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>use &#34;git checkout -- &lt;file&gt;...&#34; to discard changes in working directory
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>eg :$ git checkout -- CONTRIBUTING.md
</span></span></code></pre></div></li></ul></li></ul></li><li><p><strong>远程仓库的使用</strong></p><ul><li><p><strong>远程仓库</strong> ： 托管在因特网或其他网络中的你的项目的版本库</p></li><li><p><strong>查看远程仓库</strong> ：运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写</p><ul><li>可以指定选项 <code>-v</code>，显示需要读写远程仓库使用的 Git 保存的简写与对应的 URL</li><li><code>git remote show [remote-name]</code> : 查看某一个远程仓库的更多信息</li></ul></li><li><p><strong>添加远程仓库</strong> ：运行 <code>git remote add &lt;remote-name> &lt;url></code> 添加一个新的远程 Git 仓库，同时指定一个轻松引用的简写</p></li><li><p><strong>从远程仓库中抓取与拉取</strong> ：</p><ul><li><code>git fetch [remote-name]</code> : 访问远程仓库，从中拉取所有你还没有的数据，拥有那个远程仓库中所有分支的引用，可以随时合并或查看</li><li>使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 ``origin<code> 为简写。</code>git fetch origin` 会抓取克隆（或上一次抓取）后新推送的所有工作</li><li><strong>注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作</strong></li><li><strong><code>git pull</code> 区分如下</strong> ：更简单<ul><li>如果你有一个分支设置为<strong>跟踪</strong>一个远程分支，可以使用 <code>git pull</code> 命令来自动的抓取然后合并远程分支到当前分支</li><li>默认情况下，<code>git clone</code> 命令会<strong>自动设置本地 master 分支跟踪</strong>克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）</li><li><code>git pull</code> 通常会从最初克隆的服务器上抓取数据并<strong>自动尝试合并</strong>到当前所在的分支</li></ul></li></ul></li><li><p><strong>推送到远程仓库</strong> ：</p><ul><li><code>git push [remote-name] [branch-name]</code>。 当你想要将 master 分支推送到 <code>origin</code> 服务器时（<strong>再次说明，克隆时通常会自动帮你设置好那两个名字</strong>）</li></ul></li><li><p><strong>远程仓库的移除与重命名</strong> ：</p><ul><li><p><code>git remote rename</code> 去修改一个远程仓库的简写名</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git remote rename pb paul
</span></span></code></pre></div></li><li><p>修改你的远程分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code></p></li></ul></li><li><p><strong>移除</strong>一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 <code>git remote rm</code></p></li></ul></li></ul></li><li><p><strong>打标签</strong></p><ul><li><p>Git 可以给历史中的某一个提交打上标签，以示重要。 有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）</p></li><li><p><code>git tag</code> : 列出已有的标签是非常简单直观的</p></li><li><p><code>git show</code> 命令可以看到标签信息与对应的提交信息
<strong>eg</strong> : <code>git show v1.4</code></p></li><li><p><strong>创建标签</strong> ：</p><ul><li>轻量标签（lightweight）：像一个不会改变的分支 - 它只是一个特定提交的引用</li><li>附注标签（annotated）：存储在 Git 数据库中的一个完整对象及拥有很多信息</li><li><strong>如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的</strong></li></ul></li><li><p><strong>附注标签</strong> ：</p><ul><li><p>运行 <code>tag</code> 命令时指定 <code>-a</code> 选项，<code>-m</code> 选项指定了一条将会存储在标签中的信息</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git tag -a v1.4 -m <span style=color:#e6db74>&#39;my version 1.4&#39;</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>轻量标签</strong> ：</p><ul><li><p>创建轻量标签，不需要使用 <code>-a</code>， <code>-m</code> 选项，只需要提供标签名字</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git tag v1.4-lw
</span></span></code></pre></div></li></ul></li><li><p><strong>后期打标签</strong> ：</p><ul><li>查看过去提交历史，eg :<code>git tag -a &lt;版本> &lt;历史版本hash></code></li></ul></li><li><p><strong>共享标签</strong> ：</p><ul><li><p><code>git push</code> 命令并不会传送标签到远程仓库服务器上，运行 <code>git push origin [tagname]</code></p></li><li><p>一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span> git push origin --tags
</span></span></code></pre></div></li></ul></li><li><p><strong>检出标签</strong> ：</p><ul><li>如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 <code>git checkout -b [branchname] [tagname]</code> 在特定的标签上创建一个新分支</li><li><strong>但分支被提交会改变，要注意</strong></li></ul></li></ul></li></ul><h3 id=git分支>Git分支<a hidden class=anchor aria-hidden=true href=#git分支>#</a></h3><ul><li><p><strong>分支简介</strong></p><ul><li><p>Git 保存的不是文件的变化，而是一系列不同时刻的<strong>文件快照</strong></p></li><li><p>Git 会保存一个提交对象(commit object)，我们可以想到——该提交对象会包含一个指向暂存内容快照的<strong>指针</strong></p></li><li><p><strong>分支创建</strong> ：</p><ul><li><p>为你创建了一个可以移动的新的指针，使用 <code>git branch</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git branch testing
</span></span></code></pre></div></li><li><p>HEAD 指向当前所在的分支，而且HEAD 分支随着<strong>提交操作</strong>自动向前移动</p></li></ul></li><li><p><strong>分支切换</strong> ：</p><ul><li><p>切换到一个已存在的分支，你需要使用 <code>git checkout</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git checkout testing
</span></span></code></pre></div></li><li><p><strong>分支切换会改变你工作目录中的文件</strong></p><p>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。</p><p>如果 Git 不能干净利落地完成这个任务，它将<strong>禁止切换分支</strong></p></li></ul></li></ul></li><li><p><strong>分支新建与合并merge</strong></p><ul><li><p><strong>新建分支</strong></p><ul><li>运行一个带有 <code>-b</code> 参数的 <code>git checkout</code>：<strong>新建并同时</strong>切换到那个分支上</li></ul></li><li><p><strong>合并分支</strong></p><ul><li><p>如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>$ git merge hotfix
</span></span><span style=display:flex><span>Updating f42c576..3a0874c
</span></span><span style=display:flex><span>Fast-forward
</span></span><span style=display:flex><span> index.html | 2 ++
</span></span><span style=display:flex><span> 1 file changed, 2 insertions(+)
</span></span></code></pre></div><p>此时 hotfix 与 master 指向同一快照版本C4</p></li><li><p>从一个更早的地方开始分叉开来，进行合并</p><p><img loading=lazy src=../../static/png/basic-merging-1.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>Switched to branch &#39;master&#39;
</span></span><span style=display:flex><span>$ git merge iss53
</span></span><span style=display:flex><span>Merge made by the &#39;recursive&#39; strategy.
</span></span><span style=display:flex><span>index.html |    1 +
</span></span><span style=display:flex><span>1 file changed, 1 insertion(+)
</span></span></code></pre></div><p><img loading=lazy src=../../static/png/basic-merging-2.png alt></p><p><strong>一次典型合并中所用到的三个快照</strong></p></li></ul></li><li><p><strong>删除分支</strong>：</p><ul><li>使用带 <code>-d</code> 选项的 <code>git branch</code> 命令</li><li>如果分支没有被合并，Git 会阻止你删除该分支，以防止丢失未合并的提交。你可以使用 <code>git branch -D &lt;branch_name> </code>强制删除分支，但这样做会丢失未合并的提交.</li></ul></li><li><p><strong>遇到冲突时的分支合并</strong></p><ul><li>如果你在两个不同的分支中，<strong>对同一个文件的同一个部分进行了不同的修改</strong>，Git 就没法干净的合并它们</li><li><code>git status</code> 命令来查看那些因包含合并冲突而处于<strong>未合并</strong>（unmerged）状态的文件，进行修改</li></ul></li></ul></li><li><p><strong>分支管理</strong></p><ul><li><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表</li><li>查看每一个分支的最后一次提交，运行 <code>git branch -v</code></li><li>查看所有包含未合并工作的分支，可以运行 <code>git branch --no-merged</code></li><li>查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code></li></ul></li><li><p><strong>分支开发工作流</strong></p><ul><li><strong>长期分支：有几个固定长期分支</strong><ul><li>比如只在 <code>master</code> 分支上保留完全稳定的代码——已经发布代码。 还有一些名为 <code>develop</code> 或者 <code>next</code> 的平行分支，被用来做后续开发——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 <code>master</code></li></ul></li><li><strong>特性分支</strong><ul><li>创建一些新分支创作，进行合并，之后删除。</li></ul></li></ul></li><li><p><strong>远程分支</strong></p><ul><li><p><code>git push (远程仓库名)/(分支名)</code> 就会改变此远程仓库的分支位置</p></li><li><p>远程分支（remote branch）是对远程仓库中的分支的索引，只有在 Git 进行网络交互时才会更新，用 <code>(远程仓库名)/(分支名)</code> 的形式表示远程分支</p><p><img loading=lazy src=../../static/png/18333fig0322-tn.png alt></p></li><li><p><strong>如果你在本地 <code>master</code> 分支做了些改动，与此同时，其他人向 <code>git.ourcompany.com</code> 推送了他们的更新，那么服务器上的 <code>master</code> 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 <code>origin/master</code> 指针仍然保持原位不会移动</strong></p><ul><li><p>运行 <code>git fetch origin</code> 来同步远程服务器上的数据到本地</p><p><img loading=lazy src=../../static/png/18333fig0324-tn.png alt></p></li></ul></li><li><p><strong>推送本地分支</strong></p><ol><li><p>需要和他人一起开发此分支，可以运行 <code>git push (远程仓库名) (分支名)</code>，完整写法<code>git push (远程仓库名) （本地分支名)：(远程分支名)</code></p></li><li><p><strong>值得注意的是，在 <code>fetch</code> 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支</strong></p></li><li><p>要把该远程分支的内容合并到当前分支，可以运行 <code>git merge (远程仓库名)/(远程分支名)</code> 或自己重新一个分支</p></li></ol></li><li><p><strong>跟踪远程分支</strong></p><ul><li>从远程分支 <code>checkout</code> 出来的本地分支，称为 <em>跟踪分支</em> (tracking branch)。</li><li>跟踪分支是一种和某个远程分支有直接联系的本地分支。</li><li>在<strong>跟踪分支</strong>里输入 <code>git push</code>，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 <code>git pull</code> 会获取所有远程索引，并把它们的数据都合并到本地分支中来。而<code>git clone</code>会自动创建跟踪</li><li><code>git checkout -b [分支名] [远程名]/[分支名]</code> 可以创建跟踪远程分支</li></ul></li><li><p><strong>删除远程分支</strong></p><ul><li><strong><code>git push [远程名] :[分支名]</code>可以理解为 ： 在这里提取空白然后把它变成<code>[远程分支]</code>”。</strong></li></ul></li></ul></li><li><p><strong>变基rebase</strong></p><ul><li><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code></p></li><li><p>你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上再应用一次。 在 Git 中，这种操作就叫做 <strong>变基</strong></p></li><li><p><strong>具体操作如下</strong></p><p><img loading=lazy src=../../static/png/basic-rebase-1.png alt></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git checkout experiment
</span></span><span style=display:flex><span>$ git rebase master
</span></span><span style=display:flex><span>First, rewinding head to replay your work on top of it...
</span></span><span style=display:flex><span>Applying: added staged command
</span></span></code></pre></div><p><img loading=lazy src=../../static/png/basic-rebase-3.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>$ git merge experiment
</span></span></code></pre></div><p><img loading=lazy src=../../static/png/basic-rebase-4.png alt></p><p><strong>理解如下</strong></p></li><li><p>先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>）的最近共同祖先 <code>C2</code>，<strong>对比当前分支相对于该祖先的历次提交</strong>，提取相应的修改并存为临时文件，将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。</p></li></ul></li><li><p><strong>更高级的例子</strong></p><ul><li>==想要将 client 中的修改合并到主分支并发布，但暂时并不想合并 server中的修改==，可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项，选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重演</li></ul><p><img loading=lazy src=../../static/png/interesting-rebase-1.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git rebase --onto master server client
</span></span></code></pre></div><p><strong>理解方式</strong>：取出 <code>client</code> 分支，找出处于 <code>client</code> 分支和 <code>server</code> 分支的共同祖先之后的修改，然后把它们在 <code>master</code> 分支上重演一遍</p><p><img loading=lazy src=../../static/png/interesting-rebase-2.png alt></p><p><strong>快进合并</strong><code>master</code>分支</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git checkout master
</span></span><span style=display:flex><span>$ git merge client
</span></span></code></pre></div><p><img loading=lazy src=../../static/png/interesting-rebase-3.png alt></p></li><li><p><strong>变基的风险，遵守一条准则</strong></p><ul><li><strong>不要对在 你的仓库外有副本 的分支执行变基</strong></li><li>出现风险，解决方法之后学，现在还看不太懂</li></ul></li><li><p><strong>变基 vs. 合并 具体因人而异</strong></p><ul><li>合并：<strong>记录实际发生过什么</strong></li><li>变基：<strong>项目过程中发生的故事</strong></li><li><strong>核心观点</strong> ： <strong>只对尚未 推送或分享</strong> 给别人的本地修改<strong>执行变基</strong>操作清理历史，<strong>从不对已推送</strong>至别处的提交<strong>执行变基</strong>操作</li></ul></li></ul><h1 id=以上基本操作使用学习完毕>以上基本操作使用学习完毕<a hidden class=anchor aria-hidden=true href=#以上基本操作使用学习完毕>#</a></h1></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/linux01/><span class=title>« Prev Page</span><br><span>Linux01(命令)</span>
</a><a class=next href=https://zwlzls.github.io/posts/linux00/><span class=title>Next Page »</span><br><span>Linux介绍</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>