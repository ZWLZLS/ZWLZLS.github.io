<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git00 | 我的博客</title>
<meta name=keywords content="git"><meta name=description content="git学习 安装及配置 ：Git · Pro Git 第二版 简体中文
起步 版本控制 ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统
本地版本控制
eg : RCS工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中版本控制 : 不同系统上的开发者协同工作
有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 优点 ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限 缺点 ： 中央服务器的单点故障，只有单独快照 分布式版本控制
客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来 git基础
Git 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容 计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 执行的 Git 操作，几乎只往 Git 数据库中增加数据 三种状态 已提交表示数据已经安全的保存在本地数据库中 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此 三个工作区 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方(github) 工作目录是对项目的某个版本独立提取出来的内容(本地仓库) 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作索引 基本Git工作流程 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 Git基础 获取Git仓库"><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/git00/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/git00/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Git00"><meta property="og:description" content="git学习 安装及配置 ：Git · Pro Git 第二版 简体中文
起步 版本控制 ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统
本地版本控制
eg : RCS工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中版本控制 : 不同系统上的开发者协同工作
有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 优点 ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限 缺点 ： 中央服务器的单点故障，只有单独快照 分布式版本控制
客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来 git基础
Git 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容 计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 执行的 Git 操作，几乎只往 Git 数据库中增加数据 三种状态 已提交表示数据已经安全的保存在本地数据库中 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此 三个工作区 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方(github) 工作目录是对项目的某个版本独立提取出来的内容(本地仓库) 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作索引 基本Git工作流程 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 Git基础 获取Git仓库"><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/git00/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-05T15:03:12+08:00"><meta property="article:modified_time" content="2025-01-05T15:03:12+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git00"><meta name=twitter:description content="git学习 安装及配置 ：Git · Pro Git 第二版 简体中文
起步 版本控制 ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统
本地版本控制
eg : RCS工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中版本控制 : 不同系统上的开发者协同工作
有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 优点 ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限 缺点 ： 中央服务器的单点故障，只有单独快照 分布式版本控制
客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来 git基础
Git 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容 计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 执行的 Git 操作，几乎只往 Git 数据库中增加数据 三种状态 已提交表示数据已经安全的保存在本地数据库中 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此 三个工作区 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方(github) 工作目录是对项目的某个版本独立提取出来的内容(本地仓库) 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作索引 基本Git工作流程 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 Git基础 获取Git仓库"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Git00","item":"https://zwlzls.github.io/posts/git00/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git00","name":"Git00","description":"git学习 安装及配置 ：Git · Pro Git 第二版 简体中文\n起步 版本控制 ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统\n本地版本控制\neg : RCS工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中版本控制 : 不同系统上的开发者协同工作\n有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 优点 ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限 缺点 ： 中央服务器的单点故障，只有单独快照 分布式版本控制\n客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来 git基础\nGit 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容 计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 执行的 Git 操作，几乎只往 Git 数据库中增加数据 三种状态 已提交表示数据已经安全的保存在本地数据库中 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此 三个工作区 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方(github) 工作目录是对项目的某个版本独立提取出来的内容(本地仓库) 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作索引 基本Git工作流程 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 Git基础 获取Git仓库","keywords":["git"],"articleBody":"git学习 安装及配置 ：Git · Pro Git 第二版 简体中文\n起步 版本控制 ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统\n本地版本控制\neg : RCS工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中版本控制 : 不同系统上的开发者协同工作\n有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 优点 ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限 缺点 ： 中央服务器的单点故障，只有单独快照 分布式版本控制\n客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来 git基础\nGit 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容 计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 执行的 Git 操作，几乎只往 Git 数据库中增加数据 三种状态 已提交表示数据已经安全的保存在本地数据库中 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此 三个工作区 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方(github) 工作目录是对项目的某个版本独立提取出来的内容(本地仓库) 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作索引 基本Git工作流程 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 Git基础 获取Git仓库\n在现有目录中初始化仓库 git init\n在已经存在 文件 的文件夹中初始化\n$ git add *.c $ git commit -m 'initial project version' 克隆现有仓库\ngit clone [url] 记录每次更新到仓库\n工作目录下的每一个文件都不外乎这两种状态：已跟踪(git add)or未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆(git clone)某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态\n检查当前文件状态 git status\n目录干净 ：所有已跟踪文件在上次提交后都未被更改过 在 Untracked files 下面： 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件 在 Changes to be committed 这行下面 : 是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中 在 Changes not staged for commit 这行下 ： 已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 git add 命令 跟踪新文件 git add newfile\ngit add理解 ：添加内容到下一次提交中 忽略文件 ：总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表\n创建一个名为 .gitignore 的文件，列出要忽略的文件模式 这个可以需要时学习，Tip : https://github.com/github/gitignore 查看已暂存和未暂存的修改 git diff\ngit diff : 修改之后还没有暂存起来的变化内容 git diff --cached : 查看已暂存的将要添加到下次提交里的内容 提交更新\n都已暂存起来了， 然后再运行提交命令 git commit 跳过使用暂存区域\n给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤\n$ git commit -a -m 'added new benchmarks' 移除文件 手工删除 ： 运行 git status 会在 Changes not staged for commit 部分 git rm命令 ： 从已跟踪文件清单中移除，并从工作目录中删除指定的文件，就不会出现在未跟踪文件清单中\n也可以使用 glob 模式 强制删除 ： git rm -f file 使用 --cached 选项：把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中 移动文件 : 不显示跟踪文件移动操作 重命名 ：$ git mv file_from file_to\n查看提交历史 git log ：会按提交时间列出所有的更新，最近的更新排在最上面\n作者指的是实际作出修改的人 提交者指的是最后将此工作成果提交到仓库的人 常用的选项是 -p，用来显示每次提交的内容差异。 也可以加上 -2 来仅显示最近两次提交\n其他常见参数，具体学习 查看提交历史 · Pro Git 第二版 简体中文\n撤销操作 提交信息写错，可以运行带有 --amend 选项的提交命令尝试重新提交\n$ git commit -m 'initial commit' $ git add forgotten_file $ git commit --amend 取消暂存区文件,将暂存区文件变为暂存状态\ngit reset HEAD ... eg: $ git reset HEAD CONTRIBUTING.md 取消本次修改，还原成上次提交样子\nuse \"git checkout -- ...\" to discard changes in working directory eg :$ git checkout -- CONTRIBUTING.md 远程仓库的使用 ","wordCount":"307","inLanguage":"en","datePublished":"2025-01-05T15:03:12+08:00","dateModified":"2025-01-05T15:03:12+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/git00/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Git00</h1></header><div class=post-content><h2 id=git学习>git学习<a hidden class=anchor aria-hidden=true href=#git学习>#</a></h2><p><strong>安装及配置</strong> ：<a href=https://bingohuang.gitbooks.io/progit2/content/01-introduction/sections/installing.html>Git · Pro Git 第二版 简体中文</a></p><h4 id=起步>起步<a hidden class=anchor aria-hidden=true href=#起步>#</a></h4><ul><li><p><strong>版本控制</strong> ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统</p></li><li><p><strong>本地版本控制</strong></p><ul><li>eg : <strong>RCS</strong>工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</li></ul></li><li><p><strong>集中版本控制</strong> : 不同系统上的开发者协同工作</p><ul><li>有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新</li><li><strong>优点</strong> ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限</li><li><strong>缺点</strong> ： 中央服务器的单点故障，只有单独快照</li></ul></li><li><p><strong>分布式版本控制</strong></p><ul><li>客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来</li></ul></li><li><p><strong>git基础</strong></p><ul><li>Git 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong></li><li>Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息</li><li>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容<ul><li>计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来</li><li>实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名</li></ul></li><li>执行的 Git 操作，几乎只往 Git 数据库中增加数据</li><li><strong>三种状态</strong><ul><li><strong>已提交</strong>表示数据已经安全的保存在本地数据库中</li><li><strong>已修改</strong>表示修改了文件，但还没保存到数据库中</li><li><strong>已暂存</strong>表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li></ul></li><li>由此 <strong>三个工作区</strong><ul><li><strong>Git 仓库</strong>目录是 Git 用来保存项目的元数据和对象数据库的地方(<strong>github</strong>)</li><li><strong>工作目录</strong>是对项目的某个版本独立提取出来的内容(<strong>本地仓库</strong>)</li><li><strong>暂存区域</strong>是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作<strong>索引</strong></li></ul></li><li>基本Git工作流程<ul><li>在工作目录中修改文件</li><li>暂存文件，将文件的快照放入暂存区域</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录</li></ul></li></ul></li></ul><h3 id=git基础>Git基础<a hidden class=anchor aria-hidden=true href=#git基础>#</a></h3><ul><li><p><strong>获取Git仓库</strong></p><ul><li><p>在现有目录中初始化仓库 <code>git init</code></p><ul><li><p>在已经存在 <strong>文件</strong> 的文件夹中初始化</p><ul><li><pre tabindex=0><code class=language-git data-lang=git>$ git add *.c
$ git commit -m &#39;initial project version&#39;
</code></pre></li></ul></li></ul></li><li><p>克隆现有仓库</p><ul><li><code>git clone [url]</code></li></ul></li></ul></li><li><p><strong>记录每次更新到仓库</strong></p><p>工作目录下的每一个文件都不外乎这两种状态：<strong>已跟踪</strong>(<strong>git add</strong>)or<strong>未跟踪</strong>。
<strong>已跟踪的文件</strong>是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。
工作目录中除已跟踪文件以外的所有其它文件都属于<strong>未跟踪文件</strong>，它们既不存在于上次快照的记录中，也没有放入暂存区。
初次克隆(<strong>git clone</strong>)某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态</p><ul><li><p><strong>检查当前文件状态</strong> <code>git status</code></p><ul><li>目录干净 ：所有已跟踪文件在上次提交后都未被更改过</li><li>在 <code>Untracked files</code> 下面： 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件</li><li>在 <code>Changes to be committed</code> 这行下面 : 是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中</li><li>在 <code>Changes not staged for commit</code> 这行下 ： 已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令</li></ul></li><li><p><strong>跟踪新文件</strong> <code>git add newfile</code></p><ul><li><code>git add</code>理解 ：<strong>添加内容到下一次提交中</strong></li></ul></li><li><p><strong>忽略文件</strong> ：总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表</p><ul><li>创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式</li><li>这个可以需要时学习，<strong>Tip</strong> : <a href=https://github.com/github/gitignore>https://github.com/github/gitignore</a></li></ul></li><li><p><strong>查看已暂存和未暂存的修改</strong> <code>git diff</code></p><ul><li><code>git diff</code> : 修改之后还没有暂存起来的变化内容</li><li><code>git diff --cached</code> : 查看已暂存的将要添加到下次提交里的内容</li></ul></li><li><p><strong>提交更新</strong></p><ul><li>都已暂存起来了， 然后再运行提交命令 <code>git commit</code></li></ul></li><li><p><strong>跳过使用暂存区域</strong></p><ul><li><p>给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git commit -a -m <span style=color:#e6db74>&#39;added new benchmarks&#39;</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>移除文件</strong>
手工删除 ： 运行 <code>git status</code> 会在 <code>Changes not staged for commit</code> 部分
<code>git rm</code>命令 ： 从已跟踪文件清单中移除，并从工作目录中删除指定的文件，就不会出现在未跟踪文件清单中</p><ul><li>也可以使用 <code>glob</code> 模式</li><li>强制删除 ： <code>git rm -f file</code></li><li>使用 <code>--cached</code> 选项：把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中</li></ul></li><li><p><strong>移动文件</strong> : 不显示跟踪文件移动操作
<strong>重命名</strong> ：<code>$ git mv file_from file_to</code></p></li></ul></li><li><h4 id=查看提交历史>查看提交历史<a hidden class=anchor aria-hidden=true href=#查看提交历史>#</a></h4><ul><li><p><strong>git log</strong> ：会按提交时间列出所有的更新，最近的更新排在最上面</p><p><strong>作者</strong>指的是实际作出修改的人
<strong>提交者</strong>指的是最后将此工作成果提交到仓库的人
常用的选项是 <code>-p</code>，用来显示每次提交的内容差异。
也可以加上 <code>-2</code> 来仅显示最近两次提交</p></li><li><p>其他常见参数，具体学习 <a href=https://bingohuang.gitbooks.io/progit2/content/02-git-basics/sections/viewing-history.html>查看提交历史 · Pro Git 第二版 简体中文</a></p></li></ul></li><li><h4 id=撤销操作><strong>撤销操作</strong><a hidden class=anchor aria-hidden=true href=#撤销操作>#</a></h4><ul><li><p>提交信息写错，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ git commit -m <span style=color:#e6db74>&#39;initial commit&#39;</span>
</span></span><span style=display:flex><span>$ git add forgotten_file
</span></span><span style=display:flex><span>$ git commit --amend
</span></span></code></pre></div></li></ul></li><li><p>取消暂存区文件,将暂存区文件变为暂存状态</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>git reset HEAD &lt;file&gt;...
</span></span><span style=display:flex><span>eg: $ git reset HEAD CONTRIBUTING.md
</span></span></code></pre></div></li></ul></li><li><p>取消本次修改，还原成上次提交样子</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>use &#34;git checkout -- &lt;file&gt;...&#34; to discard changes in working directory
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>eg :$ git checkout -- CONTRIBUTING.md
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=远程仓库的使用>远程仓库的使用<a hidden class=anchor aria-hidden=true href=#远程仓库的使用>#</a></h4><ul><li></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/linux01/><span class=title>« Prev Page</span><br><span>Linux01(命令)</span>
</a><a class=next href=https://zwlzls.github.io/posts/linux00/><span class=title>Next Page »</span><br><span>Linux00</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>