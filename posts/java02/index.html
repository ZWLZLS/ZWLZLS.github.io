<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java高级 | 我的博客</title>
<meta name=keywords content="Java"><meta name=description content='异常处理 Java的异常 调用方获取调用失败的信息
约定返回错误码
处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码：
int code = processFile("C:\\test.txt"); if (code == 0) { // ok: } else { // error: switch (code) { case 1: // file not found: case 2: // no read permission: default: // unknown error: } } 语言层面上提供一个异常处理机制、
try { String s = processFile(“C:\\test.txt”); // ok: } catch (FileNotFoundException e) { // file not found: } catch (SecurityException e) { // no read permission: } catch (IOException e) { // io error: } catch (Exception e) { // other error: } 异常是class，它的继承关系如下：'><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/java02/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/java02/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Java高级"><meta property="og:description" content='异常处理 Java的异常 调用方获取调用失败的信息
约定返回错误码
处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码：
int code = processFile("C:\\test.txt"); if (code == 0) { // ok: } else { // error: switch (code) { case 1: // file not found: case 2: // no read permission: default: // unknown error: } } 语言层面上提供一个异常处理机制、
try { String s = processFile(“C:\\test.txt”); // ok: } catch (FileNotFoundException e) { // file not found: } catch (SecurityException e) { // no read permission: } catch (IOException e) { // io error: } catch (Exception e) { // other error: } 异常是class，它的继承关系如下：'><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/java02/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-22T22:06:01+08:00"><meta property="article:modified_time" content="2025-01-22T22:06:01+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java高级"><meta name=twitter:description content='异常处理 Java的异常 调用方获取调用失败的信息
约定返回错误码
处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码：
int code = processFile("C:\\test.txt"); if (code == 0) { // ok: } else { // error: switch (code) { case 1: // file not found: case 2: // no read permission: default: // unknown error: } } 语言层面上提供一个异常处理机制、
try { String s = processFile(“C:\\test.txt”); // ok: } catch (FileNotFoundException e) { // file not found: } catch (SecurityException e) { // no read permission: } catch (IOException e) { // io error: } catch (Exception e) { // other error: } 异常是class，它的继承关系如下：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Java高级","item":"https://zwlzls.github.io/posts/java02/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java高级","name":"Java高级","description":"异常处理 Java的异常 调用方获取调用失败的信息\n约定返回错误码\n处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码：\nint code = processFile(\u0026#34;C:\\\\test.txt\u0026#34;); if (code == 0) { // ok: } else { // error: switch (code) { case 1: // file not found: case 2: // no read permission: default: // unknown error: } } 语言层面上提供一个异常处理机制、\ntry { String s = processFile(“C:\\\\test.txt”); // ok: } catch (FileNotFoundException e) { // file not found: } catch (SecurityException e) { // no read permission: } catch (IOException e) { // io error: } catch (Exception e) { // other error: } 异常是class，它的继承关系如下：","keywords":["Java"],"articleBody":"异常处理 Java的异常 调用方获取调用失败的信息\n约定返回错误码\n处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码：\nint code = processFile(\"C:\\\\test.txt\"); if (code == 0) { // ok: } else { // error: switch (code) { case 1: // file not found: case 2: // no read permission: default: // unknown error: } } 语言层面上提供一个异常处理机制、\ntry { String s = processFile(“C:\\\\test.txt”); // ok: } catch (FileNotFoundException e) { // file not found: } catch (SecurityException e) { // no read permission: } catch (IOException e) { // io error: } catch (Exception e) { // other error: } 异常是class，它的继承关系如下：\n┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Throwable │ └───────────┘ ▲ ┌─────────┴─────────┐ │ │ ┌───────────┐ ┌───────────┐ │ Error │ │ Exception │ └───────────┘ └───────────┘ ▲ ▲ ┌───────┘ ┌────┴──────────┐ │ │ │ ┌─────────────────┐ ┌─────────────────┐┌───────────┐ │OutOfMemoryError │... │RuntimeException ││IOException│... └─────────────────┘ └─────────────────┘└───────────┘ ▲ ┌───────────┴─────────────┐ │ │ ┌─────────────────────┐ ┌─────────────────────────┐ │NullPointerException │ │IllegalArgumentException │... └─────────────────────┘ └─────────────────────────┘ Throwable有两个体系：\nError表示严重的错误，程序对此一般无能为力，例如：\nOutOfMemoryError：内存耗尽\nNoClassDefFoundError：无法加载某个Class\nStackOverflowError：栈溢出\nException则是运行时的错误，它可以被捕获并处理\n某些异常是应用程序逻辑处理的一部分，应该捕获并处理：NumberFormatException：数值类型的格式错误\nFileNotFoundException：未找到文件 SocketException：读取网络失败 还有一些异常是程序逻辑编写不对造成的，应该修复程序本身：\nNullPointerException：对某个null的对象调用方法或字段 IndexOutOfBoundsException：数组索引越界 Java规定：\n必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception 不需要捕获的异常，包括Error及其子类，RuntimeException及其子类 捕获异常\n捕获异常使用try...catch语句\n// try...catch import java.io.UnsupportedEncodingException; import java.util.Arrays; public class Main { public static void main(String[] args) { byte[] bs = toGBK(\"中文\"); System.out.println(Arrays.toString(bs)); } static byte[] toGBK(String s) { try { // 用指定编码转换String为byte[]: return s.getBytes(\"GBK\"); } catch (UnsupportedEncodingException e) { // 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException: System.out.println(e); // 打印异常信息 return s.getBytes(); // 尝试使用默认编码 } } } 只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获\nimport java.io.UnsupportedEncodingException; import java.util.Arrays; public class Main { public static void main(String[] args) { byte[] bs = toGBK(\"中文\"); System.out.println(Arrays.toString(bs)); } static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); } } 上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用return s.getBytes(\"GBK\");的问题，而是byte[] bs = toGBK(\"中文\");\n// try...catch import java.io.UnsupportedEncodingException; import java.util.Arrays; public class Main { public static void main(String[] args) { byte[] bs = toGBK(\"中文\"); System.out.println(Arrays.toString(bs)); } static byte[] toGBK(String s) { return s.getBytes(\"GBK\"); } } 以上代码，编译器会报错\n以下修复方法是在main()方法中捕获异常并处理：\n// try...catch import java.io.UnsupportedEncodingException; import java.util.Arrays; public class Main { public static void main(String[] args) { try { byte[] bs = toGBK(\"中文\"); System.out.println(Arrays.toString(bs)); } catch (UnsupportedEncodingException e) { System.out.println(e); } } static byte[] toGBK(String s) throws UnsupportedEncodingException { // 用指定编码转换String为byte[]: return s.getBytes(\"GBK\"); } } 因为String.getBytes(String)方法定义是：\npublic byte[] getBytes(String charsetName) throws UnsupportedEncodingException { ... } 在方法定义的时候，使用throws Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错\n上面的写法就略显麻烦。如果不想写任何try代码，可以直接把main()方法定义为throws Exception：\n// try...catch import java.io.UnsupportedEncodingException; import java.util.Arrays; public class Main { public static void main(String[] args) throws Exception { byte[] bs = toGBK(\"中文\"); System.out.println(Arrays.toString(bs)); } static byte[] toGBK(String s) throws UnsupportedEncodingException { // 用指定编码转换String为byte[]: return s.getBytes(\"GBK\"); } 捕获异常 Java中，凡是可能抛出异常的语句，都可以用try ... catch捕获\n多catch语句\n多个catch语句只有一个能被执行。例如：\npublic static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException e) { System.out.println(e); } catch (NumberFormatException e) { System.out.println(e); } } 存在多个catch的时候，catch的顺序非常重要：子类必须写在前面\npublic static void main(String[] args) { try { process1(); process2(); process3(); } catch (UnsupportedEncodingException e) { System.out.println(\"Bad encoding\"); } catch (IOException e) { System.out.println(\"IO error\"); } } finally语句\nfinally语句不是必须的，可写可不写； finally总是最后执行。 如果没有发生异常，就正常执行try { ... }语句块，然后执行finally。如果发生了异常，就中断执行try { ... }语句块，然后跳转执行匹配的catch语句块，最后执行finally。\n可见，finally是用来保证一些代码必须执行的\n捕获多种异常\n处理IOException和NumberFormatException的代码是相同的，所以我们可以把它两用|合并到一起：\npublic static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException | NumberFormatException e) { // IOException或NumberFormatException System.out.println(\"Bad input\"); } catch (Exception e) { System.out.println(\"Unknown error\"); } } 抛出异常 异常的传播\n// exception public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { process2(); } static void process2() { Integer.parseInt(null); // 会抛出NumberFormatException } } java.lang.NumberFormatException: null at java.base/java.lang.Integer.parseInt(Integer.java:614) at java.base/java.lang.Integer.parseInt(Integer.java:770) at Main.process2(Main.java:16) at Main.process1(Main.java:12) at Main.main(Main.java:5) printStackTrace()对于调试错误非常有用，上述信息表示：NumberFormatException是在java.lang.Integer.parseInt方法中被抛出的，从下往上看，调用层次依次是：\nmain()调用process1()； process1()调用process2()； process2()调用Integer.parseInt(String)； Integer.parseInt(String)调用Integer.parseInt(String, int)。 查看Integer.java源码可知，抛出异常的方法代码如下：\npublic static int parseInt(String s, int radix) throws NumberFormatException { if (s == null) { throw new NumberFormatException(\"null\"); } ... } 抛出异常\n抛出异常分两步：\n创建某个Exception的实例； 用throw语句抛出。 举例子\nvoid process2(String s) { if (s==null) { throw new NullPointerException(); } } 如果一个方法捕获了某个异常后，又在catch子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：\n// exception public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(); } } static void process2() { throw new NullPointerException(); } } java.lang.IllegalArgumentException at Main.process1(Main.java:15) at Main.main(Main.java:5) 这说明新的异常丢失了原始异常信息，我们已经看不到原始异常NullPointerException的信息了\n为了能追踪到完整的异常栈，在构造异常的时候，把原始的Exception实例传进去\n// exception public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(e); } } static void process2() { throw new NullPointerException(); } } java.lang.IllegalArgumentException: java.lang.NullPointerException at Main.process1(Main.java:15) at Main.main(Main.java:5) Caused by: java.lang.NullPointerException at Main.process2(Main.java:20) at Main.process1(Main.java:13) 异常屏蔽\n定义：说明finally抛出异常后，原来在catch中准备抛出的异常就“消失”了，因为只能抛出一个异常\n// exception public class Main { public static void main(String[] args) { try { Integer.parseInt(\"abc\"); } catch (Exception e) { System.out.println(\"catched\"); throw new RuntimeException(e); } finally { System.out.println(\"finally\"); throw new IllegalArgumentException(); } } } catched finally Exception in thread \"main\" java.lang.IllegalArgumentException at Main.main(Main.java:11) 在极少数的情况下，我们需要获知所有的异常\n方法是先用origin变量保存原始异常，然后调用Throwable.addSuppressed()，把原始异常添加进来，最后在finally抛出：\n// exception public class Main { public static void main(String[] args) throws Exception { Exception origin = null; try { System.out.println(Integer.parseInt(\"abc\")); } catch (Exception e) { origin = e; throw e; } finally { Exception e = new IllegalArgumentException(); if (origin != null) { e.addSuppressed(origin); } throw e; } } } 当catch和finally都抛出了异常时，虽然catch的异常被屏蔽了，但是，finally抛出的异常仍然包含了它：\nException in thread \"main\" java.lang.IllegalArgumentException at Main.main(Main.java:11) Suppressed: java.lang.NumberFormatException: For input string: \"abc\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) at Main.main(Main.java:6) 绝大多数情况下，在finally中不要抛出异常。因此，我们通常不需要关心Suppressed Exception\n自定义异常 Java标准库定义的常用异常包括：\nException ├─ RuntimeException │ ├─ NullPointerException │ ├─ IndexOutOfBoundsException │ ├─ SecurityException │ └─ IllegalArgumentException │ └─ NumberFormatException ├─ IOException │ ├─ UnsupportedCharsetException │ ├─ FileNotFoundException │ └─ SocketException ├─ ParseException ├─ GeneralSecurityException ├─ SQLException └─ TimeoutException 自定义的BaseException应该提供多个构造方法：\npublic class BaseException extends RuntimeException { public BaseException() { super(); } public BaseException(String message, Throwable cause) { super(message, cause); } public BaseException(String message) { super(message); } public BaseException(Throwable cause) { super(cause); } } 上述构造方法实际上都是原样照抄RuntimeException。这样，抛出异常的时候，就可以选择合适的构造方法\nNullPointerException\nNullPointerException即空指针异常，如果一个对象为null，调用其方法或访问其字段就会产生NullPointerException，这个异常通常是由JVM抛出的\npublic class Main { public static void main(String[] args) { String s = null; System.out.println(s.toLowerCase()); } } 处理NullPointerException\nNullPointerException是一种代码逻辑错误，遇到NullPointerException，遵循原则是早暴露，早修复，严禁使用catch来隐藏这种编码错误：\n// 错误示例: 捕获NullPointerException try { transferMoney(from, to, amount); } catch (NullPointerException e) { } 使用空字符串\"\"而不是默认的null可避免很多NullPointerException，编写业务逻辑时，用空字符串\"\"表示未填写比null安全得多。\n返回空字符串\"\"、空数组而不是null：\npublic String[] readLinesFromFile(String file) { if (getFileSize(file) == 0) { // 返回空数组而不是null: return new String[0]; } ... } 使用断言(Assertion) 断言（Assertion）是一种调试程序的方式\n看一个例子：\npublic static void main(String[] args) { double x = Math.abs(-123.45); assert x \u003e= 0; System.out.println(x); } 语句assert x \u003e= 0;即为断言，断言条件x \u003e= 0预期为true。如果计算结果为false，则断言失败，抛出AssertionError\n还可以添加一个可选的断言消息：\nassert x \u003e= 0 : \"x must \u003e= 0\"; 这样，断言失败的时候，AssertionError会带上消息x must \u003e= 0\n对于可恢复的程序错误，不应该使用断言。例如：\nvoid sort(int[] arr) { assert arr != null; } 应该抛出异常并在上层捕获：\nvoid sort(int[] arr) { if (arr == null) { throw new IllegalArgumentException(\"array cannot be null\"); } } 要执行assert语句，必须给Java虚拟机传递-enableassertions（可简写为-ea）参数启用断言。\n$ java -ea Main.java Exception in thread \"main\" java.lang.AssertionError at Main.main(Main.java:5) 使用JDK Logging 在编写程序的过程中，发现程序运行结果与预期不符，怎么办？\n用System.out.println()打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码 但太麻烦，最好解决方法是使用日志 日志的好处\n日志就是Logging，它的目的是为了取代System.out.println() 输出日志，而不是用System.out.println()，有以下几个好处： 可以设置输出样式，避免自己每次都写\"ERROR: \" + var； 可以设置输出级别，禁止某些级别输出。例如，只输出错误日志； 可以被重定向到文件，这样可以在程序运行结束后查看日志； 可以按包名控制日志级别，只输出某些包打的日志； 使用日志\nJava标准库内置了日志包java.util.logging，我们可以直接用\n// logging import java.util.logging.Level; import java.util.logging.Logger; public class Hello { public static void main(String[] args) { Logger logger = Logger.getGlobal(); logger.info(\"start process...\"); logger.warning(\"memory is running out...\"); logger.fine(\"ignored.\"); logger.severe(\"process will be terminated...\"); } } Mar 02, 2019 6:32:13 PM Hello main INFO: start process... Mar 02, 2019 6:32:13 PM Hello main WARNING: memory is running out... Mar 02, 2019 6:32:13 PM Hello main SEVERE: process will be terminated... logger.fine()没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从严重到普通：\nSEVERE WARNING INFO CONFIG FINE FINER FINEST 因为默认级别是INFO，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。\n使用Commons Logging Commons Logging是一个第三方日志库，它是由Apache创建的日志模块\n使用Commons Logging\n第一步，通过LogFactory获取Log类的实例\n第二步，使用Log实例的方法打日志\nimport org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; public class Main { public static void main(String[] args) { Log log = LogFactory.getLog(Main.class); log.info(\"start...\"); log.warn(\"end.\"); } } 运行上述代码，肯定会得到编译错误\nApache Commons Logging – Download Apache Commons Logging下载下来，\n找到commons-logging-1.2.jar这个文件，再把Java源码Main.java放到一个目录下，例如work目录：\nwork ├─ commons-logging-1.2.jar └─ Main.java 用javac编译Main.java，编译的时候要指定classpath\njavac -cp commons-logging-1.2.jar Main.java 编译成功，当前目录下就会多出一个Main.class文件\nwork ├─ commons-logging-1.2.jar ├─ Main.java └─ Main.class 现在可以执行这个Main.class，使用java命令，也必须指定classpath\njava -cp .;commons-logging-1.2.jar Main 注意到传入的classpath有两部分：一个是.，一个是commons-logging-1.2.jar，用;分割。.表示当前目录，如果没有这个.，JVM不会在当前目录搜索Main.class，就会报错\n使用Log4j Log4j是一种非常流行的日志框架，最新版本是2.x。\nLog4j是一个组件化设计的日志系统，它的架构大致如下：\nlog.info(\"User signed in.\"); │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──▶│ Appender │───▶│ Filter │───▶│ Layout │───▶│ Console │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──▶│ Appender │───▶│ Filter │───▶│ Layout │───▶│ File │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ └──▶│ Appender │───▶│ Filter │───▶│ Layout │───▶│ Socket │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ 使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。\nconsole：输出到屏幕；\nfile：输出到文件；\nsocket：通过网络输出到远程计算机；\n以XML配置为例，使用Log4j的时候，我们把一个log4j2.xml的文件放到classpath下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ","wordCount":"4067","inLanguage":"en","datePublished":"2025-01-22T22:06:01+08:00","dateModified":"2025-01-22T22:06:01+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/java02/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Java高级</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86 aria-label=异常处理>异常处理</a><ul><li><a href=#java%e7%9a%84%e5%bc%82%e5%b8%b8 aria-label=Java的异常>Java的异常</a></li><li><a href=#%e6%8d%95%e8%8e%b7%e5%bc%82%e5%b8%b8 aria-label=捕获异常>捕获异常</a></li><li><a href=#%e6%8a%9b%e5%87%ba%e5%bc%82%e5%b8%b8 aria-label=抛出异常>抛出异常</a></li><li><a href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e5%bc%82%e5%b8%b8 aria-label=自定义异常>自定义异常</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e6%96%ad%e8%a8%80assertion aria-label=使用断言(Assertion)>使用断言(Assertion)</a></li><li><a href=#%e4%bd%bf%e7%94%a8jdk-logging aria-label="使用JDK Logging">使用JDK Logging</a></li><li><a href=#%e4%bd%bf%e7%94%a8commons-logging aria-label="使用Commons Logging">使用Commons Logging</a></li><li><a href=#%e4%bd%bf%e7%94%a8log4j aria-label=使用Log4j>使用Log4j</a></li></ul></li><li><a href=#%e5%8f%8d%e5%b0%84reflection aria-label=反射Reflection>反射Reflection</a><ul><li><a href=#class%e7%b1%bb aria-label=Class类><code>Class</code>类</a></li><li><a href=#%e8%ae%bf%e9%97%ae%e5%ad%97%e6%ae%b5 aria-label=访问字段>访问字段</a></li><li><a href=#%e8%b0%83%e7%94%a8%e6%96%b9%e6%b3%95 aria-label=调用方法>调用方法</a></li><li><a href=#%e8%b0%83%e7%94%a8%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95 aria-label=调用构造方法>调用构造方法</a></li><li><a href=#%e8%8e%b7%e5%8f%96%e7%bb%a7%e6%89%bf%e5%85%b3%e7%b3%bb aria-label=获取继承关系>获取继承关系</a></li><li><a href=#%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86dynamic-proxy aria-label="动态代理(Dynamic Proxy)">动态代理(Dynamic Proxy)</a></li></ul></li><li><a href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b aria-label=多线程>多线程</a><ul><li><a href=#%e5%9f%ba%e7%a1%80 aria-label=基础>基础</a></li><li><a href=#%e5%88%9b%e5%bb%ba%e6%96%b0%e7%ba%bf%e7%a8%8b aria-label=创建新线程>创建新线程</a></li><li><a href=#%e7%ba%bf%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81 aria-label=线程的状态>线程的状态</a></li><li><a href=#%e4%b8%ad%e6%96%ad%e7%ba%bf%e7%a8%8b aria-label=中断线程>中断线程</a></li><li><a href=#%e5%ae%88%e6%8a%a4%e7%ba%bf%e7%a8%8b aria-label=守护线程>守护线程</a></li><li><a href=#%e5%90%8c%e6%ad%a5-%e7%90%86%e8%a7%a3 aria-label=同步-理解>同步-理解</a></li><li><a href=#%e5%90%8c%e6%ad%a5-%e5%90%8c%e6%ad%a5%e6%96%b9%e6%b3%95 aria-label=同步-同步方法>同步-同步方法</a></li><li><a href=#%e5%90%8c%e6%ad%a5-%e6%ad%bb%e9%94%81 aria-label=同步-死锁>同步-死锁</a></li><li><a href=#%e5%90%8c%e6%ad%a5-wait%e5%92%8cnotify aria-label=同步-wait和notify>同步-<code>wait</code>和<code>notify</code></a></li><li><a href=#%e5%90%8c%e6%ad%a5-reentrantlock aria-label=同步-ReentrantLock>同步-ReentrantLock</a></li><li><a href=#%e5%90%8c%e6%ad%a5-condition aria-label=同步-Condition>同步-Condition</a></li><li><a href=#%e5%90%8c%e6%ad%a5-readwritelock aria-label=同步-ReadWriteLock>同步-ReadWriteLock</a></li></ul></li></ul></div></details></div><div class=post-content><h3 id=异常处理>异常处理<a hidden class=anchor aria-hidden=true href=#异常处理>#</a></h3><ul><li><h4 id=java的异常>Java的异常<a hidden class=anchor aria-hidden=true href=#java的异常>#</a></h4><ul><li><p><strong>调用方获取调用失败的信息</strong></p><ul><li><p>约定返回错误码</p><p>处理一个文件，如果返回<code>0</code>，表示成功，返回其他整数，表示约定的错误码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> code <span style=color:#f92672>=</span> processFile(<span style=color:#e6db74>&#34;C:\\test.txt&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (code <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ok:</span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// error:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (code) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> 1:
</span></span><span style=display:flex><span>        <span style=color:#75715e>// file not found:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> 2:
</span></span><span style=display:flex><span>        <span style=color:#75715e>// no read permission:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e>// unknown error:</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>语言层面上提供一个异常处理机制、</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    String s <span style=color:#f92672>=</span> processFile(<span style=color:#960050;background-color:#1e0010>“</span>C:<span style=color:#960050;background-color:#1e0010>\\</span>test.<span style=color:#a6e22e>txt</span><span style=color:#960050;background-color:#1e0010>”</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ok:</span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (FileNotFoundException e) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// file not found:</span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (SecurityException e) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// no read permission:</span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// io error:</span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// other error:</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>异常是<code>class</code>，它的继承关系如下：</p><pre tabindex=0><code>                     ┌───────────┐
                     │  Object   │
                     └───────────┘
                           ▲
                           │
                     ┌───────────┐
                     │ Throwable │
                     └───────────┘
                           ▲
                 ┌─────────┴─────────┐
                 │                   │
           ┌───────────┐       ┌───────────┐
           │   Error   │       │ Exception │
           └───────────┘       └───────────┘
                 ▲                   ▲
         ┌───────┘              ┌────┴──────────┐
         │                      │               │
┌─────────────────┐    ┌─────────────────┐┌───────────┐
│OutOfMemoryError │... │RuntimeException ││IOException│...
└─────────────────┘    └─────────────────┘└───────────┘
                                ▲
                    ┌───────────┴─────────────┐
                    │                         │
         ┌─────────────────────┐ ┌─────────────────────────┐
         │NullPointerException │ │IllegalArgumentException │...
         └─────────────────────┘ └─────────────────────────┘
</code></pre><p><code>Throwable</code>有两个体系：</p><ul><li><p><code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p><ul><li><p><code>OutOfMemoryError</code>：内存耗尽</p></li><li><p><code>NoClassDefFoundError</code>：无法加载某个Class</p></li><li><p><code>StackOverflowError</code>：栈溢出</p></li></ul></li><li><p><code>Exception</code>则是运行时的错误，它可以被捕获并处理</p><p><strong>某些异常是应用程序逻辑处理的一部分，应该捕获并处理：</strong><code>NumberFormatException</code>：数值类型的格式错误</p><ul><li><code>FileNotFoundException</code>：未找到文件</li><li><code>SocketException</code>：读取网络失败</li></ul><p><strong>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身：</strong></p><ul><li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li><li><code>IndexOutOfBoundsException</code>：数组索引越界</li></ul></li></ul></li></ul></li><li><p>Java规定：</p><ul><li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception</li><li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类</li></ul></li><li><p>捕获异常</p><ul><li><p>捕获异常使用<code>try...catch</code>语句</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// try...catch</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.UnsupportedEncodingException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Arrays;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bs <span style=color:#f92672>=</span> toGBK(<span style=color:#e6db74>&#34;中文&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Arrays.<span style=color:#a6e22e>toString</span>(bs));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>toGBK</span>(String s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 用指定编码转换String为byte[]:</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> s.<span style=color:#a6e22e>getBytes</span>(<span style=color:#e6db74>&#34;GBK&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (UnsupportedEncodingException e) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(e); <span style=color:#75715e>// 打印异常信息</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> s.<span style=color:#a6e22e>getBytes</span>(); <span style=color:#75715e>// 尝试使用默认编码</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.io.UnsupportedEncodingException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Arrays;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bs <span style=color:#f92672>=</span> toGBK(<span style=color:#e6db74>&#34;中文&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Arrays.<span style=color:#a6e22e>toString</span>(bs));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>toGBK</span>(String s) <span style=color:#66d9ef>throws</span> UnsupportedEncodingException {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> s.<span style=color:#a6e22e>getBytes</span>(<span style=color:#e6db74>&#34;GBK&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用<code>return s.getBytes("GBK");</code>的问题，而是<code>byte[] bs = toGBK("中文");</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// try...catch</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.UnsupportedEncodingException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Arrays;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bs <span style=color:#f92672>=</span> toGBK(<span style=color:#e6db74>&#34;中文&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Arrays.<span style=color:#a6e22e>toString</span>(bs));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>toGBK</span>(String s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> s.<span style=color:#a6e22e>getBytes</span>(<span style=color:#e6db74>&#34;GBK&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上代码，编译器会报错</p><p><strong>以下修复方法是在<code>main()</code>方法中捕获异常并处理：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// try...catch</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.UnsupportedEncodingException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Arrays;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bs <span style=color:#f92672>=</span> toGBK(<span style=color:#e6db74>&#34;中文&#34;</span>);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Arrays.<span style=color:#a6e22e>toString</span>(bs));
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (UnsupportedEncodingException e) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>toGBK</span>(String s) <span style=color:#66d9ef>throws</span> UnsupportedEncodingException {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 用指定编码转换String为byte[]:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> s.<span style=color:#a6e22e>getBytes</span>(<span style=color:#e6db74>&#34;GBK&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为<code>String.getBytes(String)</code>方法定义是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>getBytes</span>(String charsetName) <span style=color:#66d9ef>throws</span> UnsupportedEncodingException {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>在方法定义的时候，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错</strong></p></li></ul></li><li><p>上面的写法就略显麻烦。如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// try...catch</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.UnsupportedEncodingException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Arrays;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bs <span style=color:#f92672>=</span> toGBK(<span style=color:#e6db74>&#34;中文&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Arrays.<span style=color:#a6e22e>toString</span>(bs));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>toGBK</span>(String s) <span style=color:#66d9ef>throws</span> UnsupportedEncodingException {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 用指定编码转换String为byte[]:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> s.<span style=color:#a6e22e>getBytes</span>(<span style=color:#e6db74>&#34;GBK&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div></li></ul></li><li><h4 id=捕获异常>捕获异常<a hidden class=anchor aria-hidden=true href=#捕获异常>#</a></h4><ul><li><p><strong>Java中，凡是可能抛出异常的语句，都可以用<code>try ... catch</code>捕获</strong></p></li><li><p>多<code>catch</code>语句</p><ul><li><p>多个<code>catch</code>语句只有一个能被执行。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        process1();
</span></span><span style=display:flex><span>        process2();
</span></span><span style=display:flex><span>        process3();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(e);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (NumberFormatException e) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>存在多个<code>catch</code>的时候，<code>catch</code>的顺序非常重要：子类必须写在前面</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        process1();
</span></span><span style=display:flex><span>        process2();
</span></span><span style=display:flex><span>        process3();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (UnsupportedEncodingException e) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Bad encoding&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;IO error&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p><code>finally</code>语句</p><ol><li><code>finally</code>语句不是必须的，可写可不写；</li><li><code>finally</code>总是最后执行。</li></ol><p>如果没有发生异常，就正常执行<code>try { ... }</code>语句块，然后执行<code>finally</code>。如果发生了异常，就中断执行<code>try { ... }</code>语句块，然后跳转执行匹配的<code>catch</code>语句块，最后执行<code>finally</code>。</p><p><strong>可见，<code>finally</code>是用来保证一些代码必须执行的</strong></p></li><li><p><strong>捕获多种异常</strong></p><p>处理<code>IOException</code>和<code>NumberFormatException</code>的代码是相同的，所以我们可以把它两用<code>|</code>合并到一起：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        process1();
</span></span><span style=display:flex><span>        process2();
</span></span><span style=display:flex><span>        process3();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (IOException <span style=color:#f92672>|</span> NumberFormatException e) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// IOException或NumberFormatException</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Bad input&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Unknown error&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><h4 id=抛出异常>抛出异常<a hidden class=anchor aria-hidden=true href=#抛出异常>#</a></h4><ul><li><p>异常的传播</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// exception</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            process1();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process1</span>() {
</span></span><span style=display:flex><span>        process2();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process2</span>() {
</span></span><span style=display:flex><span>        Integer.<span style=color:#a6e22e>parseInt</span>(<span style=color:#66d9ef>null</span>); <span style=color:#75715e>// 会抛出NumberFormatException</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>java.<span style=color:#a6e22e>lang</span>.<span style=color:#a6e22e>NumberFormatException</span>: <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>    at java.<span style=color:#a6e22e>base</span><span style=color:#f92672>/</span>java.<span style=color:#a6e22e>lang</span>.<span style=color:#a6e22e>Integer</span>.<span style=color:#a6e22e>parseInt</span>(Integer.<span style=color:#a6e22e>java</span>:614)
</span></span><span style=display:flex><span>    at java.<span style=color:#a6e22e>base</span><span style=color:#f92672>/</span>java.<span style=color:#a6e22e>lang</span>.<span style=color:#a6e22e>Integer</span>.<span style=color:#a6e22e>parseInt</span>(Integer.<span style=color:#a6e22e>java</span>:770)
</span></span><span style=display:flex><span>    at Main.<span style=color:#a6e22e>process2</span>(Main.<span style=color:#a6e22e>java</span>:16)
</span></span><span style=display:flex><span>    at Main.<span style=color:#a6e22e>process1</span>(Main.<span style=color:#a6e22e>java</span>:12)
</span></span><span style=display:flex><span>    at Main.<span style=color:#a6e22e>main</span>(Main.<span style=color:#a6e22e>java</span>:5)
</span></span></code></pre></div><p><code>printStackTrace()</code>对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code>是在<code>java.lang.Integer.parseInt</code>方法中被抛出的，从下往上看，调用层次依次是：</p><ol><li><code>main()</code>调用<code>process1()</code>；</li><li><code>process1()</code>调用<code>process2()</code>；</li><li><code>process2()</code>调用<code>Integer.parseInt(String)</code>；</li><li><code>Integer.parseInt(String)</code>调用<code>Integer.parseInt(String, int)</code>。</li></ol><p>查看<code>Integer.java</code>源码可知，抛出异常的方法代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>parseInt</span>(String s, <span style=color:#66d9ef>int</span> radix) <span style=color:#66d9ef>throws</span> NumberFormatException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NumberFormatException(<span style=color:#e6db74>&#34;null&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>抛出异常</p><ul><li><p>抛出异常分两步：</p><ol><li>创建某个<code>Exception</code>的实例；</li><li>用<code>throw</code>语句抛出。</li></ol></li><li><p>举例子</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process2</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (s<span style=color:#f92672>==</span><span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果一个方法捕获了某个异常后，又在<code>catch</code>子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// exception</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            process1();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process1</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            process2();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (NullPointerException e) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process2</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>java.lang.IllegalArgumentException
</span></span><span style=display:flex><span>    at Main.process1(Main.java:15)
</span></span><span style=display:flex><span>    at Main.main(Main.java:5)
</span></span></code></pre></div><p>这说明新的异常丢失了原始异常信息，我们已经看不到原始异常<code>NullPointerException</code>的信息了</p></li><li><p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的<code>Exception</code>实例传进去</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// exception</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            process1();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process1</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            process2();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (NullPointerException e) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process2</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>java.lang.IllegalArgumentException: java.lang.NullPointerException
</span></span><span style=display:flex><span>    at Main.process1(Main.java:15)
</span></span><span style=display:flex><span>    at Main.main(Main.java:5)
</span></span><span style=display:flex><span>Caused by: java.lang.NullPointerException
</span></span><span style=display:flex><span>    at Main.process2(Main.java:20)
</span></span><span style=display:flex><span>    at Main.process1(Main.java:13)
</span></span></code></pre></div></li></ul></li><li><p>异常屏蔽</p><ul><li><p>定义：<strong>说明<code>finally</code>抛出异常后，原来在<code>catch</code>中准备抛出的异常就“消失”了，因为只能抛出一个异常</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// exception</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            Integer.<span style=color:#a6e22e>parseInt</span>(<span style=color:#e6db74>&#34;abc&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;catched&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;finally&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>catched
</span></span><span style=display:flex><span>finally
</span></span><span style=display:flex><span>Exception in thread &#34;main&#34; java.lang.IllegalArgumentException
</span></span><span style=display:flex><span>    at Main.main(Main.java:11)
</span></span></code></pre></div></li><li><p>在极少数的情况下，我们需要获知所有的异常</p><p>方法是先用<code>origin</code>变量保存原始异常，然后调用<code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在<code>finally</code>抛出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// exception</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        Exception origin <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Integer.<span style=color:#a6e22e>parseInt</span>(<span style=color:#e6db74>&#34;abc&#34;</span>));
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            origin <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> e;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            Exception e <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> IllegalArgumentException();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (origin <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>addSuppressed</span>(origin);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> e;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当<code>catch</code>和<code>finally</code>都抛出了异常时，虽然<code>catch</code>的异常被屏蔽了，但是，<code>finally</code>抛出的异常仍然包含了它：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>Exception in thread &#34;main&#34; java.lang.IllegalArgumentException
</span></span><span style=display:flex><span>    at Main.main(Main.java:11)
</span></span><span style=display:flex><span>Suppressed: java.lang.NumberFormatException: For input string: &#34;abc&#34;
</span></span><span style=display:flex><span>    at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
</span></span><span style=display:flex><span>    at java.base/java.lang.Integer.parseInt(Integer.java:652)
</span></span><span style=display:flex><span>    at java.base/java.lang.Integer.parseInt(Integer.java:770)
</span></span><span style=display:flex><span>    at Main.main(Main.java:6)
</span></span></code></pre></div></li></ul></li><li><p><strong><em>绝大多数情况下，在<code>finally</code>中不要抛出异常。因此，我们通常不需要关心<code>Suppressed Exception</code></em></strong></p></li></ul></li><li><h4 id=自定义异常>自定义异常<a hidden class=anchor aria-hidden=true href=#自定义异常>#</a></h4><ul><li><p>Java标准库定义的常用异常包括：</p><pre tabindex=0><code>Exception
├─ RuntimeException
│  ├─ NullPointerException
│  ├─ IndexOutOfBoundsException
│  ├─ SecurityException
│  └─ IllegalArgumentException
│     └─ NumberFormatException
├─ IOException
│  ├─ UnsupportedCharsetException
│  ├─ FileNotFoundException
│  └─ SocketException
├─ ParseException
├─ GeneralSecurityException
├─ SQLException
└─ TimeoutException
</code></pre></li><li><p>自定义的<code>BaseException</code>应该提供多个构造方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BaseException</span> <span style=color:#66d9ef>extends</span> RuntimeException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>BaseException</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>BaseException</span>(String message, Throwable cause) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(message, cause);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>BaseException</span>(String message) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(message);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>BaseException</span>(Throwable cause) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(cause);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述构造方法实际上都是原样照抄<code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法</p></li></ul></li><li><p><strong><code>NullPointerException</code></strong></p><ul><li><p><code>NullPointerException</code>即空指针异常，如果一个对象为<code>null</code>，调用其方法或访问其字段就会产生<code>NullPointerException</code>，这个异常通常是由JVM抛出的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        String s <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(s.<span style=color:#a6e22e>toLowerCase</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>处理<code>NullPointerException</code></p><p><code>NullPointerException</code>是一种代码逻辑错误，遇到<code>NullPointerException</code>，遵循原则是早暴露，早修复，严禁使用<code>catch</code>来隐藏这种编码错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 错误示例: 捕获NullPointerException</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    transferMoney(from, to, amount);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (NullPointerException e) {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用空字符串<code>""</code>而不是默认的<code>null</code>可避免很多<code>NullPointerException</code>，编写业务逻辑时，用空字符串<code>""</code>表示未填写比<code>null</code>安全得多。</p><p><strong>返回空字符串<code>""</code>、空数组而不是<code>null</code>：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> String<span style=color:#f92672>[]</span> <span style=color:#a6e22e>readLinesFromFile</span>(String file) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (getFileSize(file) <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 返回空数组而不是null:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><h4 id=使用断言assertion>使用断言(Assertion)<a hidden class=anchor aria-hidden=true href=#使用断言assertion>#</a></h4><ul><li><p>断言（Assertion）是一种调试程序的方式</p></li><li><p>看一个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> x <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>abs</span>(<span style=color:#f92672>-</span>123.<span style=color:#a6e22e>45</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> x <span style=color:#f92672>&gt;=</span> 0;
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>语句<code>assert x >= 0;</code>即为断言，断言条件<code>x >= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code></p><p>还可以添加一个可选的断言消息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>assert</span> x <span style=color:#f92672>&gt;=</span> 0 : <span style=color:#e6db74>&#34;x must &gt;= 0&#34;</span>;
</span></span></code></pre></div><p>这样，断言失败的时候，<code>AssertionError</code>会带上消息<code>x must >= 0</code></p></li><li><p><strong>对于可恢复的程序错误</strong>，不应该使用断言。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> arr <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>应该抛出异常并在上层捕获：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (arr <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;array cannot be null&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ java -ea Main.java
</span></span><span style=display:flex><span>Exception in thread &#34;main&#34; java.lang.AssertionError
</span></span><span style=display:flex><span>	at Main.main(Main.java:5)
</span></span></code></pre></div></li></ul></li><li><h4 id=使用jdk-logging>使用JDK Logging<a hidden class=anchor aria-hidden=true href=#使用jdk-logging>#</a></h4><ul><li><p>在编写程序的过程中，发现程序运行结果与预期不符，怎么办？</p><ul><li>用<code>System.out.println()</code>打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码</li><li><strong>但太麻烦，最好解决方法是使用日志</strong></li></ul></li><li><p>日志的好处</p><ul><li>日志就是Logging，它的目的是为了取代<code>System.out.println()</code></li><li>输出日志，而不是用<code>System.out.println()</code>，有以下几个好处：<ol><li>可以设置输出样式，避免自己每次都写<code>"ERROR: " + var</code>；</li><li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li><li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li><li>可以按包名控制日志级别，只输出某些包打的日志；</li></ol></li></ul></li><li><p>使用日志</p><ul><li><p>Java标准库内置了日志包<code>java.util.logging</code>，我们可以直接用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// logging</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.logging.Level;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.logging.Logger;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Logger logger <span style=color:#f92672>=</span> Logger.<span style=color:#a6e22e>getGlobal</span>();
</span></span><span style=display:flex><span>        logger.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;start process...&#34;</span>);
</span></span><span style=display:flex><span>        logger.<span style=color:#a6e22e>warning</span>(<span style=color:#e6db74>&#34;memory is running out...&#34;</span>);
</span></span><span style=display:flex><span>        logger.<span style=color:#a6e22e>fine</span>(<span style=color:#e6db74>&#34;ignored.&#34;</span>);
</span></span><span style=display:flex><span>        logger.<span style=color:#a6e22e>severe</span>(<span style=color:#e6db74>&#34;process will be terminated...&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>Mar 02, 2019 6:32:13 PM Hello main
</span></span><span style=display:flex><span>INFO: start process...
</span></span><span style=display:flex><span>Mar 02, 2019 6:32:13 PM Hello main
</span></span><span style=display:flex><span>WARNING: memory is running out...
</span></span><span style=display:flex><span>Mar 02, 2019 6:32:13 PM Hello main
</span></span><span style=display:flex><span>SEVERE: process will be terminated...
</span></span></code></pre></div></li><li><p><code>logger.fine()</code>没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从严重到普通：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><p>因为默认级别是INFO，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p></li></ul></li></ul></li><li><h4 id=使用commons-logging>使用Commons Logging<a hidden class=anchor aria-hidden=true href=#使用commons-logging>#</a></h4><ul><li><p>Commons Logging是一个第三方日志库，它是由Apache创建的日志模块</p></li><li><p>使用Commons Logging</p><ul><li><p>第一步，通过<code>LogFactory</code>获取<code>Log</code>类的实例</p></li><li><p>第二步，使用<code>Log</code>实例的方法打日志</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.logging.Log;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.logging.LogFactory;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Log log <span style=color:#f92672>=</span> LogFactory.<span style=color:#a6e22e>getLog</span>(Main.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;start...&#34;</span>);
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;end.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>运行上述代码，肯定会得到编译错误</p></li><li><p><a href=https://commons.apache.org/proper/commons-logging/download_logging.cgi>Apache Commons Logging – Download Apache Commons Logging</a>下载下来，</p></li><li><p>找到<code>commons-logging-1.2.jar</code>这个文件，再把Java源码<code>Main.java</code>放到一个目录下，例如<code>work</code>目录：</p><pre tabindex=0><code>work
├─ commons-logging-1.2.jar
└─ Main.java
</code></pre></li><li><p>用<code>javac</code>编译<code>Main.java</code>，编译的时候要指定<code>classpath</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>javac -cp commons-logging-1.2.jar Main.java
</span></span></code></pre></div><p>编译成功，当前目录下就会多出一个<code>Main.class</code>文件</p><pre tabindex=0><code>work
├─ commons-logging-1.2.jar
├─ Main.java
└─ Main.class
</code></pre></li><li><p>现在可以执行这个<code>Main.class</code>，使用<code>java</code>命令，也必须指定<code>classpath</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>java -cp .;commons-logging-1.2.jar Main
</span></span></code></pre></div><p>注意到传入的<code>classpath</code>有两部分：一个是<code>.</code>，一个是<code>commons-logging-1.2.jar</code>，用<code>;</code>分割。<code>.</code>表示当前目录，如果没有这个<code>.</code>，JVM不会在当前目录搜索<code>Main.class</code>，就会报错</p></li></ul></li></ul></li><li><h4 id=使用log4j>使用Log4j<a hidden class=anchor aria-hidden=true href=#使用log4j>#</a></h4><ul><li><p>Log4j是一种非常流行的日志框架，最新版本是2.x。</p><p>Log4j是一个组件化设计的日志系统，它的架构大致如下：</p></li></ul></li></ul><pre tabindex=0><code>log.info(&#34;User signed in.&#34;);
 │
 │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
 ├──▶│ Appender │───▶│  Filter  │───▶│  Layout  │───▶│ Console  │
 │   └──────────┘    └──────────┘    └──────────┘    └──────────┘
 │
 │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
 ├──▶│ Appender │───▶│  Filter  │───▶│  Layout  │───▶│   File   │
 │   └──────────┘    └──────────┘    └──────────┘    └──────────┘
 │
 │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
 └──▶│ Appender │───▶│  Filter  │───▶│  Layout  │───▶│  Socket  │
     └──────────┘    └──────────┘    └──────────┘    └──────────┘
</code></pre><ul><li><p>使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。</p><ul><li><p>console：输出到屏幕；</p></li><li><p>file：输出到文件；</p></li><li><p>socket：通过网络输出到远程计算机；</p><p>以XML配置为例，使用Log4j的时候，我们把一个<code>log4j2.xml</code>的文件放到<code>classpath</code>下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;Configuration&gt;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;Properties&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>&lt;!-- 定义日志格式 --&gt;</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>&lt;Property</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;log.pattern&#34;</span><span style=color:#f92672>&gt;</span>%d{MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36}%n%msg%n%n<span style=color:#f92672>&lt;/Property&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>&lt;!-- 定义文件名变量 --&gt;</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>&lt;Property</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;file.err.filename&#34;</span><span style=color:#f92672>&gt;</span>log/err.log<span style=color:#f92672>&lt;/Property&gt;</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>&lt;Property</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;file.err.pattern&#34;</span><span style=color:#f92672>&gt;</span>log/err.%i.log.gz<span style=color:#f92672>&lt;/Property&gt;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;/Properties&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>&lt;!-- 定义Appender，即目的地 --&gt;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;Appenders&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>&lt;!-- 定义输出到屏幕 --&gt;</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>&lt;Console</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;console&#34;</span> <span style=color:#a6e22e>target=</span><span style=color:#e6db74>&#34;SYSTEM_OUT&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>&lt;PatternLayout</span> <span style=color:#a6e22e>pattern=</span><span style=color:#e6db74>&#34;${log.pattern}&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>&lt;/Console&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>&lt;RollingFile</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;err&#34;</span> <span style=color:#a6e22e>bufferedIO=</span><span style=color:#e6db74>&#34;true&#34;</span> <span style=color:#a6e22e>fileName=</span><span style=color:#e6db74>&#34;${file.err.filename}&#34;</span> <span style=color:#a6e22e>filePattern=</span><span style=color:#e6db74>&#34;${file.err.pattern}&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>&lt;PatternLayout</span> <span style=color:#a6e22e>pattern=</span><span style=color:#e6db74>&#34;${log.pattern}&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>&lt;Policies&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>&lt;!-- 根据文件大小自动切割日志 --&gt;</span>
</span></span><span style=display:flex><span>				<span style=color:#f92672>&lt;SizeBasedTriggeringPolicy</span> <span style=color:#a6e22e>size=</span><span style=color:#e6db74>&#34;1 MB&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>&lt;/Policies&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>&lt;!-- 保留最近10份 --&gt;</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>&lt;DefaultRolloverStrategy</span> <span style=color:#a6e22e>max=</span><span style=color:#e6db74>&#34;10&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>&lt;/RollingFile&gt;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;/Appenders&gt;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;Loggers&gt;</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>&lt;Root</span> <span style=color:#a6e22e>level=</span><span style=color:#e6db74>&#34;info&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>&lt;!-- 对info级别的日志，输出到console --&gt;</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>&lt;AppenderRef</span> <span style=color:#a6e22e>ref=</span><span style=color:#e6db74>&#34;console&#34;</span> <span style=color:#a6e22e>level=</span><span style=color:#e6db74>&#34;info&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>&lt;AppenderRef</span> <span style=color:#a6e22e>ref=</span><span style=color:#e6db74>&#34;err&#34;</span> <span style=color:#a6e22e>level=</span><span style=color:#e6db74>&#34;error&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>&lt;/Root&gt;</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;/Loggers&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/Configuration&gt;</span>
</span></span></code></pre></div></li></ul></li></ul><h3 id=反射reflection>反射Reflection<a hidden class=anchor aria-hidden=true href=#反射reflection>#</a></h3><ul><li><p>Java的反射是指程序在运行期可以拿到一个对象的所有信息</p><ul><li><p>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Main.java</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.itranswarp.learnjava.Person;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>getFullName</span>(Person p) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> p.<span style=color:#a6e22e>getFirstName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> p.<span style=color:#a6e22e>getLastName</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><h4 id=class类><code>Class</code>类<a hidden class=anchor aria-hidden=true href=#class类>#</a></h4><ul><li><p><code>class</code>（包括<code>interface</code>）的本质是数据类型（<code>Type</code>）</p><ul><li>无继承关系的数据类型无法赋值：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Number n <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Double(123.<span style=color:#a6e22e>456</span>); <span style=color:#75715e>// OK</span>
</span></span><span style=display:flex><span>String s <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Double(123.<span style=color:#a6e22e>456</span>); <span style=color:#75715e>// compile error!</span>
</span></span></code></pre></div><p>而<code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存</p><p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。注意：**这里的<code>Class</code>类型是一个名叫<code>Class</code>的<code>class**</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Class</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Class</span>() {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Class cls <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Class(String);
</span></span></code></pre></div><p>这个<code>Class</code>实例是JVM内部创建的，可以发现<code>Class</code>类的构造方法是<code>private</code>，只有JVM能创建<code>Class</code>实例，我们自己的Java程序是无法创建<code>Class</code>实例</p></li><li><p>JVM持有的每个<code>Class</code>实例都指向一个数据类型（<code>class</code>或<code>interface</code>）：</p><pre tabindex=0><code>┌───────────────────────────┐
│      Class Instance       │────▶ String
├───────────────────────────┤
│name = &#34;java.lang.String&#34;  │
└───────────────────────────┘
┌───────────────────────────┐
│      Class Instance       │────▶ Random
├───────────────────────────┤
│name = &#34;java.util.Random&#34;  │
└───────────────────────────┘
┌───────────────────────────┐
│      Class Instance       │────▶ Runnable
├───────────────────────────┤
│name = &#34;java.lang.Runnable&#34;│
└───────────────────────────┘
</code></pre><p>一个<code>Class</code>实例包含了该<code>class</code>的所有完整信息：</p><pre tabindex=0><code>┌───────────────────────────┐
│      Class Instance       │────▶ String
├───────────────────────────┤
│name = &#34;java.lang.String&#34;  │
├───────────────────────────┤
│package = &#34;java.lang&#34;      │
├───────────────────────────┤
│super = &#34;java.lang.Object&#34; │
├───────────────────────────┤
│interface = CharSequence...│
├───────────────────────────┤
│field = value[],hash,...   │
├───────────────────────────┤
│method = indexOf()...      │
└───────────────────────────┘
</code></pre><p><strong>通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）</strong></p></li><li><p>获取一个<code>class</code>的<code>Class</code>实例？</p><ul><li><p>直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Class cls <span style=color:#f92672>=</span> String.<span style=color:#a6e22e>class</span>;
</span></span></code></pre></div></li><li><p>如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello&#34;</span>;
</span></span><span style=display:flex><span>Class cls <span style=color:#f92672>=</span> s.<span style=color:#a6e22e>getClass</span>();
</span></span></code></pre></div></li><li><p>如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Class cls <span style=color:#f92672>=</span> Class.<span style=color:#a6e22e>forName</span>(<span style=color:#e6db74>&#34;java.lang.String&#34;</span>);
</span></span></code></pre></div></li></ul></li><li><p><strong><code>Class</code>实例在JVM中是唯一的，上述方法获取的<code>Class</code>实例是同一个实例</strong></p></li><li><p>注意到数组（例如<code>String[]</code>）也是一种类，而且不同于<code>String.class</code>，它的类名是<code>[Ljava.lang.String;</code></p></li><li><p>获取到了一个<code>Class</code>实例，我们就可以通过该<code>Class</code>实例来创建对应类型的实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 获取String的Class实例:</span>
</span></span><span style=display:flex><span>Class cls <span style=color:#f92672>=</span> String.<span style=color:#a6e22e>class</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// 创建一个String实例:</span>
</span></span><span style=display:flex><span>String s <span style=color:#f92672>=</span> (String) cls.<span style=color:#a6e22e>newInstance</span>();
</span></span></code></pre></div><p>上述代码相当于<code>new String()</code></p><p><strong>局限是：只能调用<code>public</code>的无参数构造方法</strong></p></li><li><p>动态加载</p><p>JVM在执行Java程序的时候，不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (args.<span style=color:#a6e22e>length</span> <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>            create(args<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>create</span>(String name) {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当执行<code>Main.java</code>时，由于用到了<code>Main</code>，因此，JVM首先会把<code>Main.class</code>加载到内存。然而，并不会加载<code>Person.class</code>，除非程序执行到<code>create()</code>方法，JVM发现需要加载<code>Person</code>类时，才会首次加载<code>Person.class</code></p></li><li><p><strong>动态加载举例</strong></p><p>动态加载<code>class</code>的特性对于Java程序非常重要。利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Commons Logging优先使用Log4j:</span>
</span></span><span style=display:flex><span>LogFactory factory <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (isClassPresent(<span style=color:#e6db74>&#34;org.apache.logging.log4j.Logger&#34;</span>)) {
</span></span><span style=display:flex><span>    factory <span style=color:#f92672>=</span> createLog4j();
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    factory <span style=color:#f92672>=</span> createJdkLog();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isClassPresent</span>(String name) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        Class.<span style=color:#a6e22e>forName</span>(name);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><h4 id=访问字段>访问字段<a hidden class=anchor aria-hidden=true href=#访问字段>#</a></h4><ul><li><p>对任意的一个<code>Object</code>实例，只要我们获取了它的<code>Class</code>，就可以获取它的一切信息</p></li><li><p><code>Class</code>类提供了以下几个方法来获取字段：</p><ul><li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field(不包括父类）</li><li>Field[] getFields()：获取所有public的field（包括父类）</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// reflection</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        Class stdClass <span style=color:#f92672>=</span> Student.<span style=color:#a6e22e>class</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取public字段&#34;score&#34;:</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(stdClass.<span style=color:#a6e22e>getField</span>(<span style=color:#e6db74>&#34;score&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取继承的public字段&#34;name&#34;:</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(stdClass.<span style=color:#a6e22e>getField</span>(<span style=color:#e6db74>&#34;name&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取private字段&#34;grade&#34;:</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(stdClass.<span style=color:#a6e22e>getDeclaredField</span>(<span style=color:#e6db74>&#34;grade&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> score;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> grade;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String name;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>public int Student.score
</span></span><span style=display:flex><span>public java.lang.String Person.name
</span></span><span style=display:flex><span>private int Student.grade
</span></span></code></pre></div></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>String</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> value;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Field f <span style=color:#f92672>=</span> String.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getDeclaredField</span>(<span style=color:#e6db74>&#34;value&#34;</span>);
</span></span><span style=display:flex><span>f.<span style=color:#a6e22e>getName</span>(); <span style=color:#75715e>// &#34;value&#34;</span>
</span></span><span style=display:flex><span>f.<span style=color:#a6e22e>getType</span>(); <span style=color:#75715e>// class [B 表示byte[]类型</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> f.<span style=color:#a6e22e>getModifiers</span>();
</span></span><span style=display:flex><span>Modifier.<span style=color:#a6e22e>isFinal</span>(m); <span style=color:#75715e>// true</span>
</span></span><span style=display:flex><span>Modifier.<span style=color:#a6e22e>isPublic</span>(m); <span style=color:#75715e>// false</span>
</span></span><span style=display:flex><span>Modifier.<span style=color:#a6e22e>isProtected</span>(m); <span style=color:#75715e>// false</span>
</span></span><span style=display:flex><span>Modifier.<span style=color:#a6e22e>isPrivate</span>(m); <span style=color:#75715e>// true</span>
</span></span><span style=display:flex><span>Modifier.<span style=color:#a6e22e>isStatic</span>(m); <span style=color:#75715e>// false</span>
</span></span></code></pre></div></li><li><p><strong>获取字段值</strong></p><p>对<code>Person</code>实例，可以先拿<code>name</code>字段对应<code>Field</code>，再获取这实例的<code>name</code>字段值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// reflection</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.reflect.Field;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        Object p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>);
</span></span><span style=display:flex><span>        Class c <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>getClass</span>();
</span></span><span style=display:flex><span>        Field f <span style=color:#f92672>=</span> c.<span style=color:#a6e22e>getDeclaredField</span>(<span style=color:#e6db74>&#34;name&#34;</span>);
</span></span><span style=display:flex><span>        Object value <span style=color:#f92672>=</span> f.<span style=color:#a6e22e>get</span>(p);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(value); <span style=color:#75715e>// &#34;Xiao Ming&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行代码，如果不出意外，会得到一个<code>IllegalAccessException</code>，这是因为<code>name</code>被定义为一个<code>private</code>字段，正常情况下，<code>Main</code>类无法访问<code>Person</code>类的<code>private</code>字段。要修复错误，可以将<code>private</code>改为<code>public</code>，或者，在调用<code>Object value = f.get(p);</code>前，先写一句：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>f.<span style=color:#a6e22e>setAccessible</span>(<span style=color:#66d9ef>true</span>);
</span></span></code></pre></div></li><li><p>设置字段值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.reflect.Field;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getName</span>()); <span style=color:#75715e>// &#34;Xiao Ming&#34;</span>
</span></span><span style=display:flex><span>        Class c <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>getClass</span>();
</span></span><span style=display:flex><span>        Field f <span style=color:#f92672>=</span> c.<span style=color:#a6e22e>getDeclaredField</span>(<span style=color:#e6db74>&#34;name&#34;</span>);
</span></span><span style=display:flex><span>        f.<span style=color:#a6e22e>setAccessible</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        f.<span style=color:#a6e22e>set</span>(p, <span style=color:#e6db74>&#34;Xiao Hong&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getName</span>()); <span style=color:#75715e>// &#34;Xiao Hong&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><h4 id=调用方法>调用方法<a hidden class=anchor aria-hidden=true href=#调用方法>#</a></h4><ul><li><p>已通过<code>Class</code>实例获取所有<code>Field</code>对象，可通过<code>Class</code>实例获取所有<code>Method</code>信息：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// reflection</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        Class stdClass <span style=color:#f92672>=</span> Student.<span style=color:#a6e22e>class</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取public方法getScore，参数为String:</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(stdClass.<span style=color:#a6e22e>getMethod</span>(<span style=color:#e6db74>&#34;getScore&#34;</span>, String.<span style=color:#a6e22e>class</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取继承的public方法getName，无参数:</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(stdClass.<span style=color:#a6e22e>getMethod</span>(<span style=color:#e6db74>&#34;getName&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取private方法getGrade，参数为int:</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(stdClass.<span style=color:#a6e22e>getDeclaredMethod</span>(<span style=color:#e6db74>&#34;getGrade&#34;</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getScore</span>(String type) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> 99;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getGrade</span>(<span style=color:#66d9ef>int</span> year) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> 1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Person&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>public int Student.getScore(java.lang.String)
</span></span><span style=display:flex><span>public java.lang.String Person.getName()
</span></span><span style=display:flex><span>private int Student.getGrade(int)
</span></span></code></pre></div></li><li><p>调用方法</p><ul><li><p>用反射来调用<code>substring</code>方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.reflect.Method;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// String对象:</span>
</span></span><span style=display:flex><span>        String s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello world&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取String substring(int)方法，参数为int:</span>
</span></span><span style=display:flex><span>        Method m <span style=color:#f92672>=</span> String.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getMethod</span>(<span style=color:#e6db74>&#34;substring&#34;</span>, <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在s对象上调用该方法并获取结果:</span>
</span></span><span style=display:flex><span>        String r <span style=color:#f92672>=</span> (String) m.<span style=color:#a6e22e>invoke</span>(s, 6);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 打印调用结果:</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(r); <span style=color:#75715e>// &#34;world&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意到<code>substring()</code>有两个重载方法，我们获取的是<code>String substring(int)</code>这个方法。</p></li></ul></li><li><p>调用静态方法</p><p>如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以<code>invoke</code>方法传入的第一个参数永远为<code>null</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// reflection</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.reflect.Method;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取Integer.parseInt(String)方法，参数为String:</span>
</span></span><span style=display:flex><span>        Method m <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getMethod</span>(<span style=color:#e6db74>&#34;parseInt&#34;</span>, String.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用该静态方法并获取结果:</span>
</span></span><span style=display:flex><span>        Integer n <span style=color:#f92672>=</span> (Integer) m.<span style=color:#a6e22e>invoke</span>(<span style=color:#66d9ef>null</span>, <span style=color:#e6db74>&#34;12345&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 打印调用结果:</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(n);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>调用非<code>public</code>方法</p><p>虽然可以通过<code>Class.getDeclaredMethod()</code>获取该方法实例，但直接对其调用将得到一个<code>IllegalAccessException</code>。为了调用非public方法，我们通过<code>Method.setAccessible(true)</code>允许其调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// reflection</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.reflect.Method;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>        Method m <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>getClass</span>().<span style=color:#a6e22e>getDeclaredMethod</span>(<span style=color:#e6db74>&#34;setName&#34;</span>, String.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>        m.<span style=color:#a6e22e>setAccessible</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        m.<span style=color:#a6e22e>invoke</span>(p, <span style=color:#e6db74>&#34;Bob&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>多态</p><p>一个<code>Person</code>类定义了<code>hello()</code>方法，并且它的子类<code>Student</code>也覆写了<code>hello()</code>方法，那么，从<code>Person.class</code>获取的<code>Method</code>，作用于<code>Student</code>实例时</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>/</span> reflection
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.reflect.Method;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取Person的hello方法:</span>
</span></span><span style=display:flex><span>        Method h <span style=color:#f92672>=</span> Person.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getMethod</span>(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对Student实例调用hello方法:</span>
</span></span><span style=display:flex><span>        h.<span style=color:#a6e22e>invoke</span>(<span style=color:#66d9ef>new</span> Student());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Person:hello&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Student:hello&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行上述代码，发现打印出的是<code>Student:hello</code>，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Method m <span style=color:#f92672>=</span> Person.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getMethod</span>(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>m.<span style=color:#a6e22e>invoke</span>(<span style=color:#66d9ef>new</span> Student());
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student();
</span></span><span style=display:flex><span>p.<span style=color:#a6e22e>hello</span>();
</span></span></code></pre></div></li></ul></li><li><h4 id=调用构造方法>调用构造方法<a hidden class=anchor aria-hidden=true href=#调用构造方法>#</a></h4><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span></code></pre></div><p>通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person p <span style=color:#f92672>=</span> Person.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>newInstance</span>();
</span></span></code></pre></div><p><strong>调用<code>Class.newInstance()</code>的局限是，它只能调用该类的public无参数构造方法</strong></p></li><li><p>为了调用任意的构造方法，Java的反射API提供了<code>Constructor</code>对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.reflect.Constructor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取构造方法Integer(int):</span>
</span></span><span style=display:flex><span>        Constructor cons1 <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getConstructor</span>(<span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用构造方法:</span>
</span></span><span style=display:flex><span>        Integer n1 <span style=color:#f92672>=</span> (Integer) cons1.<span style=color:#a6e22e>newInstance</span>(123);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(n1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取构造方法Integer(String)</span>
</span></span><span style=display:flex><span>        Constructor cons2 <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getConstructor</span>(String.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>        Integer n2 <span style=color:#f92672>=</span> (Integer) cons2.<span style=color:#a6e22e>newInstance</span>(<span style=color:#e6db74>&#34;456&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(n2);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败</p></li></ul></li><li><h4 id=获取继承关系>获取继承关系<a hidden class=anchor aria-hidden=true href=#获取继承关系>#</a></h4><ul><li><p>获取父类的<code>Class</code></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// reflection</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        Class i <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>class</span>;
</span></span><span style=display:flex><span>        Class n <span style=color:#f92672>=</span> i.<span style=color:#a6e22e>getSuperclass</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(n);
</span></span><span style=display:flex><span>        Class o <span style=color:#f92672>=</span> n.<span style=color:#a6e22e>getSuperclass</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(o);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(o.<span style=color:#a6e22e>getSuperclass</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>运行代码，可以看到，<code>Integer</code>的父类类型是<code>Number</code>，<code>Number</code>的父类是<code>Object</code>，<code>Object</code>的父类是<code>null</code></p></li></ul></li><li><p>获取<code>interface</code></p><ul><li><p>由于类可能实现一个或多个接口，通过<code>Class</code>我们就可以查询到实现的接口类型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// reflection</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.reflect.Method;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        Class s <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>class</span>;
</span></span><span style=display:flex><span>        Class<span style=color:#f92672>[]</span> is <span style=color:#f92672>=</span> s.<span style=color:#a6e22e>getInterfaces</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Class i : is) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行上述代码可知，<code>Integer</code>实现的接口有：</p><ul><li>java.lang.Comparable</li><li>java.lang.constant.Constable</li><li>java.lang.constant.ConstantDesc</li></ul></li><li><p><strong>特别注意：<code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型</strong></p></li></ul></li><li><p>继承关系</p><ul><li><p>当我们判断一个实例是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Object n <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>valueOf</span>(123);
</span></span><span style=display:flex><span><span style=color:#66d9ef>boolean</span> isDouble <span style=color:#f92672>=</span> n <span style=color:#66d9ef>instanceof</span> Double; <span style=color:#75715e>// false</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>boolean</span> isInteger <span style=color:#f92672>=</span> n <span style=color:#66d9ef>instanceof</span> Integer; <span style=color:#75715e>// true</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>boolean</span> isNumber <span style=color:#f92672>=</span> n <span style=color:#66d9ef>instanceof</span> Number; <span style=color:#75715e>// true</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>boolean</span> isSerializable <span style=color:#f92672>=</span> n <span style=color:#66d9ef>instanceof</span> java.<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Serializable</span>; <span style=color:#75715e>// true</span>
</span></span></code></pre></div></li><li><p>如果是两个<code>Class</code>实例，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Integer i = ?</span>
</span></span><span style=display:flex><span>Integer.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>isAssignableFrom</span>(Integer.<span style=color:#a6e22e>class</span>); <span style=color:#75715e>// true，因为Integer可以赋值给Integer</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Number n = ?</span>
</span></span><span style=display:flex><span>Number.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>isAssignableFrom</span>(Integer.<span style=color:#a6e22e>class</span>); <span style=color:#75715e>// true，因为Integer可以赋值给Number</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Object o = ?</span>
</span></span><span style=display:flex><span>Object.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>isAssignableFrom</span>(Integer.<span style=color:#a6e22e>class</span>); <span style=color:#75715e>// true，因为Integer可以赋值给Object</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Integer i = ?</span>
</span></span><span style=display:flex><span>Integer.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>isAssignableFrom</span>(Number.<span style=color:#a6e22e>class</span>); <span style=color:#75715e>// false，因为Number不能赋值给Integer</span>
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=动态代理dynamic-proxy>动态代理(Dynamic Proxy)<a hidden class=anchor aria-hidden=true href=#动态代理dynamic-proxy>#</a></h4><ul><li><p>我们来比较Java的<code>class</code>和<code>interface</code>的区别：</p><ul><li>可以实例化<code>class</code>（非<code>abstract</code>）</li><li>不能实例化<code>interface</code></li></ul><p>所有<code>interface</code>类型的变量总是通过某个实例向上转型并赋值给接口类型变量的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>CharSequence cs <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringBuilder();
</span></span></code></pre></div></li><li><p>动态代理（Dynamic Proxy）机制：<strong>可以在运行期动态创建某个<code>interface</code>的实例</strong></p><ul><li><p>静态代码写法：</p><p>定义接口：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>morning</span>(String name);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编写实现类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HelloWorld</span> <span style=color:#66d9ef>implements</span> Hello {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>morning</span>(String name) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Good morning, &#34;</span> <span style=color:#f92672>+</span> name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>创建实例，转型为接口并调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Hello hello <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HelloWorld();
</span></span><span style=display:flex><span>hello.<span style=color:#a6e22e>morning</span>(<span style=color:#e6db74>&#34;Bob&#34;</span>);
</span></span></code></pre></div></li><li><p>动态代码写法</p><p>我们仍然先定义了接口<code>Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code>Proxy.newProxyInstance()</code>创建了一个<code>Hello</code>接口对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.reflect.InvocationHandler;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.reflect.Method;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.reflect.Proxy;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        InvocationHandler handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> InvocationHandler() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>invoke</span>(Object proxy, Method method, Object<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Throwable {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(method);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (method.<span style=color:#a6e22e>getName</span>().<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;morning&#34;</span>)) {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Good morning, &#34;</span> <span style=color:#f92672>+</span> args<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        Hello hello <span style=color:#f92672>=</span> (Hello) Proxy.<span style=color:#a6e22e>newProxyInstance</span>(
</span></span><span style=display:flex><span>            Hello.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getClassLoader</span>(), <span style=color:#75715e>// 传入ClassLoader</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> { Hello.<span style=color:#a6e22e>class</span> }, <span style=color:#75715e>// 传入要实现的接口</span>
</span></span><span style=display:flex><span>            handler); <span style=color:#75715e>// 传入处理调用方法的InvocationHandler</span>
</span></span><span style=display:flex><span>        hello.<span style=color:#a6e22e>morning</span>(<span style=color:#e6db74>&#34;Bob&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>morning</span>(String name);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在运行期动态创建一个<code>interface</code>实例的方法如下：</p><ol><li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li><li>通过<code>Proxy.newProxyInstance()</code>创建<code>interface</code>实例，它需要3个参数：<ol><li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li></ol></li><li>将返回的<code>Object</code>强制转型为接口</li></ol></li><li><p>动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，把上面的动态代理改写为静态实现类大概长这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HelloDynamicProxy</span> <span style=color:#66d9ef>implements</span> Hello {
</span></span><span style=display:flex><span>    InvocationHandler handler;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>HelloDynamicProxy</span>(InvocationHandler handler) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> handler;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>morning</span>(String name) {
</span></span><span style=display:flex><span>        handler.<span style=color:#a6e22e>invoke</span>(
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>this</span>,
</span></span><span style=display:flex><span>           Hello.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getMethod</span>(<span style=color:#e6db74>&#34;morning&#34;</span>, String.<span style=color:#a6e22e>class</span>),
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> { name }
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li></ul><h3 id=多线程>多线程<a hidden class=anchor aria-hidden=true href=#多线程>#</a></h3><ul><li><h4 id=基础>基础<a hidden class=anchor aria-hidden=true href=#基础>#</a></h4><ul><li><strong>Java程序入口就是由JVM启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束</strong></li><li>某些进程内部需要同时执行多个子任务。<ul><li>在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程</li></ul></li><li>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃</li><li>一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等</li><li>多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步</li></ul></li><li><h4 id=创建新线程>创建新线程<a hidden class=anchor aria-hidden=true href=#创建新线程>#</a></h4><ul><li><p>需要实例化一个<code>Thread</code>实例，然后调用它的<code>start()</code>方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 多线程</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Thread t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread();
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>start</span>(); <span style=color:#75715e>// 启动新线程</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>从<code>Thread</code>派生一个自定义类，然后覆写<code>run()</code>方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 多线程</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Thread t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyThread();
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>start</span>(); <span style=color:#75715e>// 启动新线程</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;start new thread!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行上述代码，注意到<code>start()</code>方法会在内部自动调用实例的<code>run()</code>方法</p></li><li><p>创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 多线程</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Thread t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>new</span> MyRunnable());
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>start</span>(); <span style=color:#75715e>// 启动新线程</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyRunnable</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;start new thread!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p><strong>使用线程执行的打印语句，和直接在<code>main()</code>方法执行的区别</strong></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;main start...&#34;</span>);<span style=color:#75715e>//蓝色</span>
</span></span><span style=display:flex><span>        Thread t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread() {<span style=color:#75715e>//蓝色</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;thread run...&#34;</span>);<span style=color:#75715e>//红色</span>
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;thread end.&#34;</span>);<span style=color:#75715e>//红色</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>start</span>();<span style=color:#75715e>//蓝色</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;main end...&#34;</span>);<span style=color:#75715e>//蓝色</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>蓝色表示主线程，就是<code>main</code>线程，<code>main</code>线程执行的代码4行，打印<code>main start</code></p><p>然后创建<code>Thread</code>对象，紧接着调用<code>start()</code>启动新线程</p><p>当<code>start()</code>方法被调用时，JVM就创建了一个新线程，我们通过实例变量<code>t</code>来表示这个新线程对象，并开始执行</p><p><code>main</code>线程继续执行打印<code>main end</code>语句，而<code>t</code>线程在<code>main</code>线程执行的同时会并发执行，打印<code>thread run</code>和<code>thread end</code>语句</p><p>当<code>run()</code>方法结束时，新线程就结束了。而<code>main()</code>方法结束时，主线程也结束了</p></li><li><p>我们再来看线程的执行顺序：</p><ol><li><code>main</code>线程肯定是先打印<code>main start</code>，再打印<code>main end</code>；</li><li><code>t</code>线程肯定是先打印<code>thread run</code>，再打印<code>thread end</code>。</li></ol><p><strong>除了可以肯定，<code>main start</code>会先打印外，<code>main end</code>打印在<code>thread run</code>之前、<code>thread end</code>之后或者之间，都无法确定。因为从<code>t</code>线程开始运行以后，两个线程就开始同时运行了，并且由操作系统调度，程序本身无法确定线程的调度顺序</strong></p></li></ul></li><li><p>线程的优先级</p><ul><li><p>可以对线程设定优先级，设定优先级的方法是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Thread.<span style=color:#a6e22e>setPriority</span>(<span style=color:#66d9ef>int</span> n) <span style=color:#75715e>// 1~10, 默认值5</span>
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=线程的状态>线程的状态<a hidden class=anchor aria-hidden=true href=#线程的状态>#</a></h4><ul><li><p>在Java程序中，一个线程对象只能调用一次<code>start()</code>方法启动新线程，并在新线程中执行<code>run()</code>方法。一旦<code>run()</code>方法执行完毕，线程就结束了</p><ul><li>New：新创建的线程，尚未执行；</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中；</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li><li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕</li></ul></li><li><p>线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止</p></li><li><p>线程终止的原因有：</p><ul><li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li><li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li><li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）</li></ul></li><li><p><strong>一个线程还可以等待另一个线程直到其运行结束。</strong>例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 多线程</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        Thread t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;start&#34;</span>);
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>start</span>(); <span style=color:#75715e>// 启动t线程</span>
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>join</span>(); <span style=color:#75715e>// 此处main线程会等待t结束</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;end&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>start
hello
end
</code></pre></li></ul></li><li><h4 id=中断线程>中断线程<a hidden class=anchor aria-hidden=true href=#中断线程>#</a></h4><ul><li><p>定义：其他线程给该线程发一个信号，该线程收到信号后结束执行<code>run()</code>方法，使得自身线程能立刻结束运行</p></li><li><p>中断一个线程非常简单，只需要在其他线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行</p><ul><li><p>举例：从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行</p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 中断线程</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        Thread t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyThread();
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(1); <span style=color:#75715e>// 暂停1毫秒</span>
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>interrupt</span>(); <span style=color:#75715e>// 中断t线程</span>
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>join</span>(); <span style=color:#75715e>// 等待t线程结束</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;end&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span> isInterrupted()) {
</span></span><span style=display:flex><span>            n <span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(n <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; hello!&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong><code>main</code>线程通过调用<code>t.interrupt()</code>方法中断<code>t</code>线程，但是要注意，<code>interrupt()</code>方法仅仅向<code>t</code>线程发出了“中断请求”，至于<code>t</code>线程是否能立刻响应，要看具体代码。而<code>t</code>线程的<code>while</code>循环会检测<code>isInterrupted()</code>，所以上述代码能正确响应<code>interrupt()</code>请求，使得自身立刻结束运行<code>run()</code>方法</strong></p></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 中断线程</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        Thread t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyThread();
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(1000);
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>interrupt</span>(); <span style=color:#75715e>// 中断t线程</span>
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>join</span>(); <span style=color:#75715e>// 等待t线程结束</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;end&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        Thread hello <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HelloThread();
</span></span><span style=display:flex><span>        hello.<span style=color:#a6e22e>start</span>(); <span style=color:#75715e>// 启动hello线程</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            hello.<span style=color:#a6e22e>join</span>(); <span style=color:#75715e>// 等待hello线程结束</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;interrupted!&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        hello.<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HelloThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>isInterrupted()) {
</span></span><span style=display:flex><span>            n<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(n <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; hello!&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>sleep</span>(100);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>main</code>线程通过调用<code>t.interrupt()</code>从而通知<code>t</code>线程中断，而此时<code>t</code>线程正位于<code>hello.join()</code>的等待中，此方法会立刻结束等待并抛出<code>InterruptedException</code>。由于我们在<code>t</code>线程中捕获了<code>InterruptedException</code>，因此，就可以准备结束该线程。在<code>t</code>线程结束前，对<code>hello</code>线程也进行了<code>interrupt()</code>调用通知其中断。如果去掉这一行代码，可以发现<code>hello</code>线程仍然会继续运行，且JVM不会退出</p></li><li><p>另一个中断线程的方法：设置标志位</p><p>通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 中断线程</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args)  <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        HelloThread t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HelloThread();
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(1);
</span></span><span style=display:flex><span>        t.<span style=color:#a6e22e>running</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// 标志位置为false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HelloThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>boolean</span> running <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (running) {
</span></span><span style=display:flex><span>            n <span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(n <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; hello!&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;end!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong><code>HelloThread</code>的标志位<code>boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值</strong></p></li><li><p><code>volatile</code>关键字的目的是告诉虚拟机：</p><ul><li>每次访问变量时，总是获取主内存的最新值；</li><li>每次修改变量后，立刻回写到主内存。</li></ul><p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值</p></li></ul></li><li><h4 id=守护线程>守护线程<a hidden class=anchor aria-hidden=true href=#守护线程>#</a></h4><ul><li><p>但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TimerThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(LocalTime.<span style=color:#a6e22e>now</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>sleep</span>(1000);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p></li><li><p>创建守护线程:</p><p>方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Thread t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyThread();
</span></span><span style=display:flex><span>t.<span style=color:#a6e22e>setDaemon</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>t.<span style=color:#a6e22e>start</span>();
</span></span></code></pre></div></li></ul></li><li><h4 id=同步-理解>同步-理解<a hidden class=anchor aria-hidden=true href=#同步-理解>#</a></h4><ul><li><p>多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。任何一个线程都可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行</p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 多线程</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> add <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AddThread();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> dec <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DecThread();
</span></span><span style=display:flex><span>        add.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        dec.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        add.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>        dec.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Counter.<span style=color:#a6e22e>count</span>);<span style=color:#75715e>//每次结果,都是不一样的</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AddThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0; i<span style=color:#f92672>&lt;</span>10000; i<span style=color:#f92672>++</span>) { Counter.<span style=color:#a6e22e>count</span> <span style=color:#f92672>+=</span> 1; }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DecThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0; i<span style=color:#f92672>&lt;</span>10000; i<span style=color:#f92672>++</span>) { Counter.<span style=color:#a6e22e>count</span> <span style=color:#f92672>-=</span> 1; }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>原子操作</p><p>对于语句：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>n <span style=color:#f92672>=</span> n <span style=color:#f92672>+</span> 1;
</span></span></code></pre></div><p>看上去是一行语句，实际上对应了3条指令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ILOAD
</span></span><span style=display:flex><span>IADD
</span></span><span style=display:flex><span>ISTORE
</span></span></code></pre></div><p>多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待</p></li><li><p>临界区：加锁和解锁之间的代码块</p><p>在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行</p><p>任何时候临界区最多只有一个线程能执行</p></li><li><p>Java程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>synchronized</span>(lock) {
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> n <span style=color:#f92672>+</span> 1;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>synchronized</code>保证了代码块在任意时刻最多只有一个线程能执行</p></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 多线程</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> add <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AddThread();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> dec <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DecThread();
</span></span><span style=display:flex><span>        add.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        dec.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        add.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>        dec.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Counter.<span style=color:#a6e22e>count</span>);<span style=color:#75715e>//结果都是0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Object lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AddThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0; i<span style=color:#f92672>&lt;</span>10000; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span>(Counter.<span style=color:#a6e22e>lock</span>) {
</span></span><span style=display:flex><span>                Counter.<span style=color:#a6e22e>count</span> <span style=color:#f92672>+=</span> 1;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DecThread</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0; i<span style=color:#f92672>&lt;</span>10000; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span>(Counter.<span style=color:#a6e22e>lock</span>) {
</span></span><span style=display:flex><span>                Counter.<span style=color:#a6e22e>count</span> <span style=color:#f92672>-=</span> 1;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>synchronized</span>(Counter.<span style=color:#a6e22e>lock</span>) { <span style=color:#75715e>// 获取锁</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>} <span style=color:#75715e>// 释放锁</span>
</span></span></code></pre></div><p>用<code>Counter.lock</code>实例作为锁，两个线程在执行各自的<code>synchronized(Counter.lock) { ... }</code>代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在<code>synchronized</code>语句块结束会自动释放锁</p></li><li><p>来概括一下如何使用<code>synchronized</code>：</p><ol><li>找出修改共享变量的线程代码块；</li><li>选择一个共享实例作为锁；</li><li>使用<code>synchronized(lockObject) { ... }</code></li></ol></li><li><p>使用<code>synchronized</code>，不必担心抛出异常。因为无论是否有异常，都会在<code>synchronized</code>结束处正确释放锁：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> m) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> (obj) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>&lt;</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>+=</span> m;
</span></span><span style=display:flex><span>    } <span style=color:#75715e>// 无论有无异常，都会在此释放锁</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p><strong>不需要<code>synchronized</code>操作</strong></p><ul><li><p>JVM规范定义了几种原子操作：</p><ul><li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li><li>引用类型赋值，例如：<code>List&lt;String> list = anotherList</code></li><li><code>long</code>和<code>double</code>是64位数据，在x64平台的JVM是把<code>long</code>和<code>double</code>的赋值作为原子操作实现的</li></ul></li><li><p>单条原子操作的语句不需要同步</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>int</span> m) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span>(lock) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> m;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>可改为：</strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> s;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p>如果是多行赋值语句，就必须保证是同步操作，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span>(<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> y;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>多线程连续读写多个变量时，同步的目的是为了保证程序逻辑正确！</strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span>(<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> y;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>get</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> copy <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        copy<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>        copy<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> y;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>通过一些巧妙的转换，可以把非原子操作变为原子操作，改为：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> ps;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> ps <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> { x, y };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>ps</span> <span style=color:#f92672>=</span> ps;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong><code>this.ps = ps</code>是引用赋值的原子操作</strong></p><p><strong><code>ps</code>是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步</strong></p></li><li><p>不可变对象无需同步</p><p>如果多线程读写的是一个不可变对象，那么无需同步，因为不会修改对象的状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Data</span> {
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> names;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set</span>(String<span style=color:#f92672>[]</span> names) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>names</span> <span style=color:#f92672>=</span> List.<span style=color:#a6e22e>of</span>(names);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>get</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>names</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>分析变量是否能被多线程访问</p><p><strong>首先要理清概念，多线程同时执行的是方法</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Status</span> {
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> names;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set</span>(String<span style=color:#f92672>[]</span> names, <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> ns <span style=color:#f92672>=</span> List.<span style=color:#a6e22e>of</span>(names);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>names</span> <span style=color:#f92672>=</span> ns;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> step <span style=color:#f92672>=</span> n <span style=color:#f92672>*</span> 10;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>+=</span> step;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>y</span> <span style=color:#f92672>+=</span> step;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    StatusRecord <span style=color:#a6e22e>get</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> StatusRecord(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>names</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>y</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果有A、B两个线程，同时执行是指：</p><ul><li>可能同时执行set()；</li><li>可能同时执行get()；</li><li>可能A执行set()，同时B执行get()</li></ul><p><strong>类的成员变量<code>names</code>、<code>x</code>、<code>y</code>显然能被多线程同时读写，但局部变量（包括方法参数）如果没有“逃逸”，那么只有当前线程可见;</strong></p><p><strong>局部变量<code>step</code>仅在<code>set()</code>方法内部使用，因此每个线程同时执行set时都有一份独立的step存储在线程的栈上，互不影响，但是局部变量<code>ns</code>虽然每个线程也各有一份，但后续赋值后对其他线程就变成可见了</strong></p><p>对<code>set()</code>方法同步时，如果要最小化<code>synchronized</code>代码块，可以改写如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set</span>(String<span style=color:#f92672>[]</span> names, <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 局部变量其他线程不可见:</span>
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> ns <span style=color:#f92672>=</span> List.<span style=color:#a6e22e>of</span>(names);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> step <span style=color:#f92672>=</span> n <span style=color:#f92672>*</span> 10;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span>(<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>names</span> <span style=color:#f92672>=</span> ns;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>+=</span> step;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>y</span> <span style=color:#f92672>+=</span> step;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=同步-同步方法>同步-同步方法<a hidden class=anchor aria-hidden=true href=#同步-同步方法>#</a></h4><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span>(<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>            count <span style=color:#f92672>+=</span> n;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dec</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span>(<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>            count <span style=color:#f92672>-=</span> n;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> count;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>线程调用<code>add()</code>、<code>dec()</code>方法时，它不必关心同步逻辑，因为<code>synchronized</code>代码块在<code>add()</code>、<code>dec()</code>方法内部</p><p>我们注意到，<code>synchronized</code>锁住的对象是<code>this</code>，即当前实例，这又使得创建多个<code>Counter</code>实例的时候，它们之间互不影响，可以并发执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>var</span> c1 <span style=color:#f92672>=</span> Counter();
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> c2 <span style=color:#f92672>=</span> Counter();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 对c1进行操作的线程:</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>    c1.<span style=color:#a6e22e>add</span>();
</span></span><span style=display:flex><span>}).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>    c1.<span style=color:#a6e22e>dec</span>();
</span></span><span style=display:flex><span>}).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 对c2进行操作的线程:</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>    c2.<span style=color:#a6e22e>add</span>();
</span></span><span style=display:flex><span>}).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>    c2.<span style=color:#a6e22e>dec</span>();
</span></span><span style=display:flex><span>}).<span style=color:#a6e22e>start</span>();
</span></span></code></pre></div></li><li><p>线程安全</p><ul><li>如果一个类被设计为允许多线程正确访问，Java标准库的<code>java.lang.StringBuffer</code>也是线程安全的</li><li>不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的</li><li>类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的</li></ul></li></ul></li><li><h4 id=同步-死锁>同步-死锁<a hidden class=anchor aria-hidden=true href=#同步-死锁>#</a></h4><ul><li><p>Java的线程锁是可重入的锁</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;</span> 0) {
</span></span><span style=display:flex><span>            dec(<span style=color:#f92672>-</span>n);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            count <span style=color:#f92672>+=</span> n;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dec</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        count <span style=color:#f92672>+=</span> n;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>synchronized</code>修饰的<code>add()</code>方法，一旦线程执行到<code>add()</code>方法内部，已经获取当前实例的<code>this</code>锁，如果传入的<code>n &lt; 0</code>，将在<code>add()</code>方法内部调用<code>dec()</code>方法。由于<code>dec()</code>方法也需要获取<code>this</code>锁</p><ul><li><p>对同一个线程，能否在获取到锁以后继续获取同一个锁？</p><p><strong>JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁</strong></p><p><strong>因为Java线程锁是可重入锁，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出<code>synchronized</code>块，记录-1，减到0的时候，才会真正释放锁</strong></p></li></ul></li><li><p>死锁</p><ul><li><p>一个线程可以获取一个锁后，再继续获取另一个锁</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> m) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span>(lockA) { <span style=color:#75715e>// 获得lockA的锁</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>+=</span> m;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span>(lockB) { <span style=color:#75715e>// 获得lockB的锁</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>another</span> <span style=color:#f92672>+=</span> m;
</span></span><span style=display:flex><span>        } <span style=color:#75715e>// 释放lockB的锁</span>
</span></span><span style=display:flex><span>    } <span style=color:#75715e>// 释放lockA的锁</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dec</span>(<span style=color:#66d9ef>int</span> m) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span>(lockB) { <span style=color:#75715e>// 获得lockB的锁</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>another</span> <span style=color:#f92672>-=</span> m;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span>(lockA) { <span style=color:#75715e>// 获得lockA的锁</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>-=</span> m;
</span></span><span style=display:flex><span>        } <span style=color:#75715e>// 释放lockA的锁</span>
</span></span><span style=display:flex><span>    } <span style=color:#75715e>// 释放lockB的锁</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁</strong></p></li><li><p>死锁发生后，没有任何机制能解除死锁，只能<strong>强制结束JVM进程</strong></p></li></ul></li><li><p>防止死锁</p><ul><li><p>线程获取锁的顺序要一致</p><p>即严格按照先获取<code>lockA</code>，再获取<code>lockB</code>的顺序，改写<code>dec()</code>方法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dec</span>(<span style=color:#66d9ef>int</span> m) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span>(lockA) { <span style=color:#75715e>// 获得lockA的锁</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>-=</span> m;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span>(lockB) { <span style=color:#75715e>// 获得lockB的锁</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>another</span> <span style=color:#f92672>-=</span> m;
</span></span><span style=display:flex><span>        } <span style=color:#75715e>// 释放lockB的锁</span>
</span></span><span style=display:flex><span>    } <span style=color:#75715e>// 释放lockA的锁</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=同步-wait和notify>同步-<code>wait</code>和<code>notify</code><a hidden class=anchor aria-hidden=true href=#同步-wait和notify>#</a></h4><ul><li><p><code>synchronized</code>解决了多线程竞争的问题</p><p>对于一个任务管理器，多个线程同时往队列中添加任务，可以用<code>synchronized</code>加锁：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TaskQueue</span> {
</span></span><span style=display:flex><span>    Queue<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addTask</span>(String s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>queue</span>.<span style=color:#a6e22e>add</span>(s);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编写一个<code>getTask()</code>方法取出队列的任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TaskQueue</span> {
</span></span><span style=display:flex><span>    Queue<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addTask</span>(String s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>queue</span>.<span style=color:#a6e22e>add</span>(s);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> String <span style=color:#a6e22e>getTask</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (queue.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> queue.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>问题：<strong>实际上<code>while()</code>循环永远不会退出。因为线程在执行<code>while()</code>循环时，已经在<code>getTask()</code>入口获取了<code>this</code>锁，其他线程根本无法调用<code>addTask()</code>，因为<code>addTask()</code>执行条件也是获取<code>this</code>锁</strong></p><p>执行上述代码，线程会在<code>getTask()</code>中因为死循环而100%占用CPU资源</p><ul><li><p>只能在锁对象上调用<code>wait()</code>方法。因为在<code>getTask()</code>中，我们获得了<code>this</code>锁，因此，只能在<code>this</code>对象上调用<code>wait()</code>方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> String <span style=color:#a6e22e>getTask</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (queue.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 释放this锁:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>wait</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 重新获取this锁</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> queue.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong><code>wait()</code>方法的执行机制非常复杂。是定义在<code>Object</code>类的一个<code>native</code>方法，必须在<code>synchronized</code>块中才能调用<code>wait()</code>方法，因为<code>wait()</code>方法调用时，会<em>释放</em>线程获得的锁，<code>wait()</code>方法返回时，线程又会重新试图获得锁</strong></p></li><li><p>在相同的锁对象上调用<code>notify()</code>方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addTask</span>(String s) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>queue</span>.<span style=color:#a6e22e>add</span>(s);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>notify</span>(); <span style=color:#75715e>// 唤醒在this锁等待的线程</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>往队列中添加了任务后，线程立刻对<code>this</code>锁对象调用<code>notify()</code>方法，这个方法会唤醒一个正在<code>this</code>锁等待的线程（就是在<code>getTask()</code>中位于<code>this.wait()</code>的线程),从而使得等待线程从<code>this.wait()</code>方法返回</p></li></ul></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.*;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> q <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TaskQueue();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> ts <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>Thread<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0; i<span style=color:#f92672>&lt;</span>5; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 执行task:</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                            String s <span style=color:#f92672>=</span> q.<span style=color:#a6e22e>getTask</span>();
</span></span><span style=display:flex><span>                            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;execute task: &#34;</span> <span style=color:#f92672>+</span> s);
</span></span><span style=display:flex><span>                        } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            t.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>            ts.<span style=color:#a6e22e>add</span>(t);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> add <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0; i<span style=color:#f92672>&lt;</span>10; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 放入task:</span>
</span></span><span style=display:flex><span>                String s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;t-&#34;</span> <span style=color:#f92672>+</span> Math.<span style=color:#a6e22e>random</span>();
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;add task: &#34;</span> <span style=color:#f92672>+</span> s);
</span></span><span style=display:flex><span>                q.<span style=color:#a6e22e>addTask</span>(s);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> { Thread.<span style=color:#a6e22e>sleep</span>(100); } <span style=color:#66d9ef>catch</span>(InterruptedException e) {}
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        add.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        add.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(100);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> t : ts) {
</span></span><span style=display:flex><span>            t.<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TaskQueue</span> {
</span></span><span style=display:flex><span>    Queue<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addTask</span>(String s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>queue</span>.<span style=color:#a6e22e>add</span>(s);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>notifyAll</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> String <span style=color:#a6e22e>getTask</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (queue.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>wait</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> queue.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>重点关注<code>addTask()</code>方法，内部调用了<code>this.notifyAll()</code>而不是<code>this.notify()</code>，使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）</strong></p></li></ul></li><li><h4 id=同步-reentrantlock>同步-ReentrantLock<a hidden class=anchor aria-hidden=true href=#同步-reentrantlock>#</a></h4><ul><li><p>传统：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span>(<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>            count <span style=color:#f92672>+=</span> n;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>改造后：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            count <span style=color:#f92672>+=</span> n;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>ReentrantLock</code>是可重入锁，和<code>synchronized</code>一样，一个线程可以多次获取同一个锁</p><p>和<code>synchronized</code>不同的是，<code>ReentrantLock</code>可以尝试获取锁：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> (lock.<span style=color:#a6e22e>tryLock</span>(1, TimeUnit.<span style=color:#a6e22e>SECONDS</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去</p><p><strong>使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，线程在<code>tryLock()</code>失败的时候不会导致死锁</strong></p></li></ul></li><li><h4 id=同步-condition>同步-Condition<a hidden class=anchor aria-hidden=true href=#同步-condition>#</a></h4><ul><li><p><code>synchronized</code>可以配合<code>wait</code>和<code>notify</code>实现线程在条件不满足时等待</p></li><li><p>用<code>ReentrantLock</code>我们使用<code>Condition</code>对象来实现<code>wait</code>和<code>notify</code>的功能</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TaskQueue</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Lock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Condition condition <span style=color:#f92672>=</span> lock.<span style=color:#a6e22e>newCondition</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Queue<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addTask</span>(String s) {
</span></span><span style=display:flex><span>        lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            queue.<span style=color:#a6e22e>add</span>(s);
</span></span><span style=display:flex><span>            condition.<span style=color:#a6e22e>signalAll</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getTask</span>() {
</span></span><span style=display:flex><span>        lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (queue.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>                condition.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> queue.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p><ul><li><code>await()</code>会释放当前锁，进入等待状态；</li><li><code>signal()</code>会唤醒某个等待线程；</li><li><code>signalAll()</code>会唤醒所有等待线程；</li><li>唤醒线程从<code>await()</code>返回后需要重新获得锁</li></ul></li><li><p>和<code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> (condition.<span style=color:#a6e22e>await</span>(1, TimeUnit.<span style=color:#a6e22e>SECOND</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 被其他线程唤醒</span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 指定时间内没有被其他线程唤醒</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用<code>Condition</code>配合<code>Lock</code>，可以实现更灵活的线程同步</p></li></ul></li><li><h4 id=同步-readwritelock>同步-ReadWriteLock<a hidden class=anchor aria-hidden=true href=#同步-readwritelock>#</a></h4></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/java03/><span class=title>« Prev Page</span><br><span>Java03</span>
</a><a class=next href=https://zwlzls.github.io/posts/java01/><span class=title>Next Page »</span><br><span>Java中级</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>