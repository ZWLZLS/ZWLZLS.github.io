<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python高级 | 我的博客</title>
<meta name=keywords content="Python"><meta name=description content="Python高级 面向对象编程 以一个例子来说明面向过程和面向对象在程序流程上的不同之处
假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：
std1 = { 'name': 'Michael', 'score': 98 } std2 = { 'name': 'Bob', 'score': 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩：
def print_score(std): print('%s: %s' % (std['name'], std['score'])) 面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来
class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：
bart = Student('Bart Simpson', 59) lisa = Student('Lisa Simpson', 87) bart.print_score() lisa.print_score() 类和实例 类是抽象的模板，实例是类创建的一个个具体的“对象”
和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数
定义类是通过class关键字：
class Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，没有合适的继承类，就使用object类，是所有类最终都会继承的类
由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去："><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/python02/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/python02/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Python高级"><meta property="og:description" content="Python高级 面向对象编程 以一个例子来说明面向过程和面向对象在程序流程上的不同之处
假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：
std1 = { 'name': 'Michael', 'score': 98 } std2 = { 'name': 'Bob', 'score': 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩：
def print_score(std): print('%s: %s' % (std['name'], std['score'])) 面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来
class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：
bart = Student('Bart Simpson', 59) lisa = Student('Lisa Simpson', 87) bart.print_score() lisa.print_score() 类和实例 类是抽象的模板，实例是类创建的一个个具体的“对象”
和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数
定义类是通过class关键字：
class Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，没有合适的继承类，就使用object类，是所有类最终都会继承的类
由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去："><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/python02/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-17T15:14:04+08:00"><meta property="article:modified_time" content="2025-01-17T15:14:04+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python高级"><meta name=twitter:description content="Python高级 面向对象编程 以一个例子来说明面向过程和面向对象在程序流程上的不同之处
假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：
std1 = { 'name': 'Michael', 'score': 98 } std2 = { 'name': 'Bob', 'score': 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩：
def print_score(std): print('%s: %s' % (std['name'], std['score'])) 面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来
class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：
bart = Student('Bart Simpson', 59) lisa = Student('Lisa Simpson', 87) bart.print_score() lisa.print_score() 类和实例 类是抽象的模板，实例是类创建的一个个具体的“对象”
和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数
定义类是通过class关键字：
class Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，没有合适的继承类，就使用object类，是所有类最终都会继承的类
由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python高级","item":"https://zwlzls.github.io/posts/python02/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python高级","name":"Python高级","description":"Python高级 面向对象编程 以一个例子来说明面向过程和面向对象在程序流程上的不同之处\n假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：\nstd1 = { \u0026#39;name\u0026#39;: \u0026#39;Michael\u0026#39;, \u0026#39;score\u0026#39;: 98 } std2 = { \u0026#39;name\u0026#39;: \u0026#39;Bob\u0026#39;, \u0026#39;score\u0026#39;: 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩：\ndef print_score(std): print(\u0026#39;%s: %s\u0026#39; % (std[\u0026#39;name\u0026#39;], std[\u0026#39;score\u0026#39;])) 面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来\nclass Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print(\u0026#39;%s: %s\u0026#39; % (self.name, self.score)) 给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：\nbart = Student(\u0026#39;Bart Simpson\u0026#39;, 59) lisa = Student(\u0026#39;Lisa Simpson\u0026#39;, 87) bart.print_score() lisa.print_score() 类和实例 类是抽象的模板，实例是类创建的一个个具体的“对象”\n和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数\n定义类是通过class关键字：\nclass Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，没有合适的继承类，就使用object类，是所有类最终都会继承的类\n由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：","keywords":["Python"],"articleBody":"Python高级 面向对象编程 以一个例子来说明面向过程和面向对象在程序流程上的不同之处\n假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：\nstd1 = { 'name': 'Michael', 'score': 98 } std2 = { 'name': 'Bob', 'score': 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩：\ndef print_score(std): print('%s: %s' % (std['name'], std['score'])) 面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来\nclass Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：\nbart = Student('Bart Simpson', 59) lisa = Student('Lisa Simpson', 87) bart.print_score() lisa.print_score() 类和实例 类是抽象的模板，实例是类创建的一个个具体的“对象”\n和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数\n定义类是通过class关键字：\nclass Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，没有合适的继承类，就使用object类，是所有类最终都会继承的类\n由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：\nclass Student(object): def __init__(self, name, score): self.name = name self.score = score 注意__init__方法第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，self就指向创建的实例本身\n有__init__方法，创建实例时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：\n\u003e\u003e\u003e bart = Student('Bart Simpson', 59) \u003e\u003e\u003e bart.name 'Bart Simpson' \u003e\u003e\u003e bart.score 59 访问限制 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__\nclass Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) \u003e\u003e\u003e bart = Student('Bart Simpson', 59) \u003e\u003e\u003e bart.__name Traceback (most recent call last): File \"\", line 1, in AttributeError: 'Student' object has no attribute '__name' 外部代码要获取name和score，给Student类增加get_name和get_score的方法：\nclass Student(object): ... def get_name(self): return self.__name def get_score(self): return self.__score 要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：\nclass Student(object): ... def set_score(self, score): self.__score = score 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：\n\u003e\u003e\u003e bart._Student__name 'Bart Simpson' 但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名\n注意下面的这种错误写法：\n\u003e\u003e\u003e bart = Student('Bart Simpson', 59) \u003e\u003e\u003e bart.get_name() 'Bart Simpson' \u003e\u003e\u003e bart.__name = 'New Name' # 设置__name变量！ \u003e\u003e\u003e bart.__name 'New Name' 表面上，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试：\n\u003e\u003e\u003e bart.get_name() # get_name()内部返回self.__name 'Bart Simpson' 继承和多态 继承：\n最大的好处是子类获得了父类的全部功能 第二个好处需要我们对代码做一点改进，子类的run()可覆盖父类的run() 如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类 多态\n当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法 静态语言VS动态语言\n静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法\nPython这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：\nclass Timer(object): def run(self): print('Start...') 这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子\n获得对象信息 当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？\n判断对象类型，使用type()函数\n基本类型都可以用type()判断：\n\u003e\u003e\u003e type(123) ","wordCount":"2524","inLanguage":"en","datePublished":"2025-01-17T15:14:04+08:00","dateModified":"2025-01-17T15:14:04+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/python02/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Python高级</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#python%e9%ab%98%e7%ba%a7 aria-label=Python高级>Python高级</a><ul><li><a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b aria-label=面向对象编程>面向对象编程</a><ul><li><a href=#%e7%b1%bb%e5%92%8c%e5%ae%9e%e4%be%8b aria-label=类和实例>类和实例</a></li><li><a href=#%e8%ae%bf%e9%97%ae%e9%99%90%e5%88%b6 aria-label=访问限制>访问限制</a></li><li><a href=#%e7%bb%a7%e6%89%bf%e5%92%8c%e5%a4%9a%e6%80%81 aria-label=继承和多态>继承和多态</a></li><li><a href=#%e8%8e%b7%e5%be%97%e5%af%b9%e8%b1%a1%e4%bf%a1%e6%81%af aria-label=获得对象信息>获得对象信息</a></li><li><a href=#%e5%ae%9e%e4%be%8b%e5%b1%9e%e6%80%a7%e5%92%8c%e7%b1%bb%e5%b1%9e%e6%80%a7 aria-label=实例属性和类属性>实例属性和类属性</a></li></ul></li><li><a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e9%ab%98%e7%ba%a7%e7%bc%96%e7%a8%8b aria-label=面向对象高级编程>面向对象高级编程</a><ul><li><a href=#%e4%bd%bf%e7%94%a8__slots__ aria-label=使用__slots__>使用<code>__slots__</code></a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8property aria-label=使用@property>使用@property</a></li><li><a href=#%e5%a4%9a%e9%87%8d%e7%bb%a7%e6%89%bf aria-label=多重继承>多重继承</a></li><li><a href=#%e5%ae%9a%e5%88%b6%e7%b1%bb aria-label=定制类>定制类</a></li><li><a href=#%e6%9e%9a%e4%b8%be%e7%b1%bb aria-label=枚举类>枚举类</a><ul><li><a href=#%e4%bd%bf%e7%94%a8%e5%85%83%e7%b1%bb%e8%bf%98%e6%b2%a1%e6%9c%89%e8%ae%b0%e5%bd%95 aria-label=使用元类（还没有记录）>使用元类（还没有记录）</a></li></ul></li><li><a href=#%e9%94%99%e8%af%af%e8%b0%83%e8%af%95%e5%92%8c%e6%b5%8b%e8%af%95 aria-label=错误调试和测试>错误调试和测试</a><ul><li><a href=#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86 aria-label=错误处理>错误处理</a></li><li><a href=#%e8%b0%83%e8%af%95 aria-label=调试>调试</a></li><li><a href=#%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95 aria-label=单元测试>单元测试</a></li><li><a href=#%e6%96%87%e6%a1%a3%e6%b5%8b%e8%af%95 aria-label=文档测试>文档测试</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=python高级>Python高级<a hidden class=anchor aria-hidden=true href=#python高级>#</a></h2><h3 id=面向对象编程>面向对象编程<a hidden class=anchor aria-hidden=true href=#面向对象编程>#</a></h3><ul><li><p>以一个例子来说明<strong>面向过程</strong>和<strong>面向对象</strong>在程序流程上的不同之处</p><ul><li><p>假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>std1 <span style=color:#f92672>=</span> { <span style=color:#e6db74>&#39;name&#39;</span>: <span style=color:#e6db74>&#39;Michael&#39;</span>, <span style=color:#e6db74>&#39;score&#39;</span>: <span style=color:#ae81ff>98</span> }
</span></span><span style=display:flex><span>std2 <span style=color:#f92672>=</span> { <span style=color:#e6db74>&#39;name&#39;</span>: <span style=color:#e6db74>&#39;Bob&#39;</span>, <span style=color:#e6db74>&#39;score&#39;</span>: <span style=color:#ae81ff>81</span> }
</span></span></code></pre></div><p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_score</span>(std):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> (std[<span style=color:#e6db74>&#39;name&#39;</span>], std[<span style=color:#e6db74>&#39;score&#39;</span>]))
</span></span></code></pre></div></li><li><p>面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是<code>Student</code>这种数据类型应该被视为一个对象，这个对象拥有<code>name</code>和<code>score</code>这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name, score):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>score <span style=color:#f92672>=</span> score
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_score</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> (self<span style=color:#f92672>.</span>name, self<span style=color:#f92672>.</span>score))
</span></span></code></pre></div><p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>bart <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#39;Bart Simpson&#39;</span>, <span style=color:#ae81ff>59</span>)
</span></span><span style=display:flex><span>lisa <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#39;Lisa Simpson&#39;</span>, <span style=color:#ae81ff>87</span>)
</span></span><span style=display:flex><span>bart<span style=color:#f92672>.</span>print_score()
</span></span><span style=display:flex><span>lisa<span style=color:#f92672>.</span>print_score()
</span></span></code></pre></div></li></ul></li><li><h4 id=类和实例>类和实例<a hidden class=anchor aria-hidden=true href=#类和实例>#</a></h4><ul><li><p>类是抽象的模板，实例是类创建的一个个具体的“对象”</p></li><li><p><strong>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量<code>self</code>，并且，调用时，不用传递该参数</strong></p></li><li><p>定义类是通过<code>class</code>关键字：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div><p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，<strong>表示该类是从哪个类继承下来的</strong>，通常，没有合适的继承类，就使用<code>object</code>类，是所有类最终都会继承的类</p><p><em><strong>由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name, score):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>score <span style=color:#f92672>=</span> score
</span></span></code></pre></div><p>注意<code>__init__</code>方法第一个参数永远是<code>self</code>，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，<code>self</code>就指向创建的实例本身</p><ul><li><p>有<code>__init__</code>方法，创建实例时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器自己会把实例变量传进去：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 59)
</span></span><span style=display:flex><span>&gt;&gt;&gt; bart.name
</span></span><span style=display:flex><span>&#39;Bart Simpson&#39;
</span></span><span style=display:flex><span>&gt;&gt;&gt; bart.score
</span></span><span style=display:flex><span>59
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=访问限制>访问限制<a hidden class=anchor aria-hidden=true href=#访问限制>#</a></h4><ul><li><p><strong>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code></strong></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name, score):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__score <span style=color:#f92672>=</span> score
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_score</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> (self<span style=color:#f92672>.</span>__name, self<span style=color:#f92672>.</span>__score))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 59)
</span></span><span style=display:flex><span>&gt;&gt;&gt; bart.__name
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
</span></span><span style=display:flex><span>AttributeError: &#39;Student&#39; object has no attribute &#39;__name&#39;
</span></span></code></pre></div></li></ul></li><li><p>外部代码要获取name和score，给Student类增加<code>get_name</code>和<code>get_score</code>的方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_name</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>__name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_score</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>__score
</span></span></code></pre></div><p>要允许外部代码修改score怎么办？可以再给Student类增加<code>set_score</code>方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>set_score</span>(self, score):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__score <span style=color:#f92672>=</span> score
</span></span></code></pre></div></li><li><p><strong>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是</strong>。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; bart._Student__name
</span></span><span style=display:flex><span>&#39;Bart Simpson&#39;
</span></span></code></pre></div><p><em><strong>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名</strong></em></p></li><li><p><em><strong>注意下面的这种错误写法</strong></em>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 59)
</span></span><span style=display:flex><span>&gt;&gt;&gt; bart.get_name()
</span></span><span style=display:flex><span>&#39;Bart Simpson&#39;
</span></span><span style=display:flex><span>&gt;&gt;&gt; bart.__name = &#39;New Name&#39; # 设置__name变量！
</span></span><span style=display:flex><span>&gt;&gt;&gt; bart.__name
</span></span><span style=display:flex><span>&#39;New Name&#39;
</span></span></code></pre></div><p>表面上，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量<em>不是</em>一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name
</span></span><span style=display:flex><span>&#39;Bart Simpson&#39;
</span></span></code></pre></div></li></ul></li><li><h4 id=继承和多态>继承和多态<a hidden class=anchor aria-hidden=true href=#继承和多态>#</a></h4><ul><li><p>继承：</p><ul><li>最大的好处是子类获得了父类的全部功能</li><li>第二个好处需要我们对代码做一点改进，子类的<code>run()</code>可覆盖父类的<code>run()</code></li><li>如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类</li></ul></li><li><p>多态</p><ul><li>当我们需要传入<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……都是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动<strong>调用实际类型</strong>的<code>run()</code>方法</li></ul></li><li><p>静态语言VS动态语言</p><ul><li><p>静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法</p></li><li><p><strong>Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Timer</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;Start...&#39;</span>)
</span></span></code></pre></div><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子</p></li></ul></li></ul></li><li><h4 id=获得对象信息>获得对象信息<a hidden class=anchor aria-hidden=true href=#获得对象信息>#</a></h4><ul><li><p><em><strong>当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？</strong></em></p></li><li><p>判断对象类型，使用<code>type()</code>函数</p><ul><li><p>基本类型都可以用<code>type()</code>判断：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; type(123)
</span></span><span style=display:flex><span>&lt;class &#39;int&#39;&gt;
</span></span></code></pre></div></li><li><p>一个变量指向函数或者类，也可以用<code>type()</code>判断：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; type(abs)
</span></span><span style=display:flex><span>&lt;class &#39;builtin_function_or_method&#39;&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; type(123)==type(456)
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; type(123)==int
</span></span><span style=display:flex><span>True
</span></span></code></pre></div></li><li><p>如果要判断一个对象是否 是函数怎么办？可以使用<code>types</code>模块中定义的常量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; import types
</span></span><span style=display:flex><span>&gt;&gt;&gt; def fn():
</span></span><span style=display:flex><span>...     pass
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; type(fn)==types.FunctionType
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; type(lambda x: x)==types.LambdaType
</span></span><span style=display:flex><span>True
</span></span></code></pre></div></li></ul></li><li><p>对class的继承关系来说，判断class的类型，使用<code>isinstance()</code>函数</p><ul><li><p>回顾上次的例子，如果继承关系是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>object -&gt; Animal -&gt; Dog -&gt; Husky
</span></span></code></pre></div></li><li><p>先创建3种类型的对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; a = Animal()
</span></span><span style=display:flex><span>&gt;&gt;&gt; d = Dog()
</span></span><span style=display:flex><span>&gt;&gt;&gt; h = Husky()
</span></span></code></pre></div></li><li><p>验证如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; isinstance(d, Dog) and isinstance(d, Animal)
</span></span><span style=display:flex><span>True
</span></span></code></pre></div></li></ul></li><li><p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法</p><ul><li><p>我们自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; class MyDog(object):
</span></span><span style=display:flex><span>...     def __len__(self):
</span></span><span style=display:flex><span>...         return 100
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; dog = MyDog()
</span></span><span style=display:flex><span>&gt;&gt;&gt; len(dog)
</span></span><span style=display:flex><span>100
</span></span></code></pre></div></li></ul></li><li><p><strong>要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数</strong>，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; dir(&#39;ABC&#39;)
</span></span><span style=display:flex><span>[&#39;__add__&#39;, &#39;__class__&#39;,..., &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;,..., &#39;
</span></span></code></pre></div></li></ul></li><li><h4 id=实例属性和类属性>实例属性和类属性<a hidden class=anchor aria-hidden=true href=#实例属性和类属性>#</a></h4><ul><li><p><strong>Python是动态语言，根据类创建的实例可以任意绑定属性</strong></p><ul><li><p>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#39;Bob&#39;</span>)
</span></span><span style=display:flex><span>s<span style=color:#f92672>.</span>score <span style=color:#f92672>=</span> <span style=color:#ae81ff>90</span>
</span></span></code></pre></div></li></ul></li><li><p>类本身需要绑定一个属性，直接class中定义属性，这是类属性，归<code>Student</code>类所有：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Student&#39;</span>
</span></span></code></pre></div><p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到</p></li><li><p><strong>相关测试如下</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; class Student(object):
</span></span><span style=display:flex><span>...     name = &#39;Student&#39;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; s = Student() # 创建实例s
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
</span></span><span style=display:flex><span>Student
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(Student.name) # 打印类的name属性
</span></span><span style=display:flex><span>Student
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.name = &#39;Michael&#39; # 给实例绑定name属性
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
</span></span><span style=display:flex><span>Michael
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
</span></span><span style=display:flex><span>Student
</span></span><span style=display:flex><span>&gt;&gt;&gt; del s.name # 如果删除实例的name属性
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
</span></span><span style=display:flex><span>Student
</span></span></code></pre></div></li></ul></li></ul><h3 id=面向对象高级编程>面向对象高级编程<a hidden class=anchor aria-hidden=true href=#面向对象高级编程>#</a></h3><ul><li><h4 id=使用__slots__>使用<code>__slots__</code><a hidden class=anchor aria-hidden=true href=#使用__slots__>#</a></h4><ul><li><p>正常情况下，当我们定义了一个<code>class</code>，创建了一个<code>class</code>的实例后，我们可以***给该实例绑定任何属性和方法***，这就是动态语言的灵活性</p><ul><li><p>先定义<code>class</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div></li><li><p>给实例绑定一个属性：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; s = Student()
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.name = &#39;Michael&#39; # 动态给实例绑定一个属性
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(s.name)
</span></span><span style=display:flex><span>Michael
</span></span></code></pre></div></li><li><p>给实例绑定一个方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法
</span></span><span style=display:flex><span>...     self.age = age
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; from types import MethodType
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.set_age(25) # 调用实例方法
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.age # 测试结果
</span></span><span style=display:flex><span>25
</span></span></code></pre></div></li><li><p><strong>但是，给一个实例绑定的方法，对另一个实例是不起作用的：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; s2 = Student() # 创建新的实例
</span></span><span style=display:flex><span>&gt;&gt;&gt; s2.set_age(25) # 尝试调用方法
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
</span></span><span style=display:flex><span>AttributeError: &#39;Student&#39; object has no attribute &#39;set_age
</span></span></code></pre></div></li><li><p>为了给所有实例都绑定方法，可以给<code>class</code>绑定方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; def set_score(self, score):
</span></span><span style=display:flex><span>...     self.score = score
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; Student.set_score = set_score
</span></span></code></pre></div></li><li><p>给<code>class</code>绑定方法后，所有实例均可调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; s.set_score(100)
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.score
</span></span><span style=display:flex><span>100
</span></span><span style=display:flex><span>&gt;&gt;&gt; s2.set_score(99)
</span></span><span style=display:flex><span>&gt;&gt;&gt; s2.score
</span></span><span style=display:flex><span>99
</span></span></code></pre></div></li><li><p><em><strong>通常情况下，上面的<code>set_score</code>方法可以直接定义在<code>class</code>中，但动态绑定允许我们在程序运行的过程中动态给<code>class</code>加上功能，这在静态语言中很难实现</strong></em></p></li></ul></li><li><p>**想要限制实例的属性**怎么办？比如：只允许对Student实例添加<code>name</code>和<code>age</code>属性。</p><ul><li><p>达到限制，Python允许在定义<code>class</code>的时候，定义一个特殊的<code>__slots__</code>变量</p></li><li><p>限制该<code>class</code>实例能添加的属性：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    __slots__ <span style=color:#f92672>=</span> (<span style=color:#e6db74>&#39;name&#39;</span>, <span style=color:#e6db74>&#39;age&#39;</span>) <span style=color:#75715e># 用tuple定义允许绑定的属性名称</span>
</span></span></code></pre></div></li><li><p>由于<code>'score'</code>没有被放到<code>__slots__</code>中，所以不能绑定<code>score</code>属性，试图绑定<code>score</code>将得到<code>AttributeError</code>的错误。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; s = Student() # 创建新的实例
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.name = &#39;Michael&#39; # 绑定属性&#39;name&#39;
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.age = 25 # 绑定属性&#39;age&#39;
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.score = 99 # 绑定属性&#39;score&#39;
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
</span></span><span style=display:flex><span>AttributeError: &#39;Student&#39; object has no attribute &#39;score&#39;
</span></span></code></pre></div></li><li><p><em><strong>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</strong></em>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; class GraduateStudent(Student):
</span></span><span style=display:flex><span>...     pass
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; g = GraduateStudent()
</span></span><span style=display:flex><span>&gt;&gt;&gt; g.score = 9999
</span></span></code></pre></div></li></ul></li></ul></li><li><h3 id=使用property>使用@property<a hidden class=anchor aria-hidden=true href=#使用property>#</a></h3><ul><li><p>通常情况，绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>s <span style=color:#f92672>=</span> Student()
</span></span><span style=display:flex><span>s<span style=color:#f92672>.</span>score <span style=color:#f92672>=</span> <span style=color:#ae81ff>9999</span>
</span></span></code></pre></div><p>不合逻辑。为限制<code>score</code>，可以通过<code>set_score()</code>设置成绩，再通过<code>get_score()</code>来获取成绩，这样，在<code>set_score()</code>方法里，就可以检查参数</p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_score</span>(self):
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_score
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>set_score</span>(self, value):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> isinstance(value, int):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#39;score must be an integer!&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> value <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>or</span> value <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#39;score must between 0 ~ 100!&#39;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_score <span style=color:#f92672>=</span> value
</span></span></code></pre></div><p>现在，对任意的<code>Student</code>实例进行操作，就不能随心所欲地设置<code>score</code></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; s = Student()
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.set_score(60) # ok!
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.get_score()
</span></span><span style=display:flex><span>60
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.set_score(9999)
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>ValueError: score must between 0 ~ 100!
</span></span></code></pre></div></li></ul></li><li><p>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量？</p></li><li><p>对类的方法，装饰器起作用。Python内置<code>@property</code>装饰器负责把方法变属性调用</p><ul><li><p><strong>把一个getter方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>score</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_score
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@score.setter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>score</span>(self, value):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> isinstance(value, int):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#39;score must be an integer!&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> value <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>or</span> value <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#39;score must between 0 ~ 100!&#39;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_score <span style=color:#f92672>=</span> value
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; s = Student()
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.score(60)
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.score # OK，实际转化为s.score()
</span></span><span style=display:flex><span>60
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.score = 9999
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>ValueError: score must between 0 ~ 100!
</span></span></code></pre></div></li><li><p><strong>注意<code>@property</code>，在对实例属性操作时，是通过getter和setter方法来实现</strong></p></li><li><p>可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>birth</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_birth
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@birth.setter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>birth</span>(self, value):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_birth <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>age</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2015</span> <span style=color:#f92672>-</span> self<span style=color:#f92672>.</span>_birth
</span></span></code></pre></div><p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个<em><strong>只读</strong></em>属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来</p></li><li><p><em><strong>要特别注意：属性的方法名不要和实例变量重名。例如，以下的代码是错误的：</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#75715e># 方法名称和实例变量均为birth:</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>birth</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>birth
</span></span></code></pre></div><p>因调用<code>s.birth</code>，先转换方法调用，在执行<code>return self.birth</code>，又视访问<code>self</code>属性，又转换调用<code>self.birth()</code>，造成无限递归，导致栈溢出<code>RecursionError</code></p></li></ul></li></ul></li><li><h3 id=多重继承>多重继承<a hidden class=anchor aria-hidden=true href=#多重继承>#</a></h3><ul><li><p>通常情况分析，<code>Animal</code>类层次的设计，假设我们要实现以下4种动物：</p><ul><li>Dog - 狗狗；</li><li>Bat - 蝙蝠；</li><li>Parrot - 鹦鹉；</li><li>Ostrich - 鸵鸟。</li></ul><p>如果按照哺乳动物和鸟类归类，我们可以设计出这样的类的层次：</p><pre tabindex=0><code>                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Mammal    │           │    Bird     │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Bat   │  │ Parrot  │  │ Ostrich │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
</code></pre><p>是如果按照“能跑”和“能飞”来归类，我们就应该设计出这样的类的层次：</p><pre tabindex=0><code>                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │  Runnable   │           │   Flyable   │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │ Ostrich │  │ Parrot  │  │   Bat   │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
</code></pre><p>如果要把上面的两种分类都包含进来，我们就得设计更多的层次：</p><ul><li>哺乳类：能跑的哺乳类，能飞的哺乳类；</li><li>鸟类：能跑的鸟类，能飞的鸟类。</li></ul><p>这么一来，类的层次就复杂了：</p><pre tabindex=0><code>                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Mammal    │           │    Bird     │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│  MRun   │  │  MFly   │  │  BRun   │  │  BFly   │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
     │            │            │            │
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Bat   │  │ Ostrich │  │ Parrot  │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
</code></pre></li><li><p>正确的做法是采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 大类:</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Mammal</span>(Animal):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bird</span>(Animal):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 各种动物:</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span>(Mammal):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bat</span>(Mammal):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Parrot</span>(Bird):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ostrich</span>(Bird):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div><p>我们要给动物再加上<code>Runnable</code>和<code>Flyable</code>的功能</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Runnable</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;Running...&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Flyable</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fly</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;Flying...&#39;</span>)
</span></span></code></pre></div><ul><li><p>对于需要<code>Runnable</code>功能的动物，就多继承一个<code>Runnable</code>，例如<code>Dog</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span>(Mammal, Runnable):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div></li><li><p>对于需要<code>Flyable</code>功能的动物，就多继承一个<code>Flyable</code>，例如<code>Bat</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bat</span>(Mammal, Flyable):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div></li></ul></li><li><p><strong>Mixln</strong></p><ul><li><p>定义：<strong>设计类的继承关系时，通常，主线都是单一继承下来的</strong>，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，<strong>如果需要“混入”额外的功能，通过多重继承就可以实现</strong>，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code></p></li><li><p>目的：给一个类增加多个功能，在设计类的时候，优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系</p></li><li><p><strong>为了更好地看出继承关系</strong>，我们把<code>Runnable</code>和<code>Flyable</code>改为<code>RunnableMixIn</code>和<code>FlyableMixIn</code>。类似的，你还可以定义出肉食动物<code>CarnivorousMixIn</code>和植食动物<code>HerbivoresMixIn</code>，让某个动物同时拥有好几个MixIn：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span>(Mammal, RunnableMixIn, CarnivorousMixIn):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div></li></ul></li></ul></li><li><h3 id=定制类>定制类<a hidden class=anchor aria-hidden=true href=#定制类>#</a></h3><ul><li><p><code>__str__</code></p><ul><li><p>先定义一个<code>Student</code>类，打印一个实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; class Student(object):
</span></span><span style=display:flex><span>...     def __init__(self, name):
</span></span><span style=display:flex><span>...         self.name = name
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(Student(&#39;Michael&#39;))
</span></span><span style=display:flex><span>&lt;__main__.Student object at 0x109afb190&gt;
</span></span></code></pre></div></li><li><p>只需要定义好<code>__str__()</code>方法，返回一个好看的字符串就可以了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; class Student(object):
</span></span><span style=display:flex><span>...     def __init__(self, name):
</span></span><span style=display:flex><span>...         self.name = name
</span></span><span style=display:flex><span>...     def __str__(self):
</span></span><span style=display:flex><span>...         return &#39;Student object (name: %s)&#39; % self.name
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(Student(&#39;Michael&#39;))
</span></span><span style=display:flex><span>Student object (name: Michael)
</span></span></code></pre></div></li><li><p>细心的朋友会发现直接敲变量不用<code>print</code>，打印出来的实例还是不好看：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; s = Student(&#39;Michael&#39;)
</span></span><span style=display:flex><span>&gt;&gt;&gt; s
</span></span><span style=display:flex><span>&lt;__main__.Student object at 0x109afb310&gt;
</span></span></code></pre></div></li><li><p><strong>因直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者区别是<code>__str__()</code>返回用户看到的字符串，<code>__repr__()</code>返回程序开发者看到的字符串，<code>__repr__()</code>是为调试服务的。</strong></p><p>解决办法是再定义一个<code>__repr__()</code>。但是通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的，所以，有个偷懒的写法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __str__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;Student object (name=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>)&#39;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>name
</span></span><span style=display:flex><span>    __repr__ <span style=color:#f92672>=</span> __str__
</span></span></code></pre></div></li></ul></li><li><p><code>__iter__</code></p><ul><li><p>如果一个类想被用于<code>for ... in</code>循环，类似list或tuple那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环</p><p>以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Fib</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>a, self<span style=color:#f92672>.</span>b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span> <span style=color:#75715e># 初始化两个计数器a，b</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __iter__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self <span style=color:#75715e># 实例本身就是迭代对象，故返回自己</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __next__(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>a, self<span style=color:#f92672>.</span>b <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>b, self<span style=color:#f92672>.</span>a <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>b <span style=color:#75715e># 计算下一个值</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>a <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100000</span>: <span style=color:#75715e># 退出循环的条件</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>StopIteration</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>a <span style=color:#75715e># 返回下一个值</span>
</span></span></code></pre></div></li><li><p>Fib实例作用于for循环：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; for n in Fib():
</span></span><span style=display:flex><span>...     print(n)
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>1
</span></span><span style=display:flex><span>1
</span></span><span style=display:flex><span>2
</span></span><span style=display:flex><span>3
</span></span><span style=display:flex><span>5
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>46368
</span></span><span style=display:flex><span>75025
</span></span></code></pre></div></li></ul></li><li><p><code>__getitem__</code></p><ul><li><p>Fib实例虽能作用for循环，看起来和list像，但是，把它当成list来使用还是不行</p></li><li><p>比如，取第5个元素：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; Fib()[5]
</span></span><span style=display:flex><span>TypeError: &#39;Fib&#39; object does not support indexing
</span></span></code></pre></div></li><li><p>表现得像list那样按照下标取出元素，需要实现<code>__getitem__()</code>方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Fib</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __getitem__(self, n):
</span></span><span style=display:flex><span>        a, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>            a, b <span style=color:#f92672>=</span> b, a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a
</span></span></code></pre></div><p>现在，就可以按下标访问数列的任意一项了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; f = Fib()
</span></span><span style=display:flex><span>&gt;&gt;&gt; f[0]
</span></span><span style=display:flex><span>1
</span></span><span style=display:flex><span>&gt;&gt;&gt; f[1]
</span></span><span style=display:flex><span>1
</span></span><span style=display:flex><span>&gt;&gt;&gt; f[2]
</span></span><span style=display:flex><span>2
</span></span><span style=display:flex><span>&gt;&gt;&gt; f[3]
</span></span><span style=display:flex><span>3
</span></span><span style=display:flex><span>&gt;&gt;&gt; f[10]
</span></span><span style=display:flex><span>89
</span></span><span style=display:flex><span>&gt;&gt;&gt; f[100]
</span></span><span style=display:flex><span>573147844013817084101
</span></span></code></pre></div></li><li><p>但list有个神奇的切片方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; list(range(100))[5:10]
</span></span><span style=display:flex><span>[5, 6, 7, 8, 9]
</span></span></code></pre></div><p>对于Fib报错。因是<code>__getitem__()</code>传入参数可是<code>int</code>，也可是切片对象<code>slice</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Fib</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __getitem__(self, n):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> isinstance(n, int): <span style=color:#75715e># n是索引</span>
</span></span><span style=display:flex><span>            a, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>                a, b <span style=color:#f92672>=</span> b, a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> a
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> isinstance(n, slice): <span style=color:#75715e># n是切片</span>
</span></span><span style=display:flex><span>            start <span style=color:#f92672>=</span> n<span style=color:#f92672>.</span>start
</span></span><span style=display:flex><span>            stop <span style=color:#f92672>=</span> n<span style=color:#f92672>.</span>stop
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> start <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                start <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            a, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            L <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(stop):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&gt;=</span> start:
</span></span><span style=display:flex><span>                    L<span style=color:#f92672>.</span>append(a)
</span></span><span style=display:flex><span>                a, b <span style=color:#f92672>=</span> b, a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> L
</span></span></code></pre></div><p>现在试试Fib的切片：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; f = Fib()
</span></span><span style=display:flex><span>&gt;&gt;&gt; f[0:5]
</span></span><span style=display:flex><span>[1, 1, 2, 3, 5]
</span></span><span style=display:flex><span>&gt;&gt;&gt; f[:10]
</span></span><span style=display:flex><span>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</span></span></code></pre></div></li></ul></li><li><p><code>__getattr__</code></p><ul><li><p>正常情况下，调用类的方法或属性时，如不存在，就报错。比如定义<code>Student</code>类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Michael&#39;</span>
</span></span></code></pre></div><p>调用<code>name</code>属性，没问题，但是，调用不存在的<code>score</code>属性，就有问题了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; s = Student()
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(s.name)
</span></span><span style=display:flex><span>Michael
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(s.score)
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>AttributeError: &#39;Student&#39; object has no attribute &#39;score&#39;
</span></span></code></pre></div></li><li><p>避免这个错误，除了可以加上一个<code>score</code>属性外，<strong>Python还有另一个机制，那就是写一个<code>__getattr__()</code>方法，动态返回一个属性</strong>。修改如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Michael&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __getattr__(self, attr):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> attr<span style=color:#f92672>==</span><span style=color:#e6db74>&#39;score&#39;</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>99</span>
</span></span></code></pre></div><p>当调用不存在属性，比如<code>score</code>，Python解释器会试图调用<code>__getattr__(self, 'score')</code>来尝试获得属性，这样，我们就有机会返回<code>score</code>的值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; s = Student()
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.name
</span></span><span style=display:flex><span>&#39;Michael&#39;
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.score
</span></span><span style=display:flex><span>99
</span></span></code></pre></div><p>返回函数也是完全可以的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __getattr__(self, attr):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> attr<span style=color:#f92672>==</span><span style=color:#e6db74>&#39;age&#39;</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>lambda</span>: <span style=color:#ae81ff>25</span>
</span></span></code></pre></div><p>只是调用方式要变为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; s.age()
</span></span><span style=display:flex><span>25
</span></span></code></pre></div><p>注意到任意调用如<code>s.abc</code>都会返回<code>None</code>，这是因为我们定义的<code>__getattr__</code>默认返回就是<code>None</code>。要让class只响应特定的几个属性，我们就要按照约定，抛出<code>AttributeError</code>的错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __getattr__(self, attr):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> attr<span style=color:#f92672>==</span><span style=color:#e6db74>&#39;age&#39;</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>lambda</span>: <span style=color:#ae81ff>25</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>AttributeError</span>(<span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>Student</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74> object has no attribute </span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>%s</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> attr)
</span></span></code></pre></div></li><li><p><strong><em>只有在没有找到属性的情况下，才调用<code>__getattr__</code></em></strong></p></li><li><p>使用举例</p><ul><li><p>很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p><ul><li><a href=http://api.server/user/friends>http://api.server/user/friends</a></li></ul></li><li><p>要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p><p>利用完全动态的<code>__getattr__</code>，我们可以写出一个链式调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Chain</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, path<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;&#39;</span>):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_path <span style=color:#f92672>=</span> path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __getattr__(self, path):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Chain(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>/</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> (self<span style=color:#f92672>.</span>_path, path))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __str__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    __repr__ <span style=color:#f92672>=</span> __str__
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; Chain().status.user.timeline.list
</span></span><span style=display:flex><span>&#39;/status/user/timeline/list&#39;
</span></span></code></pre></div></li></ul></li></ul></li><li><p><code>__call__</code></p><ul><li><p>实例有自己的属性和方法，当我们调用实例方法，可<code>instance.method()</code>调用</p></li><li><p><strong>任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用</strong></p><ul><li>请看示例：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __call__(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;My name is </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>.&#39;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>name)
</span></span></code></pre></div><p>调用方式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; s = Student(&#39;Michael&#39;)
</span></span><span style=display:flex><span>&gt;&gt;&gt; s() # self参数不要传入
</span></span><span style=display:flex><span>My name is Michael.
</span></span></code></pre></div></li></ul></li></ul></li><li><h3 id=枚举类>枚举类<a hidden class=anchor aria-hidden=true href=#枚举类>#</a></h3><ul><li><p>需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> enum <span style=color:#f92672>import</span> Enum, unique
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@unique</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Weekday</span>(Enum):
</span></span><span style=display:flex><span>    Sun <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e># Sun的value被设定为0</span>
</span></span><span style=display:flex><span>    Mon <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    Tue <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    Wed <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>    Thu <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>    Fri <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>    Sat <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>
</span></span></code></pre></div><p><code>@unique</code>装饰器可以帮助我们检查保证没有重复值。</p><p>访问这些枚举类型可以有若干种方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; day1 = Weekday.Mon
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(day1)
</span></span><span style=display:flex><span>Weekday.Mon
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(Weekday.Tue)
</span></span><span style=display:flex><span>Weekday.Tue
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(Weekday[&#39;Tue&#39;])
</span></span><span style=display:flex><span>Weekday.Tue
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(Weekday.Tue.value)
</span></span><span style=display:flex><span>2
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(day1 == Weekday.Mon)
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(day1 == Weekday.Tue)
</span></span><span style=display:flex><span>False
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(Weekday(1))
</span></span><span style=display:flex><span>Weekday.Mon
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(day1 == Weekday(1))
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; Weekday(7)
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>ValueError: 7 is not a valid Weekday
</span></span><span style=display:flex><span>&gt;&gt;&gt; for name, member in Weekday.__members__.items():
</span></span><span style=display:flex><span>...     print(name, &#39;=&gt;&#39;, member)
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>Sun =&gt; Weekday.Sun
</span></span><span style=display:flex><span>Mon =&gt; Weekday.Mon
</span></span><span style=display:flex><span>Tue =&gt; Weekday.Tue
</span></span><span style=display:flex><span>Wed =&gt; Weekday.Wed
</span></span><span style=display:flex><span>Thu =&gt; Weekday.Thu
</span></span><span style=display:flex><span>Fri =&gt; Weekday.Fri
</span></span><span style=display:flex><span>Sat =&gt; Weekday.Sat
</span></span></code></pre></div><p>可见，既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量</p></li></ul></li><li><h4 id=使用元类还没有记录>使用元类（还没有记录）<a hidden class=anchor aria-hidden=true href=#使用元类还没有记录>#</a></h4></li></ul><h3 id=错误调试和测试>错误调试和测试<a hidden class=anchor aria-hidden=true href=#错误调试和测试>#</a></h3><ul><li><p>错误：</p><ul><li>程序编写有问题造成：比如本来应该输出整数结果输出了字符串，这种错误我们通常称之为bug，bug是必须修复的。</li><li>有的错误是用户输入造成：比如让用户输入email地址，结果得到一个空字符串，这种错误可以通过检查用户输入来做相应的处理</li><li>还有错误是完全无法在程序运行过程中预测：比如写入文件的时候，磁盘满了，写不进去了，这类错误也称为异常，在程序中通常是必须处理的</li></ul></li><li><h4 id=错误处理>错误处理<a hidden class=anchor aria-hidden=true href=#错误处理>#</a></h4><ul><li><p><strong>程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码</strong>，在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数<code>open()</code>，成功时返回文件描述符（就是一个整数），出错时返回<code>-1</code></p></li><li><p><code>try</code>机制</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;try...&#39;</span>)
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;result:&#39;</span>, r)
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ZeroDivisionError</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;except:&#39;</span>, e)
</span></span><span style=display:flex><span><span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;finally...&#39;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#39;END&#39;</span>)
</span></span></code></pre></div><p>当认为某些代码可能会出错，可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>try...
</span></span><span style=display:flex><span>except: division by zero
</span></span><span style=display:flex><span>finally...
</span></span><span style=display:flex><span>END
</span></span></code></pre></div></li><li><p>此外，如果没有错误发生，可以在<code>except</code>语句块后面加一个<code>else</code>，当没有错误发生时，会自动执行<code>else</code>语句：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;try...&#39;</span>)
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>/</span> int(<span style=color:#e6db74>&#39;2&#39;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;result:&#39;</span>, r)
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ValueError</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;ValueError:&#39;</span>, e)
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ZeroDivisionError</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;ZeroDivisionError:&#39;</span>, e)
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;no error!&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;finally...&#39;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#39;END&#39;</span>)
</span></span></code></pre></div></li><li><p>Python的错误其实也是class，所有的错误类型都继承自<code>BaseException</code>，所以使用<code>except</code>时需要注意，它不但捕获该类型错误，还把其子类也“一网打尽”。比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    foo()
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ValueError</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;ValueError&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>UnicodeError</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;UnicodeError&#39;</span>)
</span></span></code></pre></div><p>第二个<code>except</code>永远也捕获不到<code>UnicodeError</code>，因为<code>UnicodeError</code>是<code>ValueError</code>的子类，如果有，也被第一个<code>except</code>给捕获了</p></li><li><p>Python所有错误都从<code>BaseException</code>类派生，常见错误类型和继承关系：</p><p><a href=https://docs.python.org/3/library/exceptions.html#exception-hierarchy>https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a></p></li><li><p><code>try...except</code>捕获错误还有一个巨大的好处，可以跨越多层调用</p><p>比如函数<code>main()</code>调用<code>bar()</code>，<code>bar()</code>调用<code>foo()</code>，结果<code>foo()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(s):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>/</span> int(s)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bar</span>(s):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> foo(s) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        bar(<span style=color:#e6db74>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;Error:&#39;</span>, e)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;finally...&#39;</span>)
</span></span></code></pre></div><p>不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写<code>try...except...finally</code>的麻烦</p></li></ul></li><li><p>调用栈机制</p><ul><li><p>如果错误没有被捕获，会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。来看看<code>err.py</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># err.py:</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(s):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>/</span> int(s)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bar</span>(s):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> foo(s) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    bar(<span style=color:#e6db74>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main()
</span></span></code></pre></div><p>执行，结果如下：<strong>每个调用错误都显示，最后才有结果</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ python3 err.py
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File &#34;err.py&#34;, line 11, in &lt;module&gt;
</span></span><span style=display:flex><span>    main()
</span></span><span style=display:flex><span>  File &#34;err.py&#34;, line 9, in main
</span></span><span style=display:flex><span>    bar(&#39;0&#39;)
</span></span><span style=display:flex><span>  File &#34;err.py&#34;, line 6, in bar
</span></span><span style=display:flex><span>    return foo(s) * 2
</span></span><span style=display:flex><span>  File &#34;err.py&#34;, line 3, in foo
</span></span><span style=display:flex><span>    return 10 / int(s)
</span></span><span style=display:flex><span>ZeroDivisionError: division by zero
</span></span></code></pre></div><p><strong>出错并不可怕，可怕的是不知道哪里出错了。解读错误信息是定位错误的关键。</strong></p></li></ul></li><li><p>记录错误</p><ul><li><p>不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束</p></li><li><p>既然能捕获错误，就可把错误堆栈打印，然后分析错误原因，让程序继续执行下去</p><p><strong>Python内置的<code>logging</code>模块可以非常容易地记录错误信息：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> logging
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(s):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>/</span> int(s)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bar</span>(s):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> foo(s) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        bar(<span style=color:#e6db74>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        logging<span style=color:#f92672>.</span>exception(e)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main()
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#39;END&#39;</span>)
</span></span></code></pre></div><p><strong>同样是出错，但程序打印完错误信息后会继续执行，<em>并正常退出</em></strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ python3 err_logging.py
</span></span><span style=display:flex><span>ERROR:root:division by zero
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File &#34;err_logging.py&#34;, line 13, in main
</span></span><span style=display:flex><span>    bar(&#39;0&#39;)
</span></span><span style=display:flex><span>  File &#34;err_logging.py&#34;, line 9, in bar
</span></span><span style=display:flex><span>    return foo(s) * 2
</span></span><span style=display:flex><span>  File &#34;err_logging.py&#34;, line 6, in foo
</span></span><span style=display:flex><span>    return 10 / int(s)
</span></span><span style=display:flex><span>ZeroDivisionError: division by zero
</span></span><span style=display:flex><span>END
</span></span></code></pre></div><p><strong>通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查</strong></p></li></ul></li><li><p><code>raise</code>抛出错误：自己编写函数作为也可以抛出错误</p><ul><li><p>首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用<code>raise</code>语句抛出一个错误的实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FooError</span>(<span style=color:#a6e22e>ValueError</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(s):
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> int(s)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> FooError(<span style=color:#e6db74>&#39;invalid value: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> s)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>/</span> n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>foo(<span style=color:#e6db74>&#39;0&#39;</span>)
</span></span></code></pre></div><p>执行，可以最后跟踪到我们自己定义的错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ python3 err_raise.py 
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File &#34;err_throw.py&#34;, line 11, in &lt;module&gt;
</span></span><span style=display:flex><span>    foo(&#39;0&#39;)
</span></span><span style=display:flex><span>  File &#34;err_throw.py&#34;, line 8, in foo
</span></span><span style=display:flex><span>    raise FooError(&#39;invalid value: %s&#39; % s)
</span></span><span style=display:flex><span>__main__.FooError: invalid value: 0
</span></span></code></pre></div></li><li><p>另一种错误处理的方式</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(s):
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> int(s)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#39;invalid value: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> s)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>/</span> n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bar</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        foo(<span style=color:#e6db74>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ValueError</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;ValueError!&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bar()
</span></span></code></pre></div><p>在<code>bar()</code>函数中，我们明明已经捕获了错误，但是，打印一个<code>ValueError!</code>后，又把错误通过<code>raise</code>语句抛出去</p><p><strong>捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理</strong></p><pre tabindex=0><code>ValueError!

Traceback (most recent call last):
  File &#34;script.py&#34;, line 14, in &lt;module&gt;
    bar()
  File &#34;script.py&#34;, line 9, in bar
    foo(&#39;0&#39;)
  File &#34;script.py&#34;, line 4, in foo
    raise ValueError(&#39;invalid value: %s&#39; % s)
ValueError: invalid value: 0

Exited with error status 1
</code></pre><ul><li><p><code>raise</code>语句不带参数，会把当前错误原样抛出。此外，<code>except</code>中<code>raise</code>一个Error，还可以把一种类型的错误转化成另一种类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>10</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ZeroDivisionError</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#39;input error!&#39;</span>)
</span></span></code></pre></div><p>只要是合理的转换逻辑就可以，但是，决不应该把一个<code>IOError</code>转换成毫不相干的<code>ValueError</code></p></li></ul><p><strong>若忽略<code>raise</code>运行结果如下</strong></p><pre tabindex=0><code>ValueError!
</code></pre></li></ul></li></ul></li><li><h4 id=调试>调试<a hidden class=anchor aria-hidden=true href=#调试>#</a></h4><ul><li><p>第一种简单直接，用<code>print()</code>把可能有问题的变量打印出来</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(s):
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> int(s)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;&gt;&gt;&gt; n = </span><span style=color:#e6db74>%d</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> n)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>/</span> n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    foo(<span style=color:#e6db74>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ python err.py
</span></span><span style=display:flex><span>&gt;&gt;&gt; n = 0
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>ZeroDivisionError: integer division or modulo by zero
</span></span></code></pre></div><p><code>print()</code>最大的坏处是将来还得删掉它，想想程序里到处都是<code>print()</code>，运行结果也会包含很多垃圾信息</p></li><li><p>断言<code>assert</code></p><ul><li><p>用<code>print()</code>来辅助查看的地方，都可以用断言（assert）来替代：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(s):
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> int(s)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> n <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#39;n is zero!&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>/</span> n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    foo(<span style=color:#e6db74>&#39;0&#39;</span>)
</span></span></code></pre></div></li><li><p><strong><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code></strong>，否则，根据程序运行的逻辑，后面的代码肯定会出错</p></li><li><p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code></p></li><li><p>程序中到处充斥<code>assert</code>，启动Python解释器时可以用<code>-O</code>参数来关闭<code>assert</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ python -O err.py
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>ZeroDivisionError: division by zero
</span></span></code></pre></div><p><em><strong>断言的开关“-O”是英文大写字母O，不是数字0。</strong></em></p><p>关闭后，你可以把所有的<code>assert</code>语句当成<code>pass</code>来看</p></li></ul></li><li><p><code>logging</code></p><ul><li><p><code>logging</code>不会抛出错误，而且可以输出到文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> logging
</span></span><span style=display:flex><span>logging<span style=color:#f92672>.</span>basicConfig(level<span style=color:#f92672>=</span>logging<span style=color:#f92672>.</span>INFO)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;0&#39;</span>
</span></span><span style=display:flex><span>n <span style=color:#f92672>=</span> int(s)
</span></span><span style=display:flex><span>logging<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#39;n = </span><span style=color:#e6db74>%d</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> n)
</span></span><span style=display:flex><span>print(<span style=color:#ae81ff>10</span> <span style=color:#f92672>/</span> n)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ python err.py
</span></span><span style=display:flex><span>INFO:root:n = 0
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File &#34;err.py&#34;, line 8, in &lt;module&gt;
</span></span><span style=display:flex><span>    print(10 / n)
</span></span><span style=display:flex><span>ZeroDivisionError: division by zero
</span></span></code></pre></div><p><strong><code>logging</code>好处，允许指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息</strong></p></li></ul></li><li><p><code>pdb</code></p><ul><li><p>启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态</p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># err.py</span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;0&#39;</span>
</span></span><span style=display:flex><span>n <span style=color:#f92672>=</span> int(s)
</span></span><span style=display:flex><span>print(<span style=color:#ae81ff>10</span> <span style=color:#f92672>/</span> n)
</span></span></code></pre></div></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ python -m pdb err.py
</span></span><span style=display:flex><span>&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()
</span></span><span style=display:flex><span>-&gt; s = &#39;0&#39;
</span></span></code></pre></div><p>参数<code>-m pdb</code>启动后，pdb定位下一步要执行的<code>-> s = '0'</code>。输入命令<code>l</code>来查看</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>(Pdb) l
</span></span><span style=display:flex><span>  1     # err.py
</span></span><span style=display:flex><span>  2  -&gt; s = &#39;0&#39;
</span></span><span style=display:flex><span>  3     n = int(s)
</span></span><span style=display:flex><span>  4     print(10 / n)
</span></span></code></pre></div></li><li><p>输入命令<code>n</code>可以单步执行代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>(Pdb) n
</span></span><span style=display:flex><span>&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(3)&lt;module&gt;()
</span></span><span style=display:flex><span>-&gt; n = int(s)
</span></span><span style=display:flex><span>(Pdb) n
</span></span><span style=display:flex><span>&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(4)&lt;module&gt;()
</span></span><span style=display:flex><span>-&gt; print(10 / n)
</span></span></code></pre></div></li><li><p>任何时候都可以输入命令<code>p 变量名</code>来查看变量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>(Pdb) p s
</span></span><span style=display:flex><span>&#39;0&#39;
</span></span><span style=display:flex><span>(Pdb) p n
</span></span><span style=display:flex><span>0
</span></span></code></pre></div></li><li><p>输入命令<code>q</code>结束调试，退出程序：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>(Pdb) q
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=单元测试>单元测试<a hidden class=anchor aria-hidden=true href=#单元测试>#</a></h4><ul><li><p>测试驱动的开发模式的好处是<strong>确保程序模块的行为符合我们设计的测试用例</strong></p></li><li><p>举例<code>mydict.py</code>代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dict</span>(dict):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, <span style=color:#f92672>**</span>kw):
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>__init__(<span style=color:#f92672>**</span>kw)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __getattr__(self, key):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self[key]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyError</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>AttributeError</span>(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;&#39;Dict&#39; object has no attribute &#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;&#34;</span> <span style=color:#f92672>%</span> key)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __setattr__(self, key, value):
</span></span><span style=display:flex><span>        self[key] <span style=color:#f92672>=</span> value
</span></span></code></pre></div><p>为了编写单元测试，我们需要引入Python自带的<code>unittest</code>模块，编写<code>mydict_test.py</code>如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> unittest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> mydict <span style=color:#f92672>import</span> Dict
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestDict</span>(unittest<span style=color:#f92672>.</span>TestCase):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_init</span>(self):
</span></span><span style=display:flex><span>        d <span style=color:#f92672>=</span> Dict(a<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, b<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;test&#39;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>assertEqual(d<span style=color:#f92672>.</span>a, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>assertEqual(d<span style=color:#f92672>.</span>b, <span style=color:#e6db74>&#39;test&#39;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>assertTrue(isinstance(d, dict))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_key</span>(self):
</span></span><span style=display:flex><span>        d <span style=color:#f92672>=</span> Dict()
</span></span><span style=display:flex><span>        d[<span style=color:#e6db74>&#39;key&#39;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;value&#39;</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>assertEqual(d<span style=color:#f92672>.</span>key, <span style=color:#e6db74>&#39;value&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_attr</span>(self):
</span></span><span style=display:flex><span>        d <span style=color:#f92672>=</span> Dict()
</span></span><span style=display:flex><span>        d<span style=color:#f92672>.</span>key <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;value&#39;</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>assertTrue(<span style=color:#e6db74>&#39;key&#39;</span> <span style=color:#f92672>in</span> d)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>assertEqual(d[<span style=color:#e6db74>&#39;key&#39;</span>], <span style=color:#e6db74>&#39;value&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_keyerror</span>(self):
</span></span><span style=display:flex><span>        d <span style=color:#f92672>=</span> Dict()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>assertRaises(<span style=color:#a6e22e>KeyError</span>):
</span></span><span style=display:flex><span>            value <span style=color:#f92672>=</span> d[<span style=color:#e6db74>&#39;empty&#39;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_attrerror</span>(self):
</span></span><span style=display:flex><span>        d <span style=color:#f92672>=</span> Dict()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>assertRaises(<span style=color:#a6e22e>AttributeError</span>):
</span></span><span style=display:flex><span>            value <span style=color:#f92672>=</span> d<span style=color:#f92672>.</span>empty
</span></span></code></pre></div></li><li><p><strong>解释</strong></p><p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承。</p><p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p><p>对每一类测试都需要编写一个<code>test_xxx()</code>方法。由于<code>unittest.TestCase</code>提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是<code>assertEqual()</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>self<span style=color:#f92672>.</span>assertEqual(abs(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>), <span style=color:#ae81ff>1</span>) <span style=color:#75715e># 断言函数返回的结果与1相等</span>
</span></span></code></pre></div><p>另一种重要的断言就是期待抛出指定类型的Error，比如通过<code>d['empty']</code>访问不存在的key时，断言会抛出<code>KeyError</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>assertRaises(<span style=color:#a6e22e>KeyError</span>):
</span></span><span style=display:flex><span>    value <span style=color:#f92672>=</span> d[<span style=color:#e6db74>&#39;empty&#39;</span>]
</span></span></code></pre></div></li><li><p>运行单元测试</p><ul><li><strong>最简单的运行方式</strong>是在<code>mydict_test.py</code>的最后加上两行代码：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    unittest<span style=color:#f92672>.</span>main()
</span></span></code></pre></div><p>就可以把<code>mydict_test.py</code>当做正常的python脚本运行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ python mydict_test.py
</span></span></code></pre></div><ul><li><strong>另一种方法</strong>是在命令行通过参数<code>-m unittest</code>直接运行单元测试：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ python -m unittest mydict_test
</span></span><span style=display:flex><span>.....
</span></span><span style=display:flex><span>----------------------------------------------------------------------
</span></span><span style=display:flex><span>Ran 5 tests in 0.000s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>OK
</span></span></code></pre></div><p><strong>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试</strong></p></li><li><p><code>setUp()</code>和<code>tearDown()</code></p><p>这两个方法会分别在每调用一个测试方法的前后分别被执行</p><p>设想你的测试需要启动一个数据库，这时，就可以在<code>setUp()</code>方法中连接数据库，在<code>tearDown()</code>方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestDict</span>(unittest<span style=color:#f92672>.</span>TestCase):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>setUp</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;setUp...&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>tearDown</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;tearDown...&#39;</span>)
</span></span></code></pre></div><p>再次运行看看每个测试方法调用前后是否会打印出<code>setUp...</code>和<code>tearDown...</code></p></li></ul></li><li><h4 id=文档测试>文档测试<a hidden class=anchor aria-hidden=true href=#文档测试>#</a></h4><ul><li><p><strong>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试</strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># mydict2.py</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dict</span>(dict):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Simple dict but also support access as x.y style.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &gt;&gt;&gt; d1 = Dict()
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &gt;&gt;&gt; d1[&#39;x&#39;] = 100
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &gt;&gt;&gt; d1.x
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    100
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &gt;&gt;&gt; d1.y = 200
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &gt;&gt;&gt; d1[&#39;y&#39;]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    200
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&#39;3&#39;)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &gt;&gt;&gt; d2.c
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#39;3&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &gt;&gt;&gt; d2[&#39;empty&#39;]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Traceback (most recent call last):
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ...
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    KeyError: &#39;empty&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &gt;&gt;&gt; d2.empty
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Traceback (most recent call last):
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        ...
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    AttributeError: &#39;Dict&#39; object has no attribute &#39;empty&#39;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, <span style=color:#f92672>**</span>kw):
</span></span><span style=display:flex><span>        super(Dict, self)<span style=color:#f92672>.</span>__init__(<span style=color:#f92672>**</span>kw)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __getattr__(self, key):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self[key]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyError</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>AttributeError</span>(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;&#39;Dict&#39; object has no attribute &#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;&#34;</span> <span style=color:#f92672>%</span> key)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __setattr__(self, key, value):
</span></span><span style=display:flex><span>        self[key] <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__<span style=color:#f92672>==</span><span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> doctest
</span></span><span style=display:flex><span>    doctest<span style=color:#f92672>.</span>testmod()
</span></span></code></pre></div><p>运行<code>python mydict2.py</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ python mydict2.py
</span></span></code></pre></div><p>什么输出也没有。这说明我们编写的doctest运行都是正确的。如果程序有问题，比如把<code>__getattr__()</code>方法注释掉，再运行就会报错：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ python mydict2.py
</span></span><span style=display:flex><span>**********************************************************************
</span></span><span style=display:flex><span>File &#34;/Users/michael/Github/learn-python3/samples/debug/mydict2.py&#34;, line 10, in __main__.Dict
</span></span><span style=display:flex><span>Failed example:
</span></span><span style=display:flex><span>    d1.x
</span></span><span style=display:flex><span>Exception raised:
</span></span><span style=display:flex><span>    Traceback (most recent call last):
</span></span><span style=display:flex><span>      ...
</span></span><span style=display:flex><span>    AttributeError: &#39;Dict&#39; object has no attribute &#39;x&#39;
</span></span><span style=display:flex><span>**********************************************************************
</span></span><span style=display:flex><span>File &#34;/Users/michael/Github/learn-python3/samples/debug/mydict2.py&#34;, line 16, in __main__.Dict
</span></span><span style=display:flex><span>Failed example:
</span></span><span style=display:flex><span>    d2.c
</span></span><span style=display:flex><span>Exception raised:
</span></span><span style=display:flex><span>    Traceback (most recent call last):
</span></span><span style=display:flex><span>      ...
</span></span><span style=display:flex><span>    AttributeError: &#39;Dict&#39; object has no attribute &#39;c&#39;
</span></span><span style=display:flex><span>**********************************************************************
</span></span><span style=display:flex><span>1 items had failures:
</span></span><span style=display:flex><span>   2 of   9 in __main__.Dict
</span></span><span style=display:flex><span>***Test Failed*** 2 failures.
</span></span></code></pre></div><p>注意到最后3行代码。当模块正常导入时，<code>doctest</code>不会被执行。只有在命令行直接运行时，才执行<code>doctest</code>。所以，不必担心<code>doctest</code>会在非测试环境下执行</p></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/python/>Python</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/java01/><span class=title>« Prev Page</span><br><span>Java中级</span>
</a><a class=next href=https://zwlzls.github.io/posts/python01/><span class=title>Next Page »</span><br><span>Python中级</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>