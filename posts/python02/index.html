<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python02 | 我的博客</title>
<meta name=keywords content="Python"><meta name=description content="Python高级 面向对象编程 以一个例子来说明面向过程和面向对象在程序流程上的不同之处
假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：
std1 = { 'name': 'Michael', 'score': 98 } std2 = { 'name': 'Bob', 'score': 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩：
def print_score(std): print('%s: %s' % (std['name'], std['score'])) 面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来
class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：
bart = Student('Bart Simpson', 59) lisa = Student('Lisa Simpson', 87) bart.print_score() lisa.print_score() 类和实例 类是抽象的模板，实例是类创建的一个个具体的“对象”
和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数
定义类是通过class关键字：
class Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，没有合适的继承类，就使用object类，是所有类最终都会继承的类
由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去："><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/python02/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/python02/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Python02"><meta property="og:description" content="Python高级 面向对象编程 以一个例子来说明面向过程和面向对象在程序流程上的不同之处
假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：
std1 = { 'name': 'Michael', 'score': 98 } std2 = { 'name': 'Bob', 'score': 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩：
def print_score(std): print('%s: %s' % (std['name'], std['score'])) 面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来
class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：
bart = Student('Bart Simpson', 59) lisa = Student('Lisa Simpson', 87) bart.print_score() lisa.print_score() 类和实例 类是抽象的模板，实例是类创建的一个个具体的“对象”
和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数
定义类是通过class关键字：
class Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，没有合适的继承类，就使用object类，是所有类最终都会继承的类
由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去："><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/python02/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-17T15:14:04+08:00"><meta property="article:modified_time" content="2025-01-17T15:14:04+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python02"><meta name=twitter:description content="Python高级 面向对象编程 以一个例子来说明面向过程和面向对象在程序流程上的不同之处
假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：
std1 = { 'name': 'Michael', 'score': 98 } std2 = { 'name': 'Bob', 'score': 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩：
def print_score(std): print('%s: %s' % (std['name'], std['score'])) 面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来
class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：
bart = Student('Bart Simpson', 59) lisa = Student('Lisa Simpson', 87) bart.print_score() lisa.print_score() 类和实例 类是抽象的模板，实例是类创建的一个个具体的“对象”
和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数
定义类是通过class关键字：
class Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，没有合适的继承类，就使用object类，是所有类最终都会继承的类
由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python02","item":"https://zwlzls.github.io/posts/python02/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python02","name":"Python02","description":"Python高级 面向对象编程 以一个例子来说明面向过程和面向对象在程序流程上的不同之处\n假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：\nstd1 = { \u0026#39;name\u0026#39;: \u0026#39;Michael\u0026#39;, \u0026#39;score\u0026#39;: 98 } std2 = { \u0026#39;name\u0026#39;: \u0026#39;Bob\u0026#39;, \u0026#39;score\u0026#39;: 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩：\ndef print_score(std): print(\u0026#39;%s: %s\u0026#39; % (std[\u0026#39;name\u0026#39;], std[\u0026#39;score\u0026#39;])) 面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来\nclass Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print(\u0026#39;%s: %s\u0026#39; % (self.name, self.score)) 给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：\nbart = Student(\u0026#39;Bart Simpson\u0026#39;, 59) lisa = Student(\u0026#39;Lisa Simpson\u0026#39;, 87) bart.print_score() lisa.print_score() 类和实例 类是抽象的模板，实例是类创建的一个个具体的“对象”\n和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数\n定义类是通过class关键字：\nclass Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，没有合适的继承类，就使用object类，是所有类最终都会继承的类\n由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：","keywords":["Python"],"articleBody":"Python高级 面向对象编程 以一个例子来说明面向过程和面向对象在程序流程上的不同之处\n假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：\nstd1 = { 'name': 'Michael', 'score': 98 } std2 = { 'name': 'Bob', 'score': 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩：\ndef print_score(std): print('%s: %s' % (std['name'], std['score'])) 面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来\nclass Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：\nbart = Student('Bart Simpson', 59) lisa = Student('Lisa Simpson', 87) bart.print_score() lisa.print_score() 类和实例 类是抽象的模板，实例是类创建的一个个具体的“对象”\n和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数\n定义类是通过class关键字：\nclass Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，没有合适的继承类，就使用object类，是所有类最终都会继承的类\n由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：\nclass Student(object): def __init__(self, name, score): self.name = name self.score = score 注意__init__方法第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，self就指向创建的实例本身\n有__init__方法，创建实例时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：\n\u003e\u003e\u003e bart = Student('Bart Simpson', 59) \u003e\u003e\u003e bart.name 'Bart Simpson' \u003e\u003e\u003e bart.score 59 访问限制 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__\nclass Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) \u003e\u003e\u003e bart = Student('Bart Simpson', 59) \u003e\u003e\u003e bart.__name Traceback (most recent call last): File \"\", line 1, in AttributeError: 'Student' object has no attribute '__name' 外部代码要获取name和score，给Student类增加get_name和get_score的方法：\nclass Student(object): ... def get_name(self): return self.__name def get_score(self): return self.__score 要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：\nclass Student(object): ... def set_score(self, score): self.__score = score 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：\n\u003e\u003e\u003e bart._Student__name 'Bart Simpson' 但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名\n注意下面的这种错误写法：\n\u003e\u003e\u003e bart = Student('Bart Simpson', 59) \u003e\u003e\u003e bart.get_name() 'Bart Simpson' \u003e\u003e\u003e bart.__name = 'New Name' # 设置__name变量！ \u003e\u003e\u003e bart.__name 'New Name' 表面上，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试：\n\u003e\u003e\u003e bart.get_name() # get_name()内部返回self.__name 'Bart Simpson' 继承和多态 继承：\n最大的好处是子类获得了父类的全部功能 第二个好处需要我们对代码做一点改进，子类的run()可覆盖父类的run() 如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类 多态\n当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法 静态语言VS动态语言\n静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法\nPython这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：\nclass Timer(object): def run(self): print('Start...') 这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子\n获得对象信息 当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？\n判断对象类型，使用type()函数\n基本类型都可以用type()判断：\n\u003e\u003e\u003e type(123) ","wordCount":"394","inLanguage":"en","datePublished":"2025-01-17T15:14:04+08:00","dateModified":"2025-01-17T15:14:04+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/python02/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Python02</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#python%e9%ab%98%e7%ba%a7 aria-label=Python高级>Python高级</a><ul><li><a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%bc%96%e7%a8%8b aria-label=面向对象编程>面向对象编程</a><ul><li><a href=#%e7%b1%bb%e5%92%8c%e5%ae%9e%e4%be%8b aria-label=类和实例>类和实例</a></li><li><a href=#%e8%ae%bf%e9%97%ae%e9%99%90%e5%88%b6 aria-label=访问限制>访问限制</a></li><li><a href=#%e7%bb%a7%e6%89%bf%e5%92%8c%e5%a4%9a%e6%80%81 aria-label=继承和多态>继承和多态</a></li><li><a href=#%e8%8e%b7%e5%be%97%e5%af%b9%e8%b1%a1%e4%bf%a1%e6%81%af aria-label=获得对象信息>获得对象信息</a></li><li><a href=#%e5%ae%9e%e4%be%8b%e5%b1%9e%e6%80%a7%e5%92%8c%e7%b1%bb%e5%b1%9e%e6%80%a7 aria-label=实例属性和类属性>实例属性和类属性</a></li></ul></li><li><a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e9%ab%98%e7%ba%a7%e7%bc%96%e7%a8%8b aria-label=面向对象高级编程>面向对象高级编程</a><ul><li><a href=#%e4%bd%bf%e7%94%a8__slots__ aria-label=使用__slots__>使用<code>__slots__</code></a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=python高级>Python高级<a hidden class=anchor aria-hidden=true href=#python高级>#</a></h2><h3 id=面向对象编程>面向对象编程<a hidden class=anchor aria-hidden=true href=#面向对象编程>#</a></h3><ul><li><p>以一个例子来说明<strong>面向过程</strong>和<strong>面向对象</strong>在程序流程上的不同之处</p><ul><li><p>假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>std1 <span style=color:#f92672>=</span> { <span style=color:#e6db74>&#39;name&#39;</span>: <span style=color:#e6db74>&#39;Michael&#39;</span>, <span style=color:#e6db74>&#39;score&#39;</span>: <span style=color:#ae81ff>98</span> }
</span></span><span style=display:flex><span>std2 <span style=color:#f92672>=</span> { <span style=color:#e6db74>&#39;name&#39;</span>: <span style=color:#e6db74>&#39;Bob&#39;</span>, <span style=color:#e6db74>&#39;score&#39;</span>: <span style=color:#ae81ff>81</span> }
</span></span></code></pre></div><p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_score</span>(std):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> (std[<span style=color:#e6db74>&#39;name&#39;</span>], std[<span style=color:#e6db74>&#39;score&#39;</span>]))
</span></span></code></pre></div></li><li><p>面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是<code>Student</code>这种数据类型应该被视为一个对象，这个对象拥有<code>name</code>和<code>score</code>这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name, score):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>score <span style=color:#f92672>=</span> score
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_score</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> (self<span style=color:#f92672>.</span>name, self<span style=color:#f92672>.</span>score))
</span></span></code></pre></div><p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>bart <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#39;Bart Simpson&#39;</span>, <span style=color:#ae81ff>59</span>)
</span></span><span style=display:flex><span>lisa <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#39;Lisa Simpson&#39;</span>, <span style=color:#ae81ff>87</span>)
</span></span><span style=display:flex><span>bart<span style=color:#f92672>.</span>print_score()
</span></span><span style=display:flex><span>lisa<span style=color:#f92672>.</span>print_score()
</span></span></code></pre></div></li></ul></li><li><h4 id=类和实例>类和实例<a hidden class=anchor aria-hidden=true href=#类和实例>#</a></h4><ul><li><p>类是抽象的模板，实例是类创建的一个个具体的“对象”</p></li><li><p><strong>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量<code>self</code>，并且，调用时，不用传递该参数</strong></p></li><li><p>定义类是通过<code>class</code>关键字：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div><p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，<strong>表示该类是从哪个类继承下来的</strong>，通常，没有合适的继承类，就使用<code>object</code>类，是所有类最终都会继承的类</p><p><em><strong>由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name, score):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>score <span style=color:#f92672>=</span> score
</span></span></code></pre></div><p>注意<code>__init__</code>方法第一个参数永远是<code>self</code>，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，<code>self</code>就指向创建的实例本身</p><ul><li><p>有<code>__init__</code>方法，创建实例时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器自己会把实例变量传进去：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 59)
</span></span><span style=display:flex><span>&gt;&gt;&gt; bart.name
</span></span><span style=display:flex><span>&#39;Bart Simpson&#39;
</span></span><span style=display:flex><span>&gt;&gt;&gt; bart.score
</span></span><span style=display:flex><span>59
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=访问限制>访问限制<a hidden class=anchor aria-hidden=true href=#访问限制>#</a></h4><ul><li><p><strong>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code></strong></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name, score):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__score <span style=color:#f92672>=</span> score
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_score</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> (self<span style=color:#f92672>.</span>__name, self<span style=color:#f92672>.</span>__score))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 59)
</span></span><span style=display:flex><span>&gt;&gt;&gt; bart.__name
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
</span></span><span style=display:flex><span>AttributeError: &#39;Student&#39; object has no attribute &#39;__name&#39;
</span></span></code></pre></div></li></ul></li><li><p>外部代码要获取name和score，给Student类增加<code>get_name</code>和<code>get_score</code>的方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_name</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>__name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_score</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>__score
</span></span></code></pre></div><p>要允许外部代码修改score怎么办？可以再给Student类增加<code>set_score</code>方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>set_score</span>(self, score):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__score <span style=color:#f92672>=</span> score
</span></span></code></pre></div></li><li><p><strong>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是</strong>。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; bart._Student__name
</span></span><span style=display:flex><span>&#39;Bart Simpson&#39;
</span></span></code></pre></div><p><em><strong>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名</strong></em></p></li><li><p><em><strong>注意下面的这种错误写法</strong></em>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 59)
</span></span><span style=display:flex><span>&gt;&gt;&gt; bart.get_name()
</span></span><span style=display:flex><span>&#39;Bart Simpson&#39;
</span></span><span style=display:flex><span>&gt;&gt;&gt; bart.__name = &#39;New Name&#39; # 设置__name变量！
</span></span><span style=display:flex><span>&gt;&gt;&gt; bart.__name
</span></span><span style=display:flex><span>&#39;New Name&#39;
</span></span></code></pre></div><p>表面上，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量<em>不是</em>一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name
</span></span><span style=display:flex><span>&#39;Bart Simpson&#39;
</span></span></code></pre></div></li></ul></li><li><h4 id=继承和多态>继承和多态<a hidden class=anchor aria-hidden=true href=#继承和多态>#</a></h4><ul><li><p>继承：</p><ul><li>最大的好处是子类获得了父类的全部功能</li><li>第二个好处需要我们对代码做一点改进，子类的<code>run()</code>可覆盖父类的<code>run()</code></li><li>如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类</li></ul></li><li><p>多态</p><ul><li>当我们需要传入<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……都是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动<strong>调用实际类型</strong>的<code>run()</code>方法</li></ul></li><li><p>静态语言VS动态语言</p><ul><li><p>静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法</p></li><li><p><strong>Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Timer</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;Start...&#39;</span>)
</span></span></code></pre></div><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子</p></li></ul></li></ul></li><li><h4 id=获得对象信息>获得对象信息<a hidden class=anchor aria-hidden=true href=#获得对象信息>#</a></h4><ul><li><p><em><strong>当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？</strong></em></p></li><li><p>判断对象类型，使用<code>type()</code>函数</p><ul><li><p>基本类型都可以用<code>type()</code>判断：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; type(123)
</span></span><span style=display:flex><span>&lt;class &#39;int&#39;&gt;
</span></span></code></pre></div></li><li><p>一个变量指向函数或者类，也可以用<code>type()</code>判断：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; type(abs)
</span></span><span style=display:flex><span>&lt;class &#39;builtin_function_or_method&#39;&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; type(123)==type(456)
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; type(123)==int
</span></span><span style=display:flex><span>True
</span></span></code></pre></div></li><li><p>如果要判断一个对象是否 是函数怎么办？可以使用<code>types</code>模块中定义的常量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; import types
</span></span><span style=display:flex><span>&gt;&gt;&gt; def fn():
</span></span><span style=display:flex><span>...     pass
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; type(fn)==types.FunctionType
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; type(lambda x: x)==types.LambdaType
</span></span><span style=display:flex><span>True
</span></span></code></pre></div></li></ul></li><li><p>对class的继承关系来说，判断class的类型，使用<code>isinstance()</code>函数</p><ul><li><p>回顾上次的例子，如果继承关系是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>object -&gt; Animal -&gt; Dog -&gt; Husky
</span></span></code></pre></div></li><li><p>先创建3种类型的对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; a = Animal()
</span></span><span style=display:flex><span>&gt;&gt;&gt; d = Dog()
</span></span><span style=display:flex><span>&gt;&gt;&gt; h = Husky()
</span></span></code></pre></div></li><li><p>验证如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; isinstance(d, Dog) and isinstance(d, Animal)
</span></span><span style=display:flex><span>True
</span></span></code></pre></div></li></ul></li><li><p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法</p><ul><li><p>我们自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; class MyDog(object):
</span></span><span style=display:flex><span>...     def __len__(self):
</span></span><span style=display:flex><span>...         return 100
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; dog = MyDog()
</span></span><span style=display:flex><span>&gt;&gt;&gt; len(dog)
</span></span><span style=display:flex><span>100
</span></span></code></pre></div></li></ul></li><li><p><strong>要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数</strong>，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; dir(&#39;ABC&#39;)
</span></span><span style=display:flex><span>[&#39;__add__&#39;, &#39;__class__&#39;,..., &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;,..., &#39;
</span></span></code></pre></div></li></ul></li><li><h4 id=实例属性和类属性>实例属性和类属性<a hidden class=anchor aria-hidden=true href=#实例属性和类属性>#</a></h4><ul><li><p><strong>Python是动态语言，根据类创建的实例可以任意绑定属性</strong></p><ul><li><p>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>s <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#39;Bob&#39;</span>)
</span></span><span style=display:flex><span>s<span style=color:#f92672>.</span>score <span style=color:#f92672>=</span> <span style=color:#ae81ff>90</span>
</span></span></code></pre></div></li></ul></li><li><p>类本身需要绑定一个属性，直接class中定义属性，这是类属性，归<code>Student</code>类所有：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>(object):
</span></span><span style=display:flex><span>    name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Student&#39;</span>
</span></span></code></pre></div><p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到</p></li><li><p><strong>相关测试如下</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; class Student(object):
</span></span><span style=display:flex><span>...     name = &#39;Student&#39;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; s = Student() # 创建实例s
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
</span></span><span style=display:flex><span>Student
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(Student.name) # 打印类的name属性
</span></span><span style=display:flex><span>Student
</span></span><span style=display:flex><span>&gt;&gt;&gt; s.name = &#39;Michael&#39; # 给实例绑定name属性
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
</span></span><span style=display:flex><span>Michael
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
</span></span><span style=display:flex><span>Student
</span></span><span style=display:flex><span>&gt;&gt;&gt; del s.name # 如果删除实例的name属性
</span></span><span style=display:flex><span>&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
</span></span><span style=display:flex><span>Student
</span></span></code></pre></div></li></ul></li></ul><h3 id=面向对象高级编程>面向对象高级编程<a hidden class=anchor aria-hidden=true href=#面向对象高级编程>#</a></h3><ul><li><h4 id=使用__slots__>使用<code>__slots__</code><a hidden class=anchor aria-hidden=true href=#使用__slots__>#</a></h4><ul><li>正常情况下，当我们定义了一个<code>class</code>，创建了一个<code>class</code>的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/python/>Python</a></li></ul><nav class=paginav><a class=next href=https://zwlzls.github.io/posts/python01/><span class=title>Next Page »</span><br><span>Python01</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>