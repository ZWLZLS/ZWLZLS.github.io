<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Mysql01 | 我的博客</title>
<meta name=keywords content="MySQL"><meta name=description content="事务 事务是由 MySQL 的引擎来实现，常见的 InnoDB 引擎它是支持事务的 并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务
特性 具体特性
原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节；事务在执行过程中发生错误，会被回滚到事务开始前的状态 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态 隔离性：允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失 如何保证特性？
持久性是通过 redo log （重做日志）来保证的 原子性是通过 undo log（回滚日志） 来保证的 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的 一致性则是通过持久性+原子性+隔离性来保证 隔离级别 MySQL服务端允许多个客户端连接，意味着 MySQL 会出现同时处理多个事务的情况 问题： 脏读：如果一个事务「读到」了另一个「未提交事务修改过的数据」 事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，被读 不可重复读：一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况 事务A两次读取过程中，事务B进行修改且提交 幻读：一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况 事务A两次读取过程中，事务B进行修改且提交 隔离级别 读未提交：一个事务还没提交时，它做的变更就能被其他事务看到 读提交：一个事务提交之后，它做的变更才能被其他事务看到 可重复读：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别 串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行 「可重复读」但是很大程度上避免幻读现象 针对快照读（普通 select 语句），通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的 针对当前读（select &mldr; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，当执行 select &mldr; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那这个插入语句就会被阻塞，无法成功插入 四种隔级别实现 「读未提交」可以读到未提交事务修改的数据，所以直接读取最新的数据就好 「串行化」通过加读写锁的方式来避免并行访问； 「读提交」和「可重复读」通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View 执行「开始事务」begin/start transaction 命令 执行了 begin/start transaction 命令后，并不代表事务启动了 只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机 Read View在MVCC工作 Read View 有四个重要的字段： m_ids ：在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务 min_trx_id ：在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值 max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，就是全局事务中最大的事务 id 值 + 1 creator_trx_id ：创建该 Read View 的事务的事务 id InnoDB 存储引擎的数据库表，聚簇索引记录中包含下面两个隐藏列： trx_id：一个事务对某条聚簇索引记录进行改动时，会把该事务的事务 id 记录在 trx_id 隐藏列里 roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录 通过「版本链」控制并发事务访问同一个记录时的行为叫 MVCC（多版本并发控制） 可重复读和读提交如何工作 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View 读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View 日志 undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC"><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/mysql01/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/mysql01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Mysql01"><meta property="og:description" content="事务 事务是由 MySQL 的引擎来实现，常见的 InnoDB 引擎它是支持事务的 并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务
特性 具体特性
原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节；事务在执行过程中发生错误，会被回滚到事务开始前的状态 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态 隔离性：允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失 如何保证特性？
持久性是通过 redo log （重做日志）来保证的 原子性是通过 undo log（回滚日志） 来保证的 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的 一致性则是通过持久性+原子性+隔离性来保证 隔离级别 MySQL服务端允许多个客户端连接，意味着 MySQL 会出现同时处理多个事务的情况 问题： 脏读：如果一个事务「读到」了另一个「未提交事务修改过的数据」 事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，被读 不可重复读：一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况 事务A两次读取过程中，事务B进行修改且提交 幻读：一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况 事务A两次读取过程中，事务B进行修改且提交 隔离级别 读未提交：一个事务还没提交时，它做的变更就能被其他事务看到 读提交：一个事务提交之后，它做的变更才能被其他事务看到 可重复读：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别 串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行 「可重复读」但是很大程度上避免幻读现象 针对快照读（普通 select 语句），通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的 针对当前读（select &mldr; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，当执行 select &mldr; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那这个插入语句就会被阻塞，无法成功插入 四种隔级别实现 「读未提交」可以读到未提交事务修改的数据，所以直接读取最新的数据就好 「串行化」通过加读写锁的方式来避免并行访问； 「读提交」和「可重复读」通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View 执行「开始事务」begin/start transaction 命令 执行了 begin/start transaction 命令后，并不代表事务启动了 只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机 Read View在MVCC工作 Read View 有四个重要的字段： m_ids ：在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务 min_trx_id ：在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值 max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，就是全局事务中最大的事务 id 值 + 1 creator_trx_id ：创建该 Read View 的事务的事务 id InnoDB 存储引擎的数据库表，聚簇索引记录中包含下面两个隐藏列： trx_id：一个事务对某条聚簇索引记录进行改动时，会把该事务的事务 id 记录在 trx_id 隐藏列里 roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录 通过「版本链」控制并发事务访问同一个记录时的行为叫 MVCC（多版本并发控制） 可重复读和读提交如何工作 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View 读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View 日志 undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC"><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/mysql01/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-10T15:10:54+08:00"><meta property="article:modified_time" content="2025-02-10T15:10:54+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Mysql01"><meta name=twitter:description content="事务 事务是由 MySQL 的引擎来实现，常见的 InnoDB 引擎它是支持事务的 并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务
特性 具体特性
原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节；事务在执行过程中发生错误，会被回滚到事务开始前的状态 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态 隔离性：允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失 如何保证特性？
持久性是通过 redo log （重做日志）来保证的 原子性是通过 undo log（回滚日志） 来保证的 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的 一致性则是通过持久性+原子性+隔离性来保证 隔离级别 MySQL服务端允许多个客户端连接，意味着 MySQL 会出现同时处理多个事务的情况 问题： 脏读：如果一个事务「读到」了另一个「未提交事务修改过的数据」 事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，被读 不可重复读：一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况 事务A两次读取过程中，事务B进行修改且提交 幻读：一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况 事务A两次读取过程中，事务B进行修改且提交 隔离级别 读未提交：一个事务还没提交时，它做的变更就能被其他事务看到 读提交：一个事务提交之后，它做的变更才能被其他事务看到 可重复读：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别 串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行 「可重复读」但是很大程度上避免幻读现象 针对快照读（普通 select 语句），通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的 针对当前读（select &mldr; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，当执行 select &mldr; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那这个插入语句就会被阻塞，无法成功插入 四种隔级别实现 「读未提交」可以读到未提交事务修改的数据，所以直接读取最新的数据就好 「串行化」通过加读写锁的方式来避免并行访问； 「读提交」和「可重复读」通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View 执行「开始事务」begin/start transaction 命令 执行了 begin/start transaction 命令后，并不代表事务启动了 只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机 Read View在MVCC工作 Read View 有四个重要的字段： m_ids ：在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务 min_trx_id ：在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值 max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，就是全局事务中最大的事务 id 值 + 1 creator_trx_id ：创建该 Read View 的事务的事务 id InnoDB 存储引擎的数据库表，聚簇索引记录中包含下面两个隐藏列： trx_id：一个事务对某条聚簇索引记录进行改动时，会把该事务的事务 id 记录在 trx_id 隐藏列里 roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录 通过「版本链」控制并发事务访问同一个记录时的行为叫 MVCC（多版本并发控制） 可重复读和读提交如何工作 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View 读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View 日志 undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Mysql01","item":"https://zwlzls.github.io/posts/mysql01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Mysql01","name":"Mysql01","description":"事务 事务是由 MySQL 的引擎来实现，常见的 InnoDB 引擎它是支持事务的 并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务\n特性 具体特性\n原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节；事务在执行过程中发生错误，会被回滚到事务开始前的状态 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态 隔离性：允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失 如何保证特性？\n持久性是通过 redo log （重做日志）来保证的 原子性是通过 undo log（回滚日志） 来保证的 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的 一致性则是通过持久性+原子性+隔离性来保证 隔离级别 MySQL服务端允许多个客户端连接，意味着 MySQL 会出现同时处理多个事务的情况 问题： 脏读：如果一个事务「读到」了另一个「未提交事务修改过的数据」 事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，被读 不可重复读：一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况 事务A两次读取过程中，事务B进行修改且提交 幻读：一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况 事务A两次读取过程中，事务B进行修改且提交 隔离级别 读未提交：一个事务还没提交时，它做的变更就能被其他事务看到 读提交：一个事务提交之后，它做的变更才能被其他事务看到 可重复读：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别 串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行 「可重复读」但是很大程度上避免幻读现象 针对快照读（普通 select 语句），通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的 针对当前读（select \u0026hellip; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，当执行 select \u0026hellip; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那这个插入语句就会被阻塞，无法成功插入 四种隔级别实现 「读未提交」可以读到未提交事务修改的数据，所以直接读取最新的数据就好 「串行化」通过加读写锁的方式来避免并行访问； 「读提交」和「可重复读」通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View 执行「开始事务」begin/start transaction 命令 执行了 begin/start transaction 命令后，并不代表事务启动了 只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机 Read View在MVCC工作 Read View 有四个重要的字段： m_ids ：在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务 min_trx_id ：在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值 max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，就是全局事务中最大的事务 id 值 + 1 creator_trx_id ：创建该 Read View 的事务的事务 id InnoDB 存储引擎的数据库表，聚簇索引记录中包含下面两个隐藏列： trx_id：一个事务对某条聚簇索引记录进行改动时，会把该事务的事务 id 记录在 trx_id 隐藏列里 roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录 通过「版本链」控制并发事务访问同一个记录时的行为叫 MVCC（多版本并发控制） 可重复读和读提交如何工作 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View 读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View 日志 undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC","keywords":["MySQL"],"articleBody":"事务 事务是由 MySQL 的引擎来实现，常见的 InnoDB 引擎它是支持事务的 并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务\n特性 具体特性\n原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节；事务在执行过程中发生错误，会被回滚到事务开始前的状态 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态 隔离性：允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失 如何保证特性？\n持久性是通过 redo log （重做日志）来保证的 原子性是通过 undo log（回滚日志） 来保证的 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的 一致性则是通过持久性+原子性+隔离性来保证 隔离级别 MySQL服务端允许多个客户端连接，意味着 MySQL 会出现同时处理多个事务的情况 问题： 脏读：如果一个事务「读到」了另一个「未提交事务修改过的数据」 事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，被读 不可重复读：一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况 事务A两次读取过程中，事务B进行修改且提交 幻读：一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况 事务A两次读取过程中，事务B进行修改且提交 隔离级别 读未提交：一个事务还没提交时，它做的变更就能被其他事务看到 读提交：一个事务提交之后，它做的变更才能被其他事务看到 可重复读：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别 串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行 「可重复读」但是很大程度上避免幻读现象 针对快照读（普通 select 语句），通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的 针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那这个插入语句就会被阻塞，无法成功插入 四种隔级别实现 「读未提交」可以读到未提交事务修改的数据，所以直接读取最新的数据就好 「串行化」通过加读写锁的方式来避免并行访问； 「读提交」和「可重复读」通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View 执行「开始事务」begin/start transaction 命令 执行了 begin/start transaction 命令后，并不代表事务启动了 只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机 Read View在MVCC工作 Read View 有四个重要的字段： m_ids ：在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务 min_trx_id ：在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值 max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，就是全局事务中最大的事务 id 值 + 1 creator_trx_id ：创建该 Read View 的事务的事务 id InnoDB 存储引擎的数据库表，聚簇索引记录中包含下面两个隐藏列： trx_id：一个事务对某条聚簇索引记录进行改动时，会把该事务的事务 id 记录在 trx_id 隐藏列里 roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录 通过「版本链」控制并发事务访问同一个记录时的行为叫 MVCC（多版本并发控制） 可重复读和读提交如何工作 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View 读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View 日志 undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC\nredo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复\nbinlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制\nundoLog 执行执行一条“增删改”语句的时候，虽然没有输入 begin 开启事务和 commit 提交事务，但 MySQL 会隐式开启事务来执行“增删改”语句的，执行完就自动提交事务 事务执行过程中，都记录下回滚时需要的信息到一个日志里，若事务执行中途发生MySQL 崩溃后，就不用担心无法回滚到事务之前的数据，可通过这个日志回滚到事务之前的数据 undo log 是一种用于撤销回退的日志，在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚 在插入一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录删掉就好 在删除一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好 delete操作实际上不会立即直接删除，而是将delete对象打上delete flag，标记为删除，最终的删除操作是purge线程完成的 在更新一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列更新为旧值就好 update的列是否是主键列。 不是主键列，在undo log中直接反向记录是如何update的。即update是直接进行的。 是主键列，update分两部执行：先删除该行，再插入一行目标行 undo log 两大作用： 实现事务回滚，保障事务的原子性。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态 实现 MVCC（多版本并发控制）关键因素之一。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录 Buffer Pool MySQL数据都是存在磁盘中，那么要更新一条记录时候，得先从磁盘读取该记录，然后在内存中修改这条记录。那修改完这条记录是选择直接写回到磁盘，还是选择缓存起来呢?\n作用？ 当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取 当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘 缓存内容： InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。Buffer Pool 同样需要按「页」来划分 MySQL 启动的时候，InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的16KB的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页 Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等 redoLog Buffer Pool 基于内存，而内存不可靠，万一断电重启，没来及落盘脏页数据就会丢失, InnoDB 引擎会在适当时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就 WAL （Write-Ahead Logging）技术 WAL 技术： MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上 redo log 是物理日志，记录了某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新，每当执行一个事务就会产生这样的一条或者多条物理日志 redo log 和 undo log 区别 redo log 记录此次事务「修改后」的数据状态，记录的是更新之后的值，主要用于事务崩溃恢复，保证事务的持久性。 undo log 记录此次事务「修改前」的数据状态，记录的是更新之前的值，主要用于事务回滚，保证事务的原子性 redo log 要写到磁盘，数据也要写磁盘，超麻烦 写入 redo log 的方式使用了追加操作， 所以磁盘操作是顺序写 写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写 redo log 也有自己缓存—— redo log buffer，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘 作用 ： 实现事务的持久性，让 MySQL 有 crash-safe 的能力，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失； 将写操作从「随机写」变成了「顺序写」，提升 MySQL 写入磁盘的性能 redoLog刷盘时间（也就是从redoLogBuffer到磁盘） MySQL 正常关闭时； 当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘； InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。 每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略由 innodb_flush_log_at_trx_commit 参数控制） 参数 innodb_flush_log_at_trx_commit 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下： 当设置该参数为 0 时，表示每次事务提交时 ，还是将 redo log 留在 redo log buffer 中 ，该模式下在事务提交时不会主动触发写入磁盘的操作。 当设置该参数为 1 时，表示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘，这样可以保证 MySQL 异常重启之后数据不会丢失。 当设置该参数为 2 时，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存 redoLog文件写满怎么办？ 默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成 重做日志文件组是以循环写的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形 binLog MySQL 完成一条更新操作后，Server 层会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写入 binlog 文件 binlog 文件记录所有数据库表结构变更和表数据修改的日志，用于备份恢复、主从复制 锁 全局锁 要使用全局锁，执行后，整个数据库就处于只读状态了，命令：\nflush tables with read lock 释放全局锁，则要执行这条命令：\nunlock tables 全局锁主应用于全库逻辑备份，这样备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样\n加上全局锁，意味着整个数据库都是只读状态\n表级锁 表锁\n//表级别的共享锁，也就是读锁； //允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。 lock tables t_student read; //表级别的独占锁，也就是写锁； //允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。 lock tables t_stuent write; 释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：\nunlock tables 元数据锁(MDL)\n不需要显示的使用 MDL，当对数据库表进行操作时，会自动给这个表加上 MDL\n对一张表进行 CRUD 操作时，加的 MDL 读锁； 当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁） 对一张表做结构变更操作的时候，加的MDL 写锁 当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁） 意向锁\n目的是为了快速判断表里是否有记录被加锁\n在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」； 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」 意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables … read*）和独占表锁（*lock tables … write*）发生冲突\nAUTO-INC 锁\n表里的主键通常都会设置成自增，通过对主键字段声明 AUTO_INCREMENT 属性实现\nAUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放\n行级锁 InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁\n普通的 select 语句是不会对记录加锁的，因为它属于快照读\n要在查询时对记录加行锁，可以使用下面这两个方式，这种查询加锁的语句称为锁定读\n//对读取的记录加共享锁 select ... lock in share mode; //对读取的记录加独占锁 select ... for update; 上面这两条语句共同点，必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 start transaction，COMMIT;\n-- 自动提交模式下，锁立即释放（无意义） SELECT * FROM table WHERE id = 1 FOR UPDATE; -- 执行完立即释放锁 若需锁生效，必须显式开启事务\nSTART TRANSACTION; SELECT * FROM table WHERE id = 1 FOR UPDATE; -- 锁持续到事务结束 -- 执行其他操作... COMMIT; -- 提交时释放锁 行级锁的类型：\nRecord Lock：记录锁，就是仅仅把一条记录锁上； Gap Lock：间隙锁，锁定一个范围，但是不包含记录本身； Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身 Record Lock\nRecord Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：\n当一个事务执行了下面这条语句：\nmysql \u003e begin; mysql \u003e select * from t_test where id = 1 for update; 对 t_test 表中主键 id 为 1 这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改\n当事务执行 commit 后，事务过程中生成的锁都会被释放\nGap Lock\nGap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象 间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的 Next-Key Lock\nRecord Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身 Next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的 ","wordCount":"673","inLanguage":"en","datePublished":"2025-02-10T15:10:54+08:00","dateModified":"2025-02-10T15:10:54+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/mysql01/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Mysql01</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%ba%8b%e5%8a%a1 aria-label=事务>事务</a><ul><li><a href=#%e7%89%b9%e6%80%a7 aria-label=特性>特性</a></li><li><a href=#%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab aria-label=隔离级别>隔离级别</a></li><li><a href=#read-view%e5%9c%a8mvcc%e5%b7%a5%e4%bd%9c aria-label="Read View在MVCC工作">Read View在MVCC工作</a></li><li><a href=#%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e5%92%8c%e8%af%bb%e6%8f%90%e4%ba%a4%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c aria-label=可重复读和读提交如何工作>可重复读和读提交如何工作</a></li></ul></li><li><a href=#%e6%97%a5%e5%bf%97 aria-label=日志>日志</a><ul><li><a href=#undolog aria-label=undoLog>undoLog</a></li><li><a href=#buffer-pool aria-label="Buffer Pool">Buffer Pool</a></li><li><a href=#redolog aria-label=redoLog>redoLog</a></li><li><a href=#binlog aria-label=binLog>binLog</a></li></ul></li><li><a href=#%e9%94%81 aria-label=锁>锁</a><ul><li><a href=#%e5%85%a8%e5%b1%80%e9%94%81 aria-label=全局锁>全局锁</a></li><li><a href=#%e8%a1%a8%e7%ba%a7%e9%94%81 aria-label=表级锁>表级锁</a></li><li><a href=#%e8%a1%8c%e7%ba%a7%e9%94%81 aria-label=行级锁>行级锁</a></li></ul></li></ul></div></details></div><div class=post-content><h3 id=事务>事务<a hidden class=anchor aria-hidden=true href=#事务>#</a></h3><p><strong>事务是由 MySQL 的引擎来实现，常见的 InnoDB 引擎它是支持事务的</strong>
<strong>并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务</strong></p><ul><li><h4 id=特性>特性<a hidden class=anchor aria-hidden=true href=#特性>#</a></h4><ul><li><p>具体特性</p><ul><li>原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节；事务在执行过程中发生错误，会被回滚到事务开始前的状态</li><li>一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态</li><li>隔离性：允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致</li><li>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</li></ul></li><li><p>如何保证特性？</p><ul><li>持久性是通过 redo log （重做日志）来保证的</li><li>原子性是通过 undo log（回滚日志） 来保证的</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的</li><li>一致性则是通过持久性+原子性+隔离性来保证</li></ul></li></ul></li><li><h4 id=隔离级别>隔离级别<a hidden class=anchor aria-hidden=true href=#隔离级别>#</a></h4><ul><li>MySQL服务端允许多个客户端连接，意味着 MySQL 会出现同时处理多个事务的情况</li><li>问题：<ul><li>脏读：<strong>如果一个事务「读到」了另一个「未提交事务修改过的数据」</strong><ul><li>事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，被读</li></ul></li><li>不可重复读：<strong>一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况</strong><ul><li>事务A两次读取过程中，事务B进行修改且提交</li></ul></li><li>幻读：<strong>一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况</strong><ul><li>事务A两次读取过程中，事务B进行修改且提交</li></ul></li></ul></li><li>隔离级别<ul><li><strong>读未提交</strong>：一个事务还没提交时，它做的变更就能被其他事务看到</li><li><strong>读提交</strong>：一个事务提交之后，它做的变更才能被其他事务看到</li><li><strong>可重复读</strong>：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong></li><li><strong>串行化</strong>：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</li></ul></li><li><strong>「可重复读」但是很大程度上避免幻读现象</strong><ul><li>针对<strong>快照读</strong>（普通 select 语句），<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的</li><li>针对<strong>当前读</strong>（select &mldr; for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，当执行 select &mldr; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那这个插入语句就会被阻塞，无法成功插入</li></ul></li><li>四种隔级别实现<ul><li>「读未提交」可以读到未提交事务修改的数据，所以直接读取最新的数据就好</li><li>「串行化」通过加读写锁的方式来避免并行访问；</li><li>「读提交」和「可重复读」通过 <strong>Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong></li></ul></li><li>执行「开始事务」begin/start transaction 命令<ul><li>执行了 begin/start transaction 命令后，并不代表事务启动了</li><li>只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机</li></ul></li></ul></li><li><h4 id=read-view在mvcc工作>Read View在MVCC工作<a hidden class=anchor aria-hidden=true href=#read-view在mvcc工作>#</a></h4><ul><li>Read View 有四个重要的字段：<ul><li>m_ids ：在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong></li><li>min_trx_id ：在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，就是全局事务中最大的事务 id 值 + 1</li><li>creator_trx_id ：<strong>创建该 Read View 的事务的事务 id</strong></li></ul></li><li>InnoDB 存储引擎的数据库表，聚簇索引记录中包含下面两个隐藏列：<ul><li>trx_id：一个事务对某条聚簇索引记录进行改动时，会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong></li><li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录</li></ul></li><li><strong>通过「版本链」控制并发事务访问同一个记录时的行为叫 MVCC（多版本并发控制）</strong></li></ul></li><li><h4 id=可重复读和读提交如何工作>可重复读和读提交如何工作<a hidden class=anchor aria-hidden=true href=#可重复读和读提交如何工作>#</a></h4><ul><li><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong></li><li><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong></li></ul></li></ul><h3 id=日志>日志<a hidden class=anchor aria-hidden=true href=#日志>#</a></h3><ul><li><p><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong></p></li><li><p><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong></p></li><li><p><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong></p></li><li><h4 id=undolog>undoLog<a hidden class=anchor aria-hidden=true href=#undolog>#</a></h4><ul><li>执行执行一条“增删改”语句的时候，虽然没有输入 begin 开启事务和 commit 提交事务，但 MySQL 会<strong>隐式开启事务</strong>来执行“增删改”语句的，执行完就自动提交事务</li><li>事务执行过程中，都记录下回滚时需要的信息到一个日志里，若事务执行中途发生MySQL 崩溃后，就不用担心无法回滚到事务之前的数据，可通过这个日志回滚到事务之前的数据</li><li>undo log 是一种用于撤销回退的日志，在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚<ul><li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好</li><li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好<ul><li>delete操作实际上不会立即直接删除，而是将delete对象打上delete flag，标记为删除，最终的删除操作是purge线程完成的</li></ul></li><li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好<ul><li>update的列是否是主键列。<ul><li>不是主键列，在undo log中直接反向记录是如何update的。即update是直接进行的。</li><li>是主键列，update分两部执行：先删除该行，再插入一行目标行</li></ul></li></ul></li></ul></li><li>undo log 两大作用：<ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录</li></ul></li></ul></li><li><h4 id=buffer-pool>Buffer Pool<a hidden class=anchor aria-hidden=true href=#buffer-pool>#</a></h4><p>MySQL数据都是存在磁盘中，那么要更新一条记录时候，得先从磁盘读取该记录，然后在内存中修改这条记录。那修改完这条记录是选择直接写回到磁盘，还是选择缓存起来呢?</p><ul><li>作用？<ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取</li><li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘</li></ul></li><li>缓存内容：<ul><li>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。Buffer Pool 同样需要按「页」来划分</li><li>MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong></li><li>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等</li></ul></li></ul></li><li><h4 id=redolog>redoLog<a hidden class=anchor aria-hidden=true href=#redolog>#</a></h4><ul><li>Buffer Pool 基于内存，而内存不可靠，万一断电重启，没来及落盘脏页数据就会丢失,
InnoDB 引擎会在适当时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就 <strong>WAL （Write-Ahead Logging）技术</strong></li><li><strong>WAL 技术： MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong></li><li>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志</li><li>redo log 和 undo log 区别<ul><li>redo log 记录此次事务「<strong>修改后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值，<strong>主要用于事务崩溃恢复，保证事务的持久性</strong>。</li><li>undo log 记录此次事务「<strong>修改前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值，<strong>主要用于事务回滚，保证事务的原子性</strong></li></ul></li><li><strong>redo log 要写到磁盘，数据也要写磁盘，超麻烦</strong><ul><li>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong></li><li>写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong></li></ul></li><li>redo log 也有自己缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘</li><li>作用 ：<ul><li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能</li></ul></li><li>redoLog刷盘时间（也就是从redoLogBuffer到磁盘）<ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略由 innodb_flush_log_at_trx_commit 参数控制）</li></ul></li><li>参数 <code>innodb_flush_log_at_trx_commit</code> 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：<ul><li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li><li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li><li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 Page Cache，Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存</li></ul></li><li>redoLog文件写满怎么办？<ul><li>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成</li><li>重做日志文件组是以<strong>循环写</strong>的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形</li></ul></li></ul></li><li><h4 id=binlog>binLog<a hidden class=anchor aria-hidden=true href=#binlog>#</a></h4><ul><li>MySQL 完成一条<strong>更新操作</strong>后，Server 层会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写入 binlog 文件</li><li>binlog 文件记录所有数据库表结构变更和表数据修改的日志，<strong>用于备份恢复、主从复制</strong></li></ul></li></ul><h3 id=锁>锁<a hidden class=anchor aria-hidden=true href=#锁>#</a></h3><ul><li><h4 id=全局锁>全局锁<a hidden class=anchor aria-hidden=true href=#全局锁>#</a></h4><ul><li><p>要使用全局锁，执行后，<strong>整个数据库就处于只读状态了</strong>，命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>flush tables <span style=color:#66d9ef>with</span> <span style=color:#66d9ef>read</span> <span style=color:#66d9ef>lock</span>
</span></span></code></pre></div></li><li><p>释放全局锁，则要执行这条命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>unlock tables
</span></span></code></pre></div></li><li><p>全局锁主应用于<strong>全库逻辑备份</strong>，这样备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样</p><p>加上全局锁，意味着整个数据库都是只读状态</p></li></ul></li><li><h4 id=表级锁>表级锁<a hidden class=anchor aria-hidden=true href=#表级锁>#</a></h4><ul><li><p>表锁</p><pre tabindex=0><code>//表级别的共享锁，也就是读锁；
//允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。
lock tables t_student read;

//表级别的独占锁，也就是写锁；
//允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。
lock tables t_stuent write;
</code></pre><p>释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>unlock tables
</span></span></code></pre></div></li><li><p>元数据锁(MDL)</p><p>不需要显示的使用 MDL，当对数据库表进行操作时，会自动给这个表加上 MDL</p><ul><li>对一张表进行 CRUD 操作时，加的 <strong>MDL 读锁</strong>；<ul><li>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）</li></ul></li><li>对一张表做结构变更操作的时候，加的<strong>MDL 写锁</strong><ul><li>当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）</li></ul></li></ul></li><li><p>意向锁</p><p><strong>目的是为了快速判断表里是否有记录被加锁</strong></p><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」</li></ul><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables &mldr; read*）和独占表锁（*lock tables &mldr; write*）发生冲突</strong></p></li><li><p>AUTO-INC 锁</p><p>表里的主键通常都会设置成自增，通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现</p><p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong></p></li></ul></li><li><h4 id=行级锁>行级锁<a hidden class=anchor aria-hidden=true href=#行级锁>#</a></h4><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁</p><p><strong>普通的 select 语句是不会对记录加锁的，因为它属于快照读</strong></p><p>要在查询时对记录加行锁，可以使用下面这两个方式，这种查询加锁的语句称为<strong>锁定读</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#f92672>//</span><span style=color:#960050;background-color:#1e0010>对读取的记录加共享锁</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> ... <span style=color:#66d9ef>lock</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>share</span> <span style=color:#66d9ef>mode</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>//</span><span style=color:#960050;background-color:#1e0010>对读取的记录加独占锁</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> ... <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>update</span>;
</span></span></code></pre></div><p>上面这两条语句共同点，必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 start transaction，COMMIT;</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#75715e>-- 自动提交模式下，锁立即释放（无意义）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>WHERE</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>UPDATE</span>; <span style=color:#75715e>-- 执行完立即释放锁
</span></span></span></code></pre></div><p>若需锁生效，必须显式开启事务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>START</span> <span style=color:#66d9ef>TRANSACTION</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> <span style=color:#66d9ef>table</span> <span style=color:#66d9ef>WHERE</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>UPDATE</span>; <span style=color:#75715e>-- 锁持续到事务结束
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 执行其他操作...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>COMMIT</span>; <span style=color:#75715e>-- 提交时释放锁
</span></span></span></code></pre></div></li><li><p><strong>行级锁的类型：</strong></p><ul><li>Record Lock：记录锁，就是仅仅把一条记录锁上；</li><li>Gap Lock：间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身</li></ul></li><li><p>Record Lock</p><ul><li><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p></li><li><p>当一个事务执行了下面这条语句：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql <span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>begin</span>;
</span></span><span style=display:flex><span>mysql <span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> t_test <span style=color:#66d9ef>where</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>update</span>;
</span></span></code></pre></div><p>对 t_test 表中主键 id 为 1 这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改</p><p>当事务执行 commit 后，事务过程中生成的锁都会被释放</p></li></ul></li><li><p>Gap Lock</p><ul><li>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象</li><li><strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong></li></ul></li><li><p>Next-Key Lock</p><ul><li>Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身</li><li><strong>Next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong></li></ul></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/mysql/>MySQL</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/redis00/><span class=title>« Prev Page</span><br><span>Redis00</span>
</a><a class=next href=https://zwlzls.github.io/posts/mysql00/><span class=title>Next Page »</span><br><span>Mysql00</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>