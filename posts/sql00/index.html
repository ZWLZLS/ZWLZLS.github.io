<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SQL语法 | 我的博客</title>
<meta name=keywords content="MySQL"><meta name=description content="SQL基本使用 关系型数据库 数据库：保存用户数据
随着应用程序的功能越复杂，数据量越大，管理这些数据就成了大问题 读写文件并解析出数据需要大量重复代码； 从成千上万的数据中快速查询出指定数据需要复杂的逻辑 数据模型
层次模型：以“上下级”的层次关系来组织数据的一种方式，看起来就像一颗树 网状模型：每个数据节点和其他很多节点都连接起来，看起来就像很多城市之间的路网 关系模型：数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，看起来就是一个Excel表 常见数据类型
名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 SQL
结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还对数据库进行管理和维护操做 SQL语言关键字不区分大小写！！！但表名和列名不一定 MySQL本身只是一个SQL接口，内部包含多种数据引擎
InnoDB：一款支持事务的数据库引擎 MyISAM：MySQL早期默认数据库引擎，不支持事务 关系模型 表的每一行称为记录（Record），记录是一个逻辑意义上的数据。
表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。
主键
记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响 主键的一个基本原则：不使用任何业务相关的字段作为主键，也不应该允许NULL 一般字段命名为id ，常见类型有 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键 全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的 联合主键 通过多个字段唯一标识记录，即两个或更多的字段都设置为主键 外键
在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键
定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录
外键并不是通过列名实现的，而是通过定义外键约束实现的："><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/sql00/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/sql00/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="SQL语法"><meta property="og:description" content="SQL基本使用 关系型数据库 数据库：保存用户数据
随着应用程序的功能越复杂，数据量越大，管理这些数据就成了大问题 读写文件并解析出数据需要大量重复代码； 从成千上万的数据中快速查询出指定数据需要复杂的逻辑 数据模型
层次模型：以“上下级”的层次关系来组织数据的一种方式，看起来就像一颗树 网状模型：每个数据节点和其他很多节点都连接起来，看起来就像很多城市之间的路网 关系模型：数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，看起来就是一个Excel表 常见数据类型
名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 SQL
结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还对数据库进行管理和维护操做 SQL语言关键字不区分大小写！！！但表名和列名不一定 MySQL本身只是一个SQL接口，内部包含多种数据引擎
InnoDB：一款支持事务的数据库引擎 MyISAM：MySQL早期默认数据库引擎，不支持事务 关系模型 表的每一行称为记录（Record），记录是一个逻辑意义上的数据。
表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。
主键
记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响 主键的一个基本原则：不使用任何业务相关的字段作为主键，也不应该允许NULL 一般字段命名为id ，常见类型有 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键 全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的 联合主键 通过多个字段唯一标识记录，即两个或更多的字段都设置为主键 外键
在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键
定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录
外键并不是通过列名实现的，而是通过定义外键约束实现的："><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/sql00/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-07T22:12:09+08:00"><meta property="article:modified_time" content="2025-01-07T22:12:09+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SQL语法"><meta name=twitter:description content="SQL基本使用 关系型数据库 数据库：保存用户数据
随着应用程序的功能越复杂，数据量越大，管理这些数据就成了大问题 读写文件并解析出数据需要大量重复代码； 从成千上万的数据中快速查询出指定数据需要复杂的逻辑 数据模型
层次模型：以“上下级”的层次关系来组织数据的一种方式，看起来就像一颗树 网状模型：每个数据节点和其他很多节点都连接起来，看起来就像很多城市之间的路网 关系模型：数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，看起来就是一个Excel表 常见数据类型
名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 SQL
结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还对数据库进行管理和维护操做 SQL语言关键字不区分大小写！！！但表名和列名不一定 MySQL本身只是一个SQL接口，内部包含多种数据引擎
InnoDB：一款支持事务的数据库引擎 MyISAM：MySQL早期默认数据库引擎，不支持事务 关系模型 表的每一行称为记录（Record），记录是一个逻辑意义上的数据。
表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。
主键
记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响 主键的一个基本原则：不使用任何业务相关的字段作为主键，也不应该允许NULL 一般字段命名为id ，常见类型有 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键 全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的 联合主键 通过多个字段唯一标识记录，即两个或更多的字段都设置为主键 外键
在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键
定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录
外键并不是通过列名实现的，而是通过定义外键约束实现的："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SQL语法","item":"https://zwlzls.github.io/posts/sql00/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SQL语法","name":"SQL语法","description":"SQL基本使用 关系型数据库 数据库：保存用户数据\n随着应用程序的功能越复杂，数据量越大，管理这些数据就成了大问题 读写文件并解析出数据需要大量重复代码； 从成千上万的数据中快速查询出指定数据需要复杂的逻辑 数据模型\n层次模型：以“上下级”的层次关系来组织数据的一种方式，看起来就像一颗树 网状模型：每个数据节点和其他很多节点都连接起来，看起来就像很多城市之间的路网 关系模型：数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，看起来就是一个Excel表 常见数据类型\n名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 SQL\n结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还对数据库进行管理和维护操做 SQL语言关键字不区分大小写！！！但表名和列名不一定 MySQL本身只是一个SQL接口，内部包含多种数据引擎\nInnoDB：一款支持事务的数据库引擎 MyISAM：MySQL早期默认数据库引擎，不支持事务 关系模型 表的每一行称为记录（Record），记录是一个逻辑意义上的数据。\n表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。\n主键\n记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响 主键的一个基本原则：不使用任何业务相关的字段作为主键，也不应该允许NULL 一般字段命名为id ，常见类型有 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键 全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的 联合主键 通过多个字段唯一标识记录，即两个或更多的字段都设置为主键 外键\n在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键\n定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录\n外键并不是通过列名实现的，而是通过定义外键约束实现的：","keywords":["MySQL"],"articleBody":"SQL基本使用 关系型数据库 数据库：保存用户数据\n随着应用程序的功能越复杂，数据量越大，管理这些数据就成了大问题 读写文件并解析出数据需要大量重复代码； 从成千上万的数据中快速查询出指定数据需要复杂的逻辑 数据模型\n层次模型：以“上下级”的层次关系来组织数据的一种方式，看起来就像一颗树 网状模型：每个数据节点和其他很多节点都连接起来，看起来就像很多城市之间的路网 关系模型：数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，看起来就是一个Excel表 常见数据类型\n名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 SQL\n结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还对数据库进行管理和维护操做 SQL语言关键字不区分大小写！！！但表名和列名不一定 MySQL本身只是一个SQL接口，内部包含多种数据引擎\nInnoDB：一款支持事务的数据库引擎 MyISAM：MySQL早期默认数据库引擎，不支持事务 关系模型 表的每一行称为记录（Record），记录是一个逻辑意义上的数据。\n表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。\n主键\n记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响 主键的一个基本原则：不使用任何业务相关的字段作为主键，也不应该允许NULL 一般字段命名为id ，常见类型有 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键 全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的 联合主键 通过多个字段唯一标识记录，即两个或更多的字段都设置为主键 外键\n在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键\n定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录\n外键并不是通过列名实现的，而是通过定义外键约束实现的：\nALTER TABLE students ADD CONSTRAINT fk_class_id FOREIGN KEY (class_id) REFERENCES classes (id); 外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）\n删除一个外键约束，也是通过ALTER TABLE实现的：\nALTER TABLE students DROP FOREIGN KEY fk_class_id; 删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现\n多对多：两个一对多关系实现的，通过一个中间表，关联两个一对多关系\n一对一：一个表的记录对应到另一个表的唯一一个记录\n索引\n关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度\n使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上\n索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高\n优点提高查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引\n关系数据库会自动对主键创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一\n唯一索引：\n通过UNIQUE关键字我们就添加了一个唯一索引\nALTER TABLE students ADD UNIQUE INDEX uni_name (name); 只对某一列添加一个唯一约束而不创建唯一索引\nALTER TABLE students ADD CONSTRAINT uni_name UNIQUE (name); 查询数据 在MySQL命令行客户端输入SQL后，记得加一个;\n基本查询\nSELECT查询的基本语句SELECT * FROM \u003c表名\u003e可以查询一个表的所有行和所有列的数据 不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1; 条件查询\nSELECT * FROM \u003c表名\u003e WHERE \u003c条件表达式\u003e 用\u003c条件1\u003e AND \u003c条件2\u003e表达满足条件1并且满足条件2 用\u003c条件1\u003e OR \u003c条件2\u003e，表示满足条件1或者满足条件2 用NOT \u003c条件\u003e，表示“不符合该条件”的记录 组合三个或者更多的条件，就需要用小括号()表示如何进行条件运算 投影查询\nwhat : 使用SELECT *表示查询表的所有列，使用SELECT 列1, 列2, 列3则可以仅返回指定列，这种操作称为投影\n可以给每一列起个别名，结果集的列名就可以与原表的列名不同。语法是SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...\n排序\n根据其他条件排序，可以加上ORDER BY子句\nASC：升序，即从小到大。ASC可以省略 DESC：倒序 有相同的数据，要进一步排序，可以继续添加列名\n有WHERE子句，那么ORDER BY子句要放到WHERE子句后面\n分页查询\nwhy : 结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示\n查询可以通过LIMIT OFFSET 子句实现 M从0开始\nLIMIT N表示是最多N条记录。OFFSET 表示是从M号记录开始 结果集分页，每页3条记录。获取第1页的记录，可以使用LIMIT 3 OFFSET 0 要查询第2页，把OFFSET设定为3，LIMIT 3 OFFSET 3 查询第2~4行，命令为 LIMIT 3 OFFSET 1简写为LIMIT 1,3 OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集\n重点：\nOFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。\n在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15。\n使用LIMIT OFFSET 分页时，随着N越来越大，查询效率也会越来越低\n聚合查询\n对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询\n使用聚合查询时，我们应该给列名设置一个别名，便于处理结果 COUNT(*)和COUNT(id)实际上是一样的效果,查询所有列的行数 函数 说明 SUM 计算某一列的合计值，该列必须为数值类型 AVG 计算某一列的平均值，该列必须为数值类型 MAX 计算某一列的最大值 MIN 计算某一列的最小值 MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符\n如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL\n分组\nGROUP BY子句指定了按 该字段 分组 执行该SELECT语句时，会把该字段相同的列先分组，再分别计算 也可以使用多个列逐个进行分组 多表查询\n获取M x N行记录，结果集可能非常巨大，要小心使用 连接查询\n对多个表进行JOIN运算，先确定一个主表作为结果集，再把其他表的行有选择性地“连接”在主表结果集上\n注意INNER JOIN查询的写法是： 先确定主表，仍然使用FROM \u003c表1\u003e的语法； 再确定需要连接的表，使用INNER JOIN \u003c表2\u003e的语法； 然后确定连接条件，使用ON \u003c条件...\u003e，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接； 可选：加上WHERE子句、ORDER BY等子句。 区分\nINNER JOIN只返回同时存在于两张表的行数据 RIGHT OUTER JOIN返回右表都存在的行 LEFT OUTER JOIN则返回左表都存在的行 FULL OUTER JOIN，把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL 假设查询语句是：\nSELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2; 我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录：\nLEFT OUTER JOIN是选出左表存在的记录：\nRIGHT OUTER JOIN是选出右表存在的记录：\nFULL OUTER JOIN则是选出左右表都存在的记录：\n总结\nJOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上； INNER JOIN是最常用的一种JOIN查询，它的语法是SELECT ... FROM \u003c表1\u003e INNER JOIN \u003c表2\u003e ON \u003c条件...\u003e； 修改数据 语句使用\n增：INSERT：插入新记录；\n改：UPDATE：更新已有记录；\n删：DELETE：删除已有记录；\n插入数据\nINSERT语句的基本语法是：\nINSERT INTO \u003c表名\u003e (字段1, 字段2, ...) VALUES (值1, 值2, ...); 还可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由(...)包含的一组值，每组值用逗号,分隔\n更新数据\nUPDATE语句的基本语法是：\nUPDATE \u003c表名\u003e SET 字段1=值1, 字段2=值2, ... WHERE ...; 要特别小心的是，UPDATE语句可以没有WHERE条件，例如：\nUPDATE students SET score=60; 这时，整个表的所有记录都会被更新\n删除数据\nDELETE语句的基本语法是：\nDELETE FROM \u003c表名\u003e WHERE ...; DELETE FROM students WHERE id=1; 删除id=1的记录\nMySQL MYSQL\nMySQL Server：真正的MySQL服务器\nMySQL Client：命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行\n输入命令mysql -u root -p，就连上了MySQL Server\n输入exit断开与MySQL Server的连接并返回到命令提示符\n也可安装MySQL Client，连接远程MySQL Server。假设远程MySQL Server的IP地址是10.0.1.99，那么就使用-h指定IP或域名：\nmysql -h 10.0.1.99 -u root -p 管理\n列出所有数据库：mysql\u003e SHOW DATABASES;\ninformation_schema、mysql、performance_schema和sys是系统库，不要去改动它们 创建一个新数据库：\nmysql\u003e CREATE DATABASE test; 删除一个数据库：\nmysql\u003e DROP DATABASE test; 对一个数据库进行操作时，要首先将其切换为当前数据库：\nmysql\u003e USE test; 列出当前数据库的所有表：\nmysql\u003e SHOW TABLES; 要查看一个表的结构：可以知道表的字段结构\nmysql\u003e DESC students; 使用以下命令查看创建表的SQL语句：可以知道表的字段结构\nmysql\u003e SHOW CREATE TABLE students; 创建表使用CREATE TABLE语句，而删除表使用DROP TABLE语句：\nmysql\u003e DROP TABLE students; 要给students表新增一列birth，使用：\nALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL; 修改birth列，例如把列名改为birthday，类型改为VARCHAR(20)：\nALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL; 删除列：\nALTER TABLE students DROP COLUMN birthday; EXIT命令退出MySQL：\nmysql\u003e EXIT 注意EXIT仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。\n实用快捷实用\n我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引\nSELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC; 实用技巧以后再更，不会影响正常实用 事务 某些业务要求，一系列操作必须全部执行，而不能仅执行一部分\n特性·\nA：Atomicity，原子性，将所有SQL作为原子工作单元执行 C：Consistency，一致性，事务完成后，所有数据的状态都是一致的 I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离 D：Durability，持久性，即事务完成后，对数据库数据的修改被持久化存储 单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务\n手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，这种事务被称为显式事务\n希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败\nBEGIN; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; ROLLBACK; 隔离级别\n两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读\n在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read\nSQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：\nIsolation Level 脏读（Dirty Read） 不可重复读（Non Repeatable Read） 幻读（Phantom Read） Read Uncommitted Yes Yes Yes Read Committed - Yes Yes Repeatable Read - - Yes Serializable - - - Read Uncommitted\n一个事务会读到另一个事务更新后但未提交的数据 Read Committed\n一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，在第一个事务中，两次读取的数据就可能不一致 Repeatable Read\n在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现 Serializable\n所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现 ","wordCount":"553","inLanguage":"en","datePublished":"2025-01-07T22:12:09+08:00","dateModified":"2025-01-07T22:12:09+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/sql00/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SQL语法</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#sql%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8 aria-label=SQL基本使用>SQL基本使用</a></li><li><a href=#%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93 aria-label=关系型数据库>关系型数据库</a></li><li><a href=#%e5%85%b3%e7%b3%bb%e6%a8%a1%e5%9e%8b aria-label=关系模型>关系模型</a></li><li><a href=#%e6%9f%a5%e8%af%a2%e6%95%b0%e6%8d%ae aria-label=查询数据>查询数据</a></li><li><a href=#%e4%bf%ae%e6%94%b9%e6%95%b0%e6%8d%ae aria-label=修改数据>修改数据</a></li><li><a href=#mysql aria-label=MySQL>MySQL</a><ul><li><a href=#%e5%ae%9e%e7%94%a8%e6%8a%80%e5%b7%a7%e4%bb%a5%e5%90%8e%e5%86%8d%e6%9b%b4%e4%b8%8d%e4%bc%9a%e5%bd%b1%e5%93%8d%e6%ad%a3%e5%b8%b8%e5%ae%9e%e7%94%a8 aria-label=实用技巧以后再更，不会影响正常实用>实用技巧以后再更，不会影响正常实用</a></li></ul></li><li><a href=#%e4%ba%8b%e5%8a%a1 aria-label=事务>事务</a></li></ul></div></details></div><div class=post-content><h3 id=sql基本使用>SQL基本使用<a hidden class=anchor aria-hidden=true href=#sql基本使用>#</a></h3><h3 id=关系型数据库>关系型数据库<a hidden class=anchor aria-hidden=true href=#关系型数据库>#</a></h3><ul><li><p>数据库：保存用户数据</p><ul><li>随着应用程序的功能越复杂，数据量越大，管理这些数据就成了大问题<ul><li><strong>读写文件并解析出数据需要大量重复代码；</strong></li><li><strong>从成千上万的数据中快速查询出指定数据需要复杂的逻辑</strong></li></ul></li></ul></li><li><p>数据模型</p><ul><li>层次模型：以“上下级”的层次关系来组织数据的一种方式，看起来就像一颗树</li><li>网状模型：每个数据节点和其他很多节点都连接起来，看起来就像很多城市之间的路网</li><li>关系模型：数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，看起来就是一个Excel表</li></ul></li><li><p>常见数据类型</p><ul><li><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>INT</td><td>整型</td><td>4字节整数类型，范围约+/-21亿</td></tr><tr><td>BIGINT</td><td>长整型</td><td>8字节整数类型，范围约+/-922亿亿</td></tr><tr><td>REAL</td><td>浮点型</td><td>4字节浮点数，范围约+/-1038</td></tr><tr><td>DOUBLE</td><td>浮点型</td><td>8字节浮点数，范围约+/-10308</td></tr><tr><td>DECIMAL(M,N)</td><td>高精度小数</td><td>由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td></tr><tr><td>CHAR(N)</td><td>定长字符串</td><td>存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td></tr><tr><td>VARCHAR(N)</td><td>变长字符串</td><td>存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td></tr><tr><td>BOOLEAN</td><td>布尔类型</td><td>存储True或者False</td></tr><tr><td>DATE</td><td>日期类型</td><td>存储日期，例如，2018-06-22</td></tr><tr><td>TIME</td><td>时间类型</td><td>存储时间，例如，12:20:59</td></tr><tr><td>DATETIME</td><td>日期和时间类型</td><td>存储日期+时间，例如，2018-06-22 12:20:59</td></tr></tbody></table></li></ul></li><li><p>SQL</p><ul><li>结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还对数据库进行管理和维护操做</li><li><strong>SQL语言关键字不区分大小写！！！但表名和列名不一定</strong></li></ul></li><li><p>MySQL本身只是一个SQL接口，内部包含多种数据引擎</p><ul><li><strong>InnoDB：一款支持事务的数据库引擎</strong></li><li><strong>MyISAM：MySQL早期默认数据库引擎，不支持事务</strong></li></ul></li></ul><h3 id=关系模型>关系模型<a hidden class=anchor aria-hidden=true href=#关系模型>#</a></h3><ul><li><p>表的<strong>每一行</strong>称为记录（Record），记录是一个逻辑意义上的数据。</p><p>表的<strong>每一列</strong>称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</p></li><li><p>主键</p><ul><li>记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响</li><li>主键的一个<strong>基本原则</strong>：不使用任何业务相关的字段作为主键，也不应该允许<code>NULL</code></li><li>一般字段命名为<code>id</code> ，常见类型有<ul><li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键</li><li><strong>全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code></strong>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的</li></ul></li><li>联合主键<ul><li>通过多个字段唯一标识记录，即两个或更多的字段都设置为主键</li></ul></li></ul></li><li><p>外键</p><ul><li><p>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<code>外键</code></p></li><li><p>定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在<code>id=99</code>的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录</p></li><li><p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> students
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>CONSTRAINT</span> fk_class_id
</span></span><span style=display:flex><span><span style=color:#66d9ef>FOREIGN</span> <span style=color:#66d9ef>KEY</span> (class_id)
</span></span><span style=display:flex><span><span style=color:#66d9ef>REFERENCES</span> classes (id);
</span></span></code></pre></div><p>外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）</p></li><li><p>删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> students
</span></span><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>FOREIGN</span> <span style=color:#66d9ef>KEY</span> fk_class_id;
</span></span></code></pre></div></li><li><p><strong>删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现</strong></p></li><li><p>多对多：两个一对多关系实现的，通过一个中间表，关联两个一对多关系</p></li><li><p>一对一：一个表的记录对应到另一个表的唯一一个记录</p></li></ul></li><li><p>索引</p><ul><li><p>关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度</p><p><strong>使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上</strong></p></li><li><p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高</p></li><li><p>优点提高查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引</p></li><li><p>关系数据库会自动对主键创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一</p></li><li><p>唯一索引：</p><ul><li><p>通过<code>UNIQUE</code>关键字我们就添加了一个唯一索引</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> students
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>UNIQUE</span> <span style=color:#66d9ef>INDEX</span> uni_name (name);
</span></span></code></pre></div></li><li><p>只对某一列添加一个唯一约束而不创建唯一索引</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> students
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>CONSTRAINT</span> uni_name <span style=color:#66d9ef>UNIQUE</span> (name);
</span></span></code></pre></div></li></ul></li></ul></li></ul><h3 id=查询数据>查询数据<a hidden class=anchor aria-hidden=true href=#查询数据>#</a></h3><ul><li><p><strong>在MySQL命令行客户端输入SQL后，记得加一个<code>;</code></strong></p></li><li><p>基本查询</p><ul><li>SELECT查询的基本语句<code>SELECT * FROM &lt;表名></code>可以查询一个表的所有行和所有列的数据</li><li>不带<code>FROM</code>子句的<code>SELECT</code>语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条<code>SELECT 1;</code></li></ul></li><li><p>条件查询</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>表名</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>WHERE</span> <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>条件表达式</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><ul><li>用<code>&lt;条件1> AND &lt;条件2></code>表达满足条件1并且满足条件2</li><li>用<code>&lt;条件1> OR &lt;条件2></code>，表示满足条件1或者满足条件2</li><li>用<code>NOT &lt;条件></code>，表示“不符合该条件”的记录</li><li>组合三个或者更多的条件，就需要用小括号<code>()</code>表示如何进行条件运算</li></ul></li></ul></li><li><p>投影查询</p><ul><li><p><strong>what : 使用<code>SELECT *</code>表示查询表的所有列，使用<code>SELECT 列1, 列2, 列3</code>则可以仅返回指定列，这种操作称为投影</strong></p></li><li><p>可以给每一列起个别名，结果集的列名就可以与原表的列名不同。语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code></p></li></ul></li><li><p>排序</p><ul><li><p>根据其他条件排序，可以加上<code>ORDER BY</code>子句</p><ul><li><code>ASC</code>：<strong>升序</strong>，即从小到大。<strong><code>ASC</code>可以省略</strong></li><li><code>DESC</code>：<strong>倒序</strong></li></ul></li><li><p>有相同的数据，要进一步排序，可以<strong>继续添加</strong>列名</p></li><li><p>有<code>WHERE</code>子句，那么<code>ORDER BY</code>子句要放到<code>WHERE</code>子句后面</p></li></ul></li><li><p>分页查询</p><ul><li><p><strong>why : 结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示</strong></p></li><li><p>查询可以通过<code>LIMIT &lt;N> OFFSET &lt;M></code>子句实现 <strong>M从0开始</strong></p><ul><li><code>LIMIT N</code>表示是<strong>最多N条记录</strong>。<code>OFFSET &lt;M></code>表示是<strong>从M号记录开始</strong></li><li>结果集分页，每页3条记录。获取第1页的记录，可以使用<code>LIMIT 3 OFFSET 0</code></li><li>要查询第2页，把<code>OFFSET</code>设定为3，<code>LIMIT 3 OFFSET 3</code></li><li>查询第2~4行，命令为 <code>LIMIT 3 OFFSET 1</code>简写为<code>LIMIT 1,3</code></li></ul></li><li><p><code>OFFSET</code>超过了查询的最大数量并不会报错，而是得到一个空的结果集</p></li><li><p><strong>重点：</strong></p><ul><li><p><code>OFFSET</code>是可选的，如果只写<code>LIMIT 15</code>，那么相当于<code>LIMIT 15 OFFSET 0</code>。</p></li><li><p>在MySQL中，<code>LIMIT 15 OFFSET 30</code>还可以简写成<code>LIMIT 30, 15</code>。</p></li><li><p>使用<code>LIMIT &lt;M> OFFSET &lt;N></code>分页时，随着<code>N</code>越来越大，查询效率也会越来越低</p></li></ul></li></ul></li><li><p>聚合查询</p><ul><li><p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询</p><ul><li><strong>使用聚合查询时，我们应该给列名设置一个别名，便于处理结果</strong></li><li><strong><code>COUNT(*)</code>和<code>COUNT(id)</code>实际上是一样的效果,查询所有列的行数</strong></li></ul></li><li><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SUM</td><td>计算某一列的合计值，该列必须为数值类型</td></tr><tr><td>AVG</td><td>计算某一列的平均值，该列必须为数值类型</td></tr><tr><td>MAX</td><td>计算某一列的最大值</td></tr><tr><td>MIN</td><td>计算某一列的最小值</td></tr></tbody></table><p><code>MAX()</code>和<code>MIN()</code>函数并不限于数值类型。如果是字符类型，<code>MAX()</code>和<code>MIN()</code>会返回排序最后和排序最前的字符</p></li><li><p><strong>如果聚合查询的<code>WHERE</code>条件没有匹配到任何行，<code>COUNT()</code>会返回0，而<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>和<code>MIN()</code>会返回<code>NULL</code></strong></p></li><li><p><strong>分组</strong></p><ul><li><code>GROUP BY</code>子句指定了按 <strong>该字段</strong> 分组</li><li>执行该<code>SELECT</code>语句时，会把<code>该字段</code>相同的列先分组，再分别计算</li><li>也可以使用多个列逐个进行分组</li></ul></li></ul></li><li><p>多表查询</p><ul><li>获取M x N行记录，结果集可能非常巨大，要小心使用</li></ul></li><li><p>连接查询</p><ul><li><p>对多个表进行JOIN运算，先确定一个主表作为结果集，再把其他表的行有选择性地“连接”在主表结果集上</p><ul><li><strong>注意INNER JOIN查询的写法是：</strong><ol><li>先确定主表，仍然使用<code>FROM &lt;表1></code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2></code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...></code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li></ol></li></ul></li><li><p><strong>区分</strong></p><ul><li>INNER JOIN只返回同时存在于两张表的行数据</li><li>RIGHT OUTER JOIN返回右表都存在的行</li><li>LEFT OUTER JOIN则返回左表都存在的行</li><li>FULL OUTER JOIN，把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL</li></ul></li><li><p><strong>假设查询语句是：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> ... <span style=color:#66d9ef>FROM</span> tableA <span style=color:#f92672>???</span> <span style=color:#66d9ef>JOIN</span> tableB <span style=color:#66d9ef>ON</span> tableA.column1 <span style=color:#f92672>=</span> tableB.column2;
</span></span></code></pre></div><p>我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录：</p><p><img loading=lazy src=../../static/png/inner-join.jpg alt=inner-join></p><p>LEFT OUTER JOIN是选出左表存在的记录：</p><p><img loading=lazy src=../../static/png/left-outer-join.jpg alt=left-outer-join></p><p>RIGHT OUTER JOIN是选出右表存在的记录：</p><p><img loading=lazy src=../../static/png/right-outer-join.jpg alt=right-outer-join></p><p>FULL OUTER JOIN则是选出左右表都存在的记录：</p><p><img loading=lazy src=../../static/png/full-outer-join.jpg alt=full-outer-join></p></li><li><p>总结</p><ul><li>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；</li><li>INNER JOIN是最常用的一种JOIN查询，它的语法是<code>SELECT ... FROM &lt;表1> INNER JOIN &lt;表2> ON &lt;条件...></code>；</li></ul></li></ul></li></ul><h3 id=修改数据>修改数据<a hidden class=anchor aria-hidden=true href=#修改数据>#</a></h3><ul><li><p>语句使用</p><ul><li><p>增：INSERT：插入新记录；</p></li><li><p>改：UPDATE：更新已有记录；</p></li><li><p>删：DELETE：删除已有记录；</p></li></ul></li><li><p>插入数据</p><ul><li><p><code>INSERT</code>语句的基本语法是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>表名</span><span style=color:#f92672>&gt;</span> (<span style=color:#960050;background-color:#1e0010>字段</span><span style=color:#ae81ff>1</span>, <span style=color:#960050;background-color:#1e0010>字段</span><span style=color:#ae81ff>2</span>, ...) <span style=color:#66d9ef>VALUES</span> (<span style=color:#960050;background-color:#1e0010>值</span><span style=color:#ae81ff>1</span>, <span style=color:#960050;background-color:#1e0010>值</span><span style=color:#ae81ff>2</span>, ...);
</span></span></code></pre></div></li><li><p>还可以一次性添加多条记录，只需要在<code>VALUES</code>子句中指定多个记录值，每个记录是由<code>(...)</code>包含的一组值，每组值用逗号<code>,</code>分隔</p></li></ul></li><li><p>更新数据</p><ul><li><p><code>UPDATE</code>语句的基本语法是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>表名</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SET</span> <span style=color:#960050;background-color:#1e0010>字段</span><span style=color:#ae81ff>1</span><span style=color:#f92672>=</span><span style=color:#960050;background-color:#1e0010>值</span><span style=color:#ae81ff>1</span>, <span style=color:#960050;background-color:#1e0010>字段</span><span style=color:#ae81ff>2</span><span style=color:#f92672>=</span><span style=color:#960050;background-color:#1e0010>值</span><span style=color:#ae81ff>2</span>, ... <span style=color:#66d9ef>WHERE</span> ...;
</span></span></code></pre></div></li><li><p>要特别小心的是，<code>UPDATE</code>语句可以没有<code>WHERE</code>条件，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> students <span style=color:#66d9ef>SET</span> score<span style=color:#f92672>=</span><span style=color:#ae81ff>60</span>;
</span></span></code></pre></div><p><strong>这时，整个表的所有记录都会被更新</strong></p></li></ul></li><li><p>删除数据</p><ul><li><p><code>DELETE</code>语句的基本语法是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>DELETE</span> <span style=color:#66d9ef>FROM</span> <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>表名</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>WHERE</span> ...;
</span></span></code></pre></div></li><li><p><code>DELETE FROM students WHERE id=1;</code> 删除id=1的记录</p></li></ul></li></ul><h3 id=mysql>MySQL<a hidden class=anchor aria-hidden=true href=#mysql>#</a></h3><ul><li><p>MYSQL</p><ul><li><p>MySQL Server：真正的MySQL服务器</p></li><li><p>MySQL Client：命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行</p></li><li><p>输入命令<code>mysql -u root -p</code>，就连上了MySQL Server</p></li><li><p>输入<code>exit</code>断开与MySQL Server的连接并返回到命令提示符</p></li><li><p>也可安装MySQL Client，连接远程MySQL Server。假设远程MySQL Server的IP地址是<code>10.0.1.99</code>，那么就使用<code>-h</code>指定IP或域名：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>mysql -h 10.0.1.99 -u root -p
</span></span></code></pre></div></li></ul></li><li><p>管理</p><ul><li><p>列出所有数据库：<code>mysql> SHOW DATABASES;</code></p><ul><li><code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>是系统库，不要去改动它们</li></ul></li><li><p>创建一个新数据库：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>mysql&gt; CREATE DATABASE test;
</span></span></code></pre></div></li><li><p>删除一个数据库：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>mysql&gt; DROP DATABASE test;
</span></span></code></pre></div></li><li><p>对一个数据库进行操作时，要首先将其切换为当前数据库：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>mysql&gt; USE test;
</span></span></code></pre></div></li><li><p>列出当前数据库的所有<strong>表</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>mysql&gt; SHOW TABLES;
</span></span></code></pre></div></li><li><p>要查看一个表的结构：<strong>可以知道表的字段结构</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>mysql&gt; DESC students;
</span></span></code></pre></div></li><li><p>使用以下命令查看创建表的SQL语句：<strong>可以知道表的字段结构</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>mysql&gt; SHOW CREATE TABLE students;
</span></span></code></pre></div></li><li><p><strong>创建表</strong>使用<code>CREATE TABLE</code>语句，而<strong>删除表</strong>使用<code>DROP TABLE</code>语句：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>mysql&gt; DROP TABLE students;
</span></span></code></pre></div></li><li><p>要给<code>students</code>表新增一列<code>birth</code>，使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;
</span></span></code></pre></div></li><li><p>修改<code>birth</code>列，例如把列名改为<code>birthday</code>，类型改为<code>VARCHAR(20)</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;
</span></span></code></pre></div></li><li><p>删除列：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>ALTER TABLE students DROP COLUMN birthday;
</span></span></code></pre></div></li><li><p><code>EXIT</code>命令退出MySQL：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>mysql&gt; EXIT
</span></span></code></pre></div><p><strong>注意<code>EXIT</code>仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。</strong></p></li></ul></li><li><p>实用快捷实用</p><ul><li><p>我们知道如何选择索引，可以使用<code>FORCE INDEX</code>强制查询使用指定的索引</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> students <span style=color:#66d9ef>FORCE</span> <span style=color:#66d9ef>INDEX</span> (idx_class_id) <span style=color:#66d9ef>WHERE</span> class_id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> id <span style=color:#66d9ef>DESC</span>;
</span></span></code></pre></div></li></ul></li></ul><h4 id=实用技巧以后再更不会影响正常实用>实用技巧以后再更，不会影响正常实用<a hidden class=anchor aria-hidden=true href=#实用技巧以后再更不会影响正常实用>#</a></h4><h3 id=事务>事务<a hidden class=anchor aria-hidden=true href=#事务>#</a></h3><ul><li><p>某些业务要求，<strong>一系列操作</strong>必须全部执行，而不能仅执行一部分</p><ul><li><p><strong>特性·</strong></p><ul><li>A：Atomicity，原子性，将所有SQL作为原子工作单元执行</li><li>C：Consistency，一致性，事务完成后，所有数据的状态都是一致的</li><li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离</li><li>D：Durability，持久性，即事务完成后，对数据库数据的修改被持久化存储</li></ul></li><li><p>单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<em><strong>隐式事务</strong></em></p></li><li><p>手动把多条SQL语句作为一个事务执行，使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<em><strong>显式事务</strong></em></p></li><li><p>希望<strong>主动让事务失败</strong>，这时，可以用<code>ROLLBACK</code>回滚事务，整个事务会失败</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>BEGIN</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> accounts <span style=color:#66d9ef>SET</span> balance <span style=color:#f92672>=</span> balance <span style=color:#f92672>-</span> <span style=color:#ae81ff>100</span> <span style=color:#66d9ef>WHERE</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> accounts <span style=color:#66d9ef>SET</span> balance <span style=color:#f92672>=</span> balance <span style=color:#f92672>+</span> <span style=color:#ae81ff>100</span> <span style=color:#66d9ef>WHERE</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>ROLLBACK</span>;
</span></span></code></pre></div></li></ul></li><li><p>隔离级别</p><ul><li><p>两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读</p></li><li><p>在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read</p></li><li><p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p><table><thead><tr><th>Isolation Level</th><th>脏读（Dirty Read）</th><th>不可重复读（Non Repeatable Read）</th><th>幻读（Phantom Read）</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Read Committed</td><td>-</td><td>Yes</td><td>Yes</td></tr><tr><td>Repeatable Read</td><td>-</td><td>-</td><td>Yes</td></tr><tr><td>Serializable</td><td>-</td><td>-</td><td>-</td></tr></tbody></table></li></ul></li><li><p>Read Uncommitted</p><ul><li>一个事务会读到另一个事务更新后但未提交的数据</li></ul></li><li><p>Read Committed</p><ul><li>一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，在第一个事务中，两次读取的数据就可能不一致</li></ul></li><li><p>Repeatable Read</p><ul><li>在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现</li></ul></li><li><p>Serializable</p><ul><li>所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/mysql/>MySQL</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/java00/><span class=title>« Prev Page</span><br><span>Java基础</span>
</a><a class=next href=https://zwlzls.github.io/posts/linux01/><span class=title>Next Page »</span><br><span>Linux01(命令)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>