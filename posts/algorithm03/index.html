<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hot100 | 我的博客</title>
<meta name=keywords content="算法"><meta name=description content="Hot100 回溯 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案
class Solution { List<List<Integer>>res; int len=0; public List<List<Integer>> permute(int[] nums) { this.res=new LinkedList<>(); this.len=nums.length; dfs(nums,new LinkedList<>(),new boolean[len]); return res; } public void dfs(int[] nums,LinkedList path,boolean[]p){ if(path.size()==len){ res.add(new LinkedList<>(path)); return; } for(int i=0;i<len;i++){ if(p[i]){ continue; } p[i]=true; path.add(nums[i]); dfs(nums,path,p); p[i]=false; path.remove(path.size()-1); } } } 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集
class Solution { List<List<Integer>>res=new LinkedList<>(); LinkedList<Integer>track=new LinkedList<>(); public List<List<Integer>> subsets(int[] nums) { backtracking(nums,0); return res; } public void backtracking(int[] nums,int start){ res."><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/algorithm03/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/algorithm03/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Hot100"><meta property="og:description" content="Hot100 回溯 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案
class Solution { List<List<Integer>>res; int len=0; public List<List<Integer>> permute(int[] nums) { this.res=new LinkedList<>(); this.len=nums.length; dfs(nums,new LinkedList<>(),new boolean[len]); return res; } public void dfs(int[] nums,LinkedList path,boolean[]p){ if(path.size()==len){ res.add(new LinkedList<>(path)); return; } for(int i=0;i<len;i++){ if(p[i]){ continue; } p[i]=true; path.add(nums[i]); dfs(nums,path,p); p[i]=false; path.remove(path.size()-1); } } } 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集
class Solution { List<List<Integer>>res=new LinkedList<>(); LinkedList<Integer>track=new LinkedList<>(); public List<List<Integer>> subsets(int[] nums) { backtracking(nums,0); return res; } public void backtracking(int[] nums,int start){ res."><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/algorithm03/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-24T13:13:09+08:00"><meta property="article:modified_time" content="2025-02-24T13:13:09+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hot100"><meta name=twitter:description content="Hot100 回溯 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案
class Solution { List<List<Integer>>res; int len=0; public List<List<Integer>> permute(int[] nums) { this.res=new LinkedList<>(); this.len=nums.length; dfs(nums,new LinkedList<>(),new boolean[len]); return res; } public void dfs(int[] nums,LinkedList path,boolean[]p){ if(path.size()==len){ res.add(new LinkedList<>(path)); return; } for(int i=0;i<len;i++){ if(p[i]){ continue; } p[i]=true; path.add(nums[i]); dfs(nums,path,p); p[i]=false; path.remove(path.size()-1); } } } 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集
class Solution { List<List<Integer>>res=new LinkedList<>(); LinkedList<Integer>track=new LinkedList<>(); public List<List<Integer>> subsets(int[] nums) { backtracking(nums,0); return res; } public void backtracking(int[] nums,int start){ res."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Hot100","item":"https://zwlzls.github.io/posts/algorithm03/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hot100","name":"Hot100","description":"Hot100 回溯 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案\nclass Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res; int len=0; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { this.res=new LinkedList\u0026lt;\u0026gt;(); this.len=nums.length; dfs(nums,new LinkedList\u0026lt;\u0026gt;(),new boolean[len]); return res; } public void dfs(int[] nums,LinkedList path,boolean[]p){ if(path.size()==len){ res.add(new LinkedList\u0026lt;\u0026gt;(path)); return; } for(int i=0;i\u0026lt;len;i++){ if(p[i]){ continue; } p[i]=true; path.add(nums[i]); dfs(nums,path,p); p[i]=false; path.remove(path.size()-1); } } } 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集\nclass Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res=new LinkedList\u0026lt;\u0026gt;(); LinkedList\u0026lt;Integer\u0026gt;track=new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { backtracking(nums,0); return res; } public void backtracking(int[] nums,int start){ res.","keywords":["算法"],"articleBody":"Hot100 回溯 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案\nclass Solution { List\u003cList\u003cInteger\u003e\u003eres; int len=0; public List\u003cList\u003cInteger\u003e\u003e permute(int[] nums) { this.res=new LinkedList\u003c\u003e(); this.len=nums.length; dfs(nums,new LinkedList\u003c\u003e(),new boolean[len]); return res; } public void dfs(int[] nums,LinkedList path,boolean[]p){ if(path.size()==len){ res.add(new LinkedList\u003c\u003e(path)); return; } for(int i=0;i\u003clen;i++){ if(p[i]){ continue; } p[i]=true; path.add(nums[i]); dfs(nums,path,p); p[i]=false; path.remove(path.size()-1); } } } 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集\nclass Solution { List\u003cList\u003cInteger\u003e\u003eres=new LinkedList\u003c\u003e(); LinkedList\u003cInteger\u003etrack=new LinkedList\u003c\u003e(); public List\u003cList\u003cInteger\u003e\u003e subsets(int[] nums) { backtracking(nums,0); return res; } public void backtracking(int[] nums,int start){ res.add(new LinkedList\u003c\u003e(track)); for(int i=start;i\u003cnums.length;i++){ track.addLast(nums[i]); backtracking(nums,i+1); track.removeLast(); } } } 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母\nclass Solution { public List\u003cString\u003e letterCombinations(String digits) { if(digits.length()\u003c1){ return new LinkedList\u003cString\u003e(); } List\u003cString\u003eres=new LinkedList\u003c\u003e(); res.add(\"\"); HashMap\u003cCharacter,String\u003emap=new HashMap\u003c\u003e(); map.put('2',\"abc\"); map.put('3',\"def\"); map.put('4',\"ghi\"); map.put('5',\"jkl\"); map.put('6',\"mno\"); map.put('7',\"pqrs\"); map.put('8',\"tuv\"); map.put('9',\"wxyz\"); for(Character c1:digits.toCharArray()){//取每个数字 LinkedList\u003cString\u003ene=new LinkedList\u003c\u003e(); for(Character c2:map.get(c1).toCharArray()){//取每个数字的对应值 for(String s1:res){//res存上一次组成的字符串，把新增加入存量字符串用ne StringBuffer s2=new StringBuffer(s1); s2.append(c2); String str=s2.toString(); ne.add(str); } } res=ne;//res指向新更新的值地址 } return res; } } 递归解法\nclass Solution { private static final String[] map = new String[]{\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; private final List\u003cString\u003e ans = new ArrayList\u003c\u003e(); private char[] digits; private char[] path; public List\u003cString\u003e letterCombinations(String digits) { int n = digits.length(); if (n == 0) { return new ArrayList\u003c\u003e(); } this.digits = digits.toCharArray(); path = new char[n]; // 存入一次完整路径字符串 dfs(0); return ans; } private void dfs(int i) { if (i == digits.length) { ans.add(new String(path)); return; } for (char c : map[digits[i] - '0'].toCharArray()) {//按每个数字所针对字符数弄分支 path[i] = c; // 直接覆盖 dfs(i + 1); } } } 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的\nclass Solution { List\u003cList\u003cInteger\u003e\u003eres=new LinkedList\u003c\u003e(); LinkedList\u003cInteger\u003etrack=new LinkedList\u003c\u003e(); int trackSum=0; public List\u003cList\u003cInteger\u003e\u003e combinationSum(int[] candidates, int target) { backtrack(candidates,target,0); return res; } void backtrack(int[] candidates,int target,int start){ if(trackSum==target){ res.add(new LinkedList\u003c\u003e(track)); return; } if(trackSum\u003etarget){ return; } for(int i=start;i\u003ccandidates.length;i++){ trackSum+=candidates[i]; track.addLast(candidates[i]); backtrack(candidates,target,i); trackSum-=candidates[i]; track.removeLast(); } } } ","wordCount":"313","inLanguage":"en","datePublished":"2025-02-24T13:13:09+08:00","dateModified":"2025-02-24T13:13:09+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/algorithm03/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Hot100</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#hot100 aria-label=Hot100>Hot100</a><ul><li><a href=#%e5%9b%9e%e6%ba%af aria-label=回溯>回溯</a></li></ul></li></ul></div></details></div><div class=post-content><h3 id=hot100>Hot100<a hidden class=anchor aria-hidden=true href=#hot100>#</a></h3><h4 id=回溯>回溯<a hidden class=anchor aria-hidden=true href=#回溯>#</a></h4><ul><li><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span>res;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> len<span style=color:#f92672>=</span>0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>permute</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>res</span><span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>len</span><span style=color:#f92672>=</span>nums.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        dfs(nums,<span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>(),<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[</span>len<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums,LinkedList path,<span style=color:#66d9ef>boolean</span><span style=color:#f92672>[]</span>p){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(path.<span style=color:#a6e22e>size</span>()<span style=color:#f92672>==</span>len){
</span></span><span style=display:flex><span>            res.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>(path));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0;i<span style=color:#f92672>&lt;</span>len;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(p<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            p<span style=color:#f92672>[</span>i<span style=color:#f92672>]=</span><span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            path.<span style=color:#a6e22e>add</span>(nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            dfs(nums,path,p);
</span></span><span style=display:flex><span>            p<span style=color:#f92672>[</span>i<span style=color:#f92672>]=</span><span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            path.<span style=color:#a6e22e>remove</span>(path.<span style=color:#a6e22e>size</span>()<span style=color:#f92672>-</span>1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span>res<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    LinkedList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span>track<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>subsets</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums) {
</span></span><span style=display:flex><span>        backtracking(nums,0);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>backtracking</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums,<span style=color:#66d9ef>int</span> start){
</span></span><span style=display:flex><span>        res.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>(track));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>start;i<span style=color:#f92672>&lt;</span>nums.<span style=color:#a6e22e>length</span>;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            track.<span style=color:#a6e22e>addLast</span>(nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            backtracking(nums,i<span style=color:#f92672>+</span>1);
</span></span><span style=display:flex><span>            track.<span style=color:#a6e22e>removeLast</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>letterCombinations</span>(String digits) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(digits.<span style=color:#a6e22e>length</span>()<span style=color:#f92672>&lt;</span>1){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>res<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        res.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>Character,String<span style=color:#f92672>&gt;</span>map<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#39;2&#39;</span>,<span style=color:#e6db74>&#34;abc&#34;</span>);
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#39;3&#39;</span>,<span style=color:#e6db74>&#34;def&#34;</span>);
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#39;4&#39;</span>,<span style=color:#e6db74>&#34;ghi&#34;</span>);
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#39;5&#39;</span>,<span style=color:#e6db74>&#34;jkl&#34;</span>);
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#39;6&#39;</span>,<span style=color:#e6db74>&#34;mno&#34;</span>);
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#39;7&#39;</span>,<span style=color:#e6db74>&#34;pqrs&#34;</span>);
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#39;8&#39;</span>,<span style=color:#e6db74>&#34;tuv&#34;</span>);
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#39;9&#39;</span>,<span style=color:#e6db74>&#34;wxyz&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(Character c1:digits.<span style=color:#a6e22e>toCharArray</span>()){<span style=color:#75715e>//取每个数字</span>
</span></span><span style=display:flex><span>            LinkedList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>ne<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(Character c2:map.<span style=color:#a6e22e>get</span>(c1).<span style=color:#a6e22e>toCharArray</span>()){<span style=color:#75715e>//取每个数字的对应值</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span>(String s1:res){<span style=color:#75715e>//res存上一次组成的字符串，把新增加入存量字符串用ne</span>
</span></span><span style=display:flex><span>                   StringBuffer s2<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> StringBuffer(s1);    
</span></span><span style=display:flex><span>                    s2.<span style=color:#a6e22e>append</span>(c2);
</span></span><span style=display:flex><span>                    String str<span style=color:#f92672>=</span>s2.<span style=color:#a6e22e>toString</span>();
</span></span><span style=display:flex><span>                    ne.<span style=color:#a6e22e>add</span>(str);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            res<span style=color:#f92672>=</span>ne;<span style=color:#75715e>//res指向新更新的值地址</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>递归解法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String<span style=color:#f92672>[]</span> map <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>[]</span>{<span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#e6db74>&#34;def&#34;</span>, <span style=color:#e6db74>&#34;ghi&#34;</span>, <span style=color:#e6db74>&#34;jkl&#34;</span>, <span style=color:#e6db74>&#34;mno&#34;</span>, <span style=color:#e6db74>&#34;pqrs&#34;</span>, <span style=color:#e6db74>&#34;tuv&#34;</span>, <span style=color:#e6db74>&#34;wxyz&#34;</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> ans <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>[]</span> digits;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>[]</span> path;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>letterCombinations</span>(String digits) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> digits.<span style=color:#a6e22e>length</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>digits</span> <span style=color:#f92672>=</span> digits.<span style=color:#a6e22e>toCharArray</span>();
</span></span><span style=display:flex><span>        path <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>[</span>n<span style=color:#f92672>]</span>; <span style=color:#75715e>// 存入一次完整路径字符串</span>
</span></span><span style=display:flex><span>        dfs(0);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> digits.<span style=color:#a6e22e>length</span>) {
</span></span><span style=display:flex><span>            ans.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> String(path));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span> c : map<span style=color:#f92672>[</span>digits<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span><span style=color:#f92672>]</span>.<span style=color:#a6e22e>toCharArray</span>()) {<span style=color:#75715e>//按每个数字所针对字符数弄分支</span>
</span></span><span style=display:flex><span>            path<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> c; <span style=color:#75715e>// 直接覆盖</span>
</span></span><span style=display:flex><span>            dfs(i <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span>res<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    LinkedList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span>track<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> trackSum<span style=color:#f92672>=</span>0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>combinationSum</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> candidates, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>        backtrack(candidates,target,0);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>backtrack</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> candidates,<span style=color:#66d9ef>int</span> target,<span style=color:#66d9ef>int</span> start){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(trackSum<span style=color:#f92672>==</span>target){
</span></span><span style=display:flex><span>            res.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>(track));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(trackSum<span style=color:#f92672>&gt;</span>target){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>start;i<span style=color:#f92672>&lt;</span>candidates.<span style=color:#a6e22e>length</span>;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            trackSum<span style=color:#f92672>+=</span>candidates<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            track.<span style=color:#a6e22e>addLast</span>(candidates<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            backtrack(candidates,target,i);
</span></span><span style=display:flex><span>            trackSum<span style=color:#f92672>-=</span>candidates<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            track.<span style=color:#a6e22e>removeLast</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/%E7%AE%97%E6%B3%95/>算法</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/algorithm06/><span class=title>« Prev Page</span><br><span>数据结构知识</span>
</a><a class=next href=https://zwlzls.github.io/posts/algorithm04/><span class=title>Next Page »</span><br><span>算法总结</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>