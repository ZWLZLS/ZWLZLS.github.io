<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hot100 | 我的博客</title>
<meta name=keywords content="算法"><meta name=description content="Hot100 哈希 两数之和
class Solution { public int[] twoSum(int[] nums, int target) { HashMap<Integer,Integer>map=new HashMap<>(); int len=nums.length; for(int i=0;i<len;i++){ int p=target-nums[i]; if(map.containsKey(p)){ return new int[]{i,map.get(p)}; } map.put(nums[i],i); } return new int[]{0,0}; } } 字母异位分组
class Solution { public List<List<String>> groupAnagrams(String[] strs) { HashMap<String,LinkedList<String>>cur=new HashMap<>(); for(String str:strs){ char[] c1=str.toCharArray(); Arrays.sort(c1); String s=String.valueOf(c1); if(!cur.containsKey(s)){ cur.put(s,new LinkedList<>()); cur.get(s).add(str); }else{ cur.get(s).add(str); } } return new LinkedList(cur.values()); } } 最长连续序列：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度
class Solution { public int longestConsecutive(int[] nums) { int ans = 0; Set<Integer> st = new HashSet<>(); for (int num : nums) { st."><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/algorithm01/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/algorithm01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Hot100"><meta property="og:description" content="Hot100 哈希 两数之和
class Solution { public int[] twoSum(int[] nums, int target) { HashMap<Integer,Integer>map=new HashMap<>(); int len=nums.length; for(int i=0;i<len;i++){ int p=target-nums[i]; if(map.containsKey(p)){ return new int[]{i,map.get(p)}; } map.put(nums[i],i); } return new int[]{0,0}; } } 字母异位分组
class Solution { public List<List<String>> groupAnagrams(String[] strs) { HashMap<String,LinkedList<String>>cur=new HashMap<>(); for(String str:strs){ char[] c1=str.toCharArray(); Arrays.sort(c1); String s=String.valueOf(c1); if(!cur.containsKey(s)){ cur.put(s,new LinkedList<>()); cur.get(s).add(str); }else{ cur.get(s).add(str); } } return new LinkedList(cur.values()); } } 最长连续序列：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度
class Solution { public int longestConsecutive(int[] nums) { int ans = 0; Set<Integer> st = new HashSet<>(); for (int num : nums) { st."><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/algorithm01/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-24T13:12:57+08:00"><meta property="article:modified_time" content="2025-02-24T13:12:57+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hot100"><meta name=twitter:description content="Hot100 哈希 两数之和
class Solution { public int[] twoSum(int[] nums, int target) { HashMap<Integer,Integer>map=new HashMap<>(); int len=nums.length; for(int i=0;i<len;i++){ int p=target-nums[i]; if(map.containsKey(p)){ return new int[]{i,map.get(p)}; } map.put(nums[i],i); } return new int[]{0,0}; } } 字母异位分组
class Solution { public List<List<String>> groupAnagrams(String[] strs) { HashMap<String,LinkedList<String>>cur=new HashMap<>(); for(String str:strs){ char[] c1=str.toCharArray(); Arrays.sort(c1); String s=String.valueOf(c1); if(!cur.containsKey(s)){ cur.put(s,new LinkedList<>()); cur.get(s).add(str); }else{ cur.get(s).add(str); } } return new LinkedList(cur.values()); } } 最长连续序列：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度
class Solution { public int longestConsecutive(int[] nums) { int ans = 0; Set<Integer> st = new HashSet<>(); for (int num : nums) { st."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Hot100","item":"https://zwlzls.github.io/posts/algorithm01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hot100","name":"Hot100","description":"Hot100 哈希 两数之和\nclass Solution { public int[] twoSum(int[] nums, int target) { HashMap\u0026lt;Integer,Integer\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); int len=nums.length; for(int i=0;i\u0026lt;len;i++){ int p=target-nums[i]; if(map.containsKey(p)){ return new int[]{i,map.get(p)}; } map.put(nums[i],i); } return new int[]{0,0}; } } 字母异位分组\nclass Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { HashMap\u0026lt;String,LinkedList\u0026lt;String\u0026gt;\u0026gt;cur=new HashMap\u0026lt;\u0026gt;(); for(String str:strs){ char[] c1=str.toCharArray(); Arrays.sort(c1); String s=String.valueOf(c1); if(!cur.containsKey(s)){ cur.put(s,new LinkedList\u0026lt;\u0026gt;()); cur.get(s).add(str); }else{ cur.get(s).add(str); } } return new LinkedList(cur.values()); } } 最长连续序列：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度\nclass Solution { public int longestConsecutive(int[] nums) { int ans = 0; Set\u0026lt;Integer\u0026gt; st = new HashSet\u0026lt;\u0026gt;(); for (int num : nums) { st.","keywords":["算法"],"articleBody":"Hot100 哈希 两数之和\nclass Solution { public int[] twoSum(int[] nums, int target) { HashMap\u003cInteger,Integer\u003emap=new HashMap\u003c\u003e(); int len=nums.length; for(int i=0;i\u003clen;i++){ int p=target-nums[i]; if(map.containsKey(p)){ return new int[]{i,map.get(p)}; } map.put(nums[i],i); } return new int[]{0,0}; } } 字母异位分组\nclass Solution { public List\u003cList\u003cString\u003e\u003e groupAnagrams(String[] strs) { HashMap\u003cString,LinkedList\u003cString\u003e\u003ecur=new HashMap\u003c\u003e(); for(String str:strs){ char[] c1=str.toCharArray(); Arrays.sort(c1); String s=String.valueOf(c1); if(!cur.containsKey(s)){ cur.put(s,new LinkedList\u003c\u003e()); cur.get(s).add(str); }else{ cur.get(s).add(str); } } return new LinkedList(cur.values()); } } 最长连续序列：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度\nclass Solution { public int longestConsecutive(int[] nums) { int ans = 0; Set\u003cInteger\u003e st = new HashSet\u003c\u003e(); for (int num : nums) { st.add(num); // 把 nums 转成哈希集合 } for (int x : st) { if (st.contains(x - 1)) { continue; } // x 是序列的起点 int y = x + 1; while (st.contains(y)) { // 不断查找下一个数是否在哈希集合中 y++; } // 循环结束后，y-1 是最后一个在哈希集合中的数 ans = Math.max(ans, y - x); // 从 x 到 y-1 一共 y-x 个数 } return ans; } } 双指针 移动零\nclass Solution { public void moveZeroes(int[] nums) { int l=0; for(int j=0;j\u003cnums.length;j++){ if(nums[j]!=0){ nums[l]=nums[j]; l++; } } for(int i=l;i\u003cnums.length;i++){ nums[i]=0; } } } 盛最多水的容器\nclass Solution { public int maxArea(int[] height) { int res=0; int l=0,r=height.length-1; while(l\u003cr){ int max=0; if(height[l]\u003cheight[r]){ max=height[l]*(r-l); l++; }else{ max=height[r]*(r-l); r--; } res=Math.max(res,max); } return res; } } 三数之和\nclass Solution { public List\u003cList\u003cInteger\u003e\u003e threeSum(int[] nums) { Arrays.sort(nums); List\u003cList\u003cInteger\u003e\u003eres=new LinkedList\u003c\u003e(); int len=nums.length; for(int i=0;i\u003clen-2;i++){ if(i\u003e0\u0026\u0026nums[i]==nums[i-1]) continue; int l=i+1,r=nums.length-1; while(l\u003cr){ int sum=nums[i]+nums[l]+nums[r]; if(sum==0){ LinkedList\u003cInteger\u003etrack=new LinkedList\u003c\u003e(); track.add(nums[l]); track.add(nums[i]); track.add(nums[r]); res.add(track); while(l\u003cr\u0026\u0026nums[l]==nums[l+1]){ l++; } while(l\u003cr\u0026\u0026nums[r]==nums[r-1]){ r--; } l++; r--; }else if(sum\u003e0){ r--; }else{ l++; } } } return res; } } 无重复字符的最长子串\nclass Solution { public int lengthOfLongestSubstring(String s) { int len=s.length(); if(len\u003c=1){ return len; } int[] res=new int[128]; int l=0,r=0,max=0; while(r\u003clen){ char c=s.charAt(r++); res[c]++; while(res[c]\u003e1){ char c1=s.charAt(l++); res[c1]--; } max=Math.max(max,r-l); } return max; } } 找到字符串中所有字母异位词\nclass Solution { public List\u003cInteger\u003e findAnagrams(String s, String p) { List\u003cInteger\u003eres=new LinkedList\u003c\u003e(); HashMap\u003cCharacter,Integer\u003eneed=new HashMap\u003c\u003e(); HashMap\u003cCharacter,Integer\u003ewindow=new HashMap\u003c\u003e(); for(char c:p.toCharArray()){ need.put(c,need.getOrDefault(c,0)+1); } int left=0,right=0,viald=0; while(right\u003cs.length()){ char c=s.charAt(right++); if(need.containsKey(c)){ window.put(c,window.getOrDefault(c,0)+1); if(window.get(c).equals(need.get(c))){ viald++;//p都是单个的，可直接匹配 } } while(right-left\u003e=p.length()){ if(viald==need.size()){ res.add(left); } char d=s.charAt(left++); if(need.containsKey(d)){ if(window.get(d).equals(need.get(d))){ viald--; } window.put(d,window.get(d)-1); } } } return res; } } 子串 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列\nclass Solution { public int subarraySum(int[] nums, int k) { HashMap\u003cInteger,Integer\u003emap=new HashMap\u003c\u003e(); int cur=0,res=0; map.put(k,1); for(int num:nums){ cur+=num; if(map.containsKey(cur)){ res+=map.get(cur); } map.put(cur+k,map.getOrDefault(cur+k,0)+1); } return res; } } 前缀和，假设：hash第一次存 前缀和+k，如果之后 前缀和 可以在hash中找到，那么说明之间距离为k hash存这个前缀和数字出现次数\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位\n返回 滑动窗口中的最大值\nclass Solution { public int[] maxSlidingWindow(int[] nums, int k) { Deque\u003cInteger\u003e q = new LinkedList\u003c\u003e(); for (int i = 0; i \u003c k; i++) { while (!q.isEmpty() \u0026\u0026 nums[i] \u003e q.peekLast()) { q.pollLast();//只放最大 } q.addLast(nums[i]); } int res[] = new int[nums.length - k + 1]; res[0] = q.peekFirst(); int temp = 1; for (int i = k, j = 0; i \u003c nums.length; i++, j++) { if (nums[j] == q.peekFirst()) {//按滑动窗口去除 q.pollFirst(); } while (!q.isEmpty() \u0026\u0026 nums[i] \u003e q.peekLast()) { q.pollLast();//只放最大的 } q.addLast(nums[i]); res[temp++] = q.peekFirst();//最大永远在前面 } return res; } } ​\t双端队列从左往右，那么左边为last，右边为first（想成汽车）\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\"\nclass Solution { public String minWindow(String s, String t) { // 初始化 need 和 window 哈希表 HashMap\u003cCharacter, Integer\u003e need = new HashMap\u003c\u003e(); HashMap\u003cCharacter, Integer\u003e window = new HashMap\u003c\u003e(); // 统计 t 中每个字符的出现次数 for (char c : t.toCharArray()) { need.put(c, need.getOrDefault(c, 0) + 1); } // 初始化变量 int temp = 0; // 记录窗口中满足 need 条件的字符个数 int start = 0; // 记录最小子串的起始位置 int len = Integer.MAX_VALUE; // 记录最小子串的长度 String res = \"\"; // 最终结果 int left = 0, right = 0; // 滑动窗口的左右边界 // 开始滑动窗口 while (right \u003c s.length()) { char c = s.charAt(right); // 获取当前字符 right++; // 扩大窗口 // 如果当前字符是 t 中的字符，更新 window 哈希表 if (need.containsKey(c)) { window.put(c, window.getOrDefault(c, 0) + 1); // 如果当前字符的出现次数满足 need 的条件，temp++ if (window.get(c).equals(need.get(c))) { temp++; } } // 当窗口满足条件时，尝试缩小窗口 while (temp == need.size()) { // 更新最小子串的起始位置和长度 if (right - left \u003c len) { start = left; len = right - left; } char d = s.charAt(left); // 获取左边界字符 left++; // 缩小窗口 // 如果左边界字符是 t 中的字符，更新 window 哈希表 if (need.containsKey(d)) { // 如果当前字符的出现次数不再满足 need 的条件，temp-- if (window.get(d).equals(need.get(d))) { temp--; } window.put(d, window.get(d) - 1); } } } // 返回结果 return len == Integer.MAX_VALUE ? \"\" : s.substring(start, start + len); } } 数组 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组是数组中的一个连续部分\nclass Solution { public int maxSubArray(int[] nums) { if(nums.length\u003c1){ return 0; } int res=nums[0],max=0; for(int num:nums){//上次能否大于0，为这次使用 if(max\u003c=0){ max=num; }else{ max=max+num; } res=Math.max(res,max); } return res; } } 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间\nclass Solution { public int[][] merge(int[][] intervals) { if(intervals==null||intervals.length\u003c2){ return intervals; } ArrayList\u003cint[]\u003elist1=new ArrayList\u003c\u003e(); Arrays.sort(intervals, (e1, e2) -\u003e Integer.compare(e1[0], e2[0])); for(int[] interval:intervals){ if(list1.isEmpty()||interval[0]\u003elist1.get(list1.size()-1)[1]){ list1.add(interval); }else{ list1.get(list1.size()-1)[1]=Math.max(list1.get(list1.size()-1)[1],interval[1]); } } return list1.toArray(new int[list1.size()][2]); } } 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数\nclass Solution { public void rotate(int[] nums, int k) { int len=nums.length; k=k%len; reverse(nums,0,len-1); reverse(nums,0,k-1); reverse(nums,k,len-1); } private void reverse(int[] nums, int i, int j) { while (i \u003c j) { int temp = nums[i]; nums[i++] = nums[j]; nums[j--] = temp; } } } 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。\n题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。\n请 **不要使用除法，**且在 O(n) 时间复杂度内完成此题\nclass Solution { public int[] productExceptSelf(int[] nums) { int len=nums.length; int[]res=new int[len]; int k=1; for(int i=0;i\u003clen;i++){ res[i]=k; k=k*nums[i]; } k=1; for(int i=len-1;i\u003e=0;i--){ res[i]*=k; k=k*nums[i]; } return res; } } 矩阵 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素\nclass Solution { public List\u003cInteger\u003e spiralOrder(int[][] matrix) { List\u003cInteger\u003eres=new LinkedList\u003c\u003e(); int l=0,r=matrix[0].length-1; int u=0,d=matrix.length-1; while(l\u003c=r\u0026\u0026u\u003c=d){ for(int i=l;i\u003c=r;i++){ res.add(matrix[l][i]); } for(int i=l+1;i\u003c=d;i++){ res.add(matrix[i][r]); } if(u==d||l==r){ break; } for(int i=r-1;i\u003e=l;i--){ res.add(matrix[d][i]); } for(int i=d-1;i\u003eu;i--){ res.add(matrix[i][l]); } u++; d--; l++; r--; } return res; } } 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n你必须在** 原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像\nclass Solution { public void rotate(int[][] matrix) { int n=matrix.length; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003c(n-i);j++){ int temp=matrix[i][j]; matrix[i][j]=matrix[n-j-1][n-i-1]; matrix[n-j-1][n-i-1]=temp; } } for(int i=0;i\u003cn/2;i++){ for(int j=0;j\u003cn;j++){ int temp=matrix[i][j]; matrix[i][j]=matrix[n-1-i][j]; matrix[n-1-i][j]=temp; } } } } 编写一个高效的算法来搜索 *m* x *n* 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：\n每行的元素从左到右升序排列。 每列的元素从上到下升序排列 class Solution { public boolean searchMatrix(int[][] matrix, int target) { if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false; int m = matrix.length, n = matrix[0].length; int row = 0, col = n - 1; while (row \u003c m \u0026\u0026 col \u003e= 0) { if (target == matrix[row][col]) return true; else if (target \u003c matrix[row][col]) col--; else row++; } return false; } } 链表 相交链表\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p1=headA,p2=headB; while(p1!=p2){ if(p1!=null){ p1=p1.next; }else{ p1=headB; } if(p2!=null){ p2=p2.next; }else{ p2=headA; } } return p1; } } 反转链表\nclass Solution { public ListNode reverseList(ListNode head) { if(head==null||head.next==null){ return head; } ListNode pre=reverseList(head.next); head.next.next=head; head.next=null; return pre; } } 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false\nclass Solution { public boolean isPalindrome(ListNode head) { ListNode slow=head,fast=head; while(fast!=null\u0026\u0026fast.next!=null){ slow=slow.next; fast=fast.next.next; } if(fast!=null\u0026\u0026fast.next==null){//为奇数设置 slow=slow.next; } ListNode flag=head; ListNode temp=serve(slow); while(temp!=null){ if(temp.val!=flag.val){ return false; } temp=temp.next; flag=flag.next; } return true; } public ListNode serve(ListNode head){//反转 ListNode cur=head,pre=null; while(cur!=null){ ListNode nex=cur.next; cur.next=pre; pre=cur; cur=nex; } return pre; } } 给你一个链表的头节点 head ，判断链表中是否有环\npublic class Solution { public boolean hasCycle(ListNode head) { ListNode fast=head; ListNode slow=head; while(fast!=null\u0026\u0026fast.next!=null){ fast=fast.next.next; slow=slow.next; if(fast==slow){ return true; } } return false; } } 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null\npublic class Solution { public ListNode detectCycle(ListNode head) { ListNode fast=head,slow=head; while(fast!=null\u0026\u0026fast.next!=null){ slow=slow.next; fast=fast.next.next; if(slow==fast) break; } if(fast==null||fast.next==null) return null; fast=head; while(fast!=slow){ slow=slow.next; fast=fast.next; } return fast; } } 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的\nclass Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode p1=list1; ListNode p2=list2; ListNode cur=new ListNode(); ListNode res=cur; while(p1!=null\u0026\u0026p2!=null){ if(p1.val\u003cp2.val){ res.next=p1; p1=p1.next; }else{ res.next=p2; p2=p2.next; } res=res.next; } while(p1!=null){ res.next=p1; p1=p1.next; res=res.next; } while(p2!=null){ res.next=p2; p2=p2.next; res=res.next; } return cur.next; } } 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点\nclass Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if(head==null||n==0){ return head; } ListNode dummy = new ListNode(0, head);//防止n刚好删去头结点 ListNode fast=dummy; ListNode slow=dummy; while(fast!=null\u0026\u0026n--\u003e0) fast=fast.next; if(n\u003e0){ return null; } while(fast.next!=null){ fast=fast.next; slow=slow.next; } slow.next=slow.next.next; return dummy.next; } } 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。\nk 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序\nclass Solution { public ListNode reverseKGroup(ListNode head, int k) { ListNode last=head; for(int i=0;i\u003ck;i++){ if(last==null){ return head; } last=last.next; } ListNode t=res(head,last); ListNode temp=t;//反转后的位置逻辑和head其实一样 for(int i=0;i\u003ck-1;i++){ temp=temp.next; } temp.next=reverseKGroup(last,k); return t; } public ListNode res(ListNode head,ListNode tail){ if(head==null||head.next==null){ return head; } ListNode cur=head,nex=head; ListNode pre=tail; while(nex!=tail){ nex=nex.next; cur.next=pre; pre=cur; cur=nex; } return pre; } } ","wordCount":"1369","inLanguage":"en","datePublished":"2025-02-24T13:12:57+08:00","dateModified":"2025-02-24T13:12:57+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/algorithm01/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Hot100</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#hot100 aria-label=Hot100>Hot100</a><ul><li><a href=#%e5%93%88%e5%b8%8c aria-label=哈希>哈希</a></li><li><a href=#%e5%8f%8c%e6%8c%87%e9%92%88 aria-label=双指针>双指针</a></li><li><a href=#%e5%ad%90%e4%b8%b2 aria-label=子串>子串</a></li><li><a href=#%e6%95%b0%e7%bb%84 aria-label=数组>数组</a></li><li><a href=#%e7%9f%a9%e9%98%b5 aria-label=矩阵>矩阵</a></li><li><a href=#%e9%93%be%e8%a1%a8 aria-label=链表>链表</a></li></ul></li></ul></div></details></div><div class=post-content><h3 id=hot100>Hot100<a hidden class=anchor aria-hidden=true href=#hot100>#</a></h3><h4 id=哈希>哈希<a hidden class=anchor aria-hidden=true href=#哈希>#</a></h4><ul><li><p>两数之和</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>twoSum</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>Integer,Integer<span style=color:#f92672>&gt;</span>map<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> len<span style=color:#f92672>=</span>nums.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0;i<span style=color:#f92672>&lt;</span>len;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> p<span style=color:#f92672>=</span>target<span style=color:#f92672>-</span>nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(map.<span style=color:#a6e22e>containsKey</span>(p)){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span>{i,map.<span style=color:#a6e22e>get</span>(p)};
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            map.<span style=color:#a6e22e>put</span>(nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>,i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span>{0,0};
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>字母异位分组</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>groupAnagrams</span>(String<span style=color:#f92672>[]</span> strs) {
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>String,LinkedList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span>cur<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(String str:strs){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>char</span><span style=color:#f92672>[]</span> c1<span style=color:#f92672>=</span>str.<span style=color:#a6e22e>toCharArray</span>();
</span></span><span style=display:flex><span>            Arrays.<span style=color:#a6e22e>sort</span>(c1);
</span></span><span style=display:flex><span>            String s<span style=color:#f92672>=</span>String.<span style=color:#a6e22e>valueOf</span>(c1);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>cur.<span style=color:#a6e22e>containsKey</span>(s)){
</span></span><span style=display:flex><span>                cur.<span style=color:#a6e22e>put</span>(s,<span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>());
</span></span><span style=display:flex><span>                cur.<span style=color:#a6e22e>get</span>(s).<span style=color:#a6e22e>add</span>(str);
</span></span><span style=display:flex><span>            }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>                cur.<span style=color:#a6e22e>get</span>(s).<span style=color:#a6e22e>add</span>(str);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> LinkedList(cur.<span style=color:#a6e22e>values</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>最长连续序列：给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>longestConsecutive</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> ans <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        Set<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> st <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashSet<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> num : nums) {
</span></span><span style=display:flex><span>            st.<span style=color:#a6e22e>add</span>(num); <span style=color:#75715e>// 把 nums 转成哈希集合</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> x : st) { 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (st.<span style=color:#a6e22e>contains</span>(x <span style=color:#f92672>-</span> 1)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// x 是序列的起点</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> 1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (st.<span style=color:#a6e22e>contains</span>(y)) { <span style=color:#75715e>// 不断查找下一个数是否在哈希集合中</span>
</span></span><span style=display:flex><span>                y<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 循环结束后，y-1 是最后一个在哈希集合中的数</span>
</span></span><span style=display:flex><span>            ans <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>max</span>(ans, y <span style=color:#f92672>-</span> x); <span style=color:#75715e>// 从 x 到 y-1 一共 y-x 个数</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h4 id=双指针>双指针<a hidden class=anchor aria-hidden=true href=#双指针>#</a></h4><ul><li><p>移动零</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>moveZeroes</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> l<span style=color:#f92672>=</span>0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span>0;j<span style=color:#f92672>&lt;</span>nums.<span style=color:#a6e22e>length</span>;j<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(nums<span style=color:#f92672>[</span>j<span style=color:#f92672>]!=</span>0){
</span></span><span style=display:flex><span>                nums<span style=color:#f92672>[</span>l<span style=color:#f92672>]=</span>nums<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                l<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>l;i<span style=color:#f92672>&lt;</span>nums.<span style=color:#a6e22e>length</span>;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]=</span>0;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>盛最多水的容器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>maxArea</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> height) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> res<span style=color:#f92672>=</span>0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> l<span style=color:#f92672>=</span>0,r<span style=color:#f92672>=</span>height.<span style=color:#a6e22e>length</span><span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(l<span style=color:#f92672>&lt;</span>r){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> max<span style=color:#f92672>=</span>0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(height<span style=color:#f92672>[</span>l<span style=color:#f92672>]&lt;</span>height<span style=color:#f92672>[</span>r<span style=color:#f92672>]</span>){
</span></span><span style=display:flex><span>                max<span style=color:#f92672>=</span>height<span style=color:#f92672>[</span>l<span style=color:#f92672>]*</span>(r<span style=color:#f92672>-</span>l);
</span></span><span style=display:flex><span>                l<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>                max<span style=color:#f92672>=</span>height<span style=color:#f92672>[</span>r<span style=color:#f92672>]*</span>(r<span style=color:#f92672>-</span>l);
</span></span><span style=display:flex><span>                r<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            res<span style=color:#f92672>=</span>Math.<span style=color:#a6e22e>max</span>(res,max);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>三数之和</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>threeSum</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums) {
</span></span><span style=display:flex><span>        Arrays.<span style=color:#a6e22e>sort</span>(nums);
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span>res<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> len<span style=color:#f92672>=</span>nums.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0;i<span style=color:#f92672>&lt;</span>len<span style=color:#f92672>-</span>2;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(i<span style=color:#f92672>&gt;</span>0<span style=color:#f92672>&amp;&amp;</span>nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]==</span>nums<span style=color:#f92672>[</span>i<span style=color:#f92672>-</span>1<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> l<span style=color:#f92672>=</span>i<span style=color:#f92672>+</span>1,r<span style=color:#f92672>=</span>nums.<span style=color:#a6e22e>length</span><span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span>(l<span style=color:#f92672>&lt;</span>r){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> sum<span style=color:#f92672>=</span>nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]+</span>nums<span style=color:#f92672>[</span>l<span style=color:#f92672>]+</span>nums<span style=color:#f92672>[</span>r<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(sum<span style=color:#f92672>==</span>0){
</span></span><span style=display:flex><span>                   LinkedList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span>track<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>                    track.<span style=color:#a6e22e>add</span>(nums<span style=color:#f92672>[</span>l<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>                    track.<span style=color:#a6e22e>add</span>(nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>                    track.<span style=color:#a6e22e>add</span>(nums<span style=color:#f92672>[</span>r<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>                    res.<span style=color:#a6e22e>add</span>(track);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span>(l<span style=color:#f92672>&lt;</span>r<span style=color:#f92672>&amp;&amp;</span>nums<span style=color:#f92672>[</span>l<span style=color:#f92672>]==</span>nums<span style=color:#f92672>[</span>l<span style=color:#f92672>+</span>1<span style=color:#f92672>]</span>){
</span></span><span style=display:flex><span>                    l<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>while</span>(l<span style=color:#f92672>&lt;</span>r<span style=color:#f92672>&amp;&amp;</span>nums<span style=color:#f92672>[</span>r<span style=color:#f92672>]==</span>nums<span style=color:#f92672>[</span>r<span style=color:#f92672>-</span>1<span style=color:#f92672>]</span>){
</span></span><span style=display:flex><span>                    r<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    l<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                    r<span style=color:#f92672>--</span>; 
</span></span><span style=display:flex><span>                }<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(sum<span style=color:#f92672>&gt;</span>0){
</span></span><span style=display:flex><span>                    r<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>                    l<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>无重复字符的最长子串</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lengthOfLongestSubstring</span>(String s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> len<span style=color:#f92672>=</span>s.<span style=color:#a6e22e>length</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(len<span style=color:#f92672>&lt;=</span>1){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> len;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> res<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>128<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> l<span style=color:#f92672>=</span>0,r<span style=color:#f92672>=</span>0,max<span style=color:#f92672>=</span>0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(r<span style=color:#f92672>&lt;</span>len){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>char</span> c<span style=color:#f92672>=</span>s.<span style=color:#a6e22e>charAt</span>(r<span style=color:#f92672>++</span>);
</span></span><span style=display:flex><span>            res<span style=color:#f92672>[</span>c<span style=color:#f92672>]++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span>(res<span style=color:#f92672>[</span>c<span style=color:#f92672>]&gt;</span>1){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>char</span> c1<span style=color:#f92672>=</span>s.<span style=color:#a6e22e>charAt</span>(l<span style=color:#f92672>++</span>);
</span></span><span style=display:flex><span>                res<span style=color:#f92672>[</span>c1<span style=color:#f92672>]--</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            max<span style=color:#f92672>=</span>Math.<span style=color:#a6e22e>max</span>(max,r<span style=color:#f92672>-</span>l);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>找到字符串中所有字母异位词</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>findAnagrams</span>(String s, String p) {
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span>res<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>Character,Integer<span style=color:#f92672>&gt;</span>need<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>Character,Integer<span style=color:#f92672>&gt;</span>window<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>char</span> c:p.<span style=color:#a6e22e>toCharArray</span>()){
</span></span><span style=display:flex><span>            need.<span style=color:#a6e22e>put</span>(c,need.<span style=color:#a6e22e>getOrDefault</span>(c,0)<span style=color:#f92672>+</span>1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> left<span style=color:#f92672>=</span>0,right<span style=color:#f92672>=</span>0,viald<span style=color:#f92672>=</span>0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(right<span style=color:#f92672>&lt;</span>s.<span style=color:#a6e22e>length</span>()){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>char</span> c<span style=color:#f92672>=</span>s.<span style=color:#a6e22e>charAt</span>(right<span style=color:#f92672>++</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(need.<span style=color:#a6e22e>containsKey</span>(c)){
</span></span><span style=display:flex><span>                window.<span style=color:#a6e22e>put</span>(c,window.<span style=color:#a6e22e>getOrDefault</span>(c,0)<span style=color:#f92672>+</span>1);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(window.<span style=color:#a6e22e>get</span>(c).<span style=color:#a6e22e>equals</span>(need.<span style=color:#a6e22e>get</span>(c))){
</span></span><span style=display:flex><span>                    viald<span style=color:#f92672>++</span>;<span style=color:#75715e>//p都是单个的，可直接匹配</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span>(right<span style=color:#f92672>-</span>left<span style=color:#f92672>&gt;=</span>p.<span style=color:#a6e22e>length</span>()){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(viald<span style=color:#f92672>==</span>need.<span style=color:#a6e22e>size</span>()){
</span></span><span style=display:flex><span>                    res.<span style=color:#a6e22e>add</span>(left);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>char</span> d<span style=color:#f92672>=</span>s.<span style=color:#a6e22e>charAt</span>(left<span style=color:#f92672>++</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(need.<span style=color:#a6e22e>containsKey</span>(d)){
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span>(window.<span style=color:#a6e22e>get</span>(d).<span style=color:#a6e22e>equals</span>(need.<span style=color:#a6e22e>get</span>(d))){
</span></span><span style=display:flex><span>                        viald<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    window.<span style=color:#a6e22e>put</span>(d,window.<span style=color:#a6e22e>get</span>(d)<span style=color:#f92672>-</span>1);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h4 id=子串>子串<a hidden class=anchor aria-hidden=true href=#子串>#</a></h4><ul><li><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。
子数组是数组中元素的连续非空序列</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>subarraySum</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>Integer,Integer<span style=color:#f92672>&gt;</span>map<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> cur<span style=color:#f92672>=</span>0,res<span style=color:#f92672>=</span>0;
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>put</span>(k,1);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> num:nums){
</span></span><span style=display:flex><span>            cur<span style=color:#f92672>+=</span>num;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(map.<span style=color:#a6e22e>containsKey</span>(cur)){
</span></span><span style=display:flex><span>                res<span style=color:#f92672>+=</span>map.<span style=color:#a6e22e>get</span>(cur);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            map.<span style=color:#a6e22e>put</span>(cur<span style=color:#f92672>+</span>k,map.<span style=color:#a6e22e>getOrDefault</span>(cur<span style=color:#f92672>+</span>k,0)<span style=color:#f92672>+</span>1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>前缀和，假设：hash第一次存 前缀和+k，如果之后 前缀和 可以在hash中找到，那么说明之间距离为k
hash存这个前缀和数字出现次数</p></li><li><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位</p><p>返回 <em>滑动窗口中的最大值</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>maxSlidingWindow</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        Deque<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> q <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> k; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>&amp;&amp;</span> nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>&gt;</span> q.<span style=color:#a6e22e>peekLast</span>()) {
</span></span><span style=display:flex><span>                q.<span style=color:#a6e22e>pollLast</span>();<span style=color:#75715e>//只放最大</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            q.<span style=color:#a6e22e>addLast</span>(nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> res<span style=color:#f92672>[]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>nums.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> k <span style=color:#f92672>+</span> 1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        res<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> q.<span style=color:#a6e22e>peekFirst</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> temp <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> k, j <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> nums.<span style=color:#a6e22e>length</span>; i<span style=color:#f92672>++</span>, j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (nums<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> q.<span style=color:#a6e22e>peekFirst</span>()) {<span style=color:#75715e>//按滑动窗口去除</span>
</span></span><span style=display:flex><span>                q.<span style=color:#a6e22e>pollFirst</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>&amp;&amp;</span> nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>&gt;</span> q.<span style=color:#a6e22e>peekLast</span>()) {
</span></span><span style=display:flex><span>                q.<span style=color:#a6e22e>pollLast</span>();<span style=color:#75715e>//只放最大的</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            q.<span style=color:#a6e22e>addLast</span>(nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            res<span style=color:#f92672>[</span>temp<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> q.<span style=color:#a6e22e>peekFirst</span>();<span style=color:#75715e>//最大永远在前面</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p>​ 双端队列从左往右，那么左边为last，右边为first（想成汽车）</p><ul><li><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>""</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>minWindow</span>(String s, String t) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 初始化 need 和 window 哈希表</span>
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>Character, Integer<span style=color:#f92672>&gt;</span> need <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>Character, Integer<span style=color:#f92672>&gt;</span> window <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 统计 t 中每个字符的出现次数</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span> c : t.<span style=color:#a6e22e>toCharArray</span>()) {
</span></span><span style=display:flex><span>            need.<span style=color:#a6e22e>put</span>(c, need.<span style=color:#a6e22e>getOrDefault</span>(c, 0) <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 初始化变量</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> temp <span style=color:#f92672>=</span> 0; <span style=color:#75715e>// 记录窗口中满足 need 条件的字符个数</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> start <span style=color:#f92672>=</span> 0; <span style=color:#75715e>// 记录最小子串的起始位置</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>MAX_VALUE</span>; <span style=color:#75715e>// 记录最小子串的长度</span>
</span></span><span style=display:flex><span>        String res <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>; <span style=color:#75715e>// 最终结果</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> 0, right <span style=color:#f92672>=</span> 0; <span style=color:#75715e>// 滑动窗口的左右边界</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 开始滑动窗口</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (right <span style=color:#f92672>&lt;</span> s.<span style=color:#a6e22e>length</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>char</span> c <span style=color:#f92672>=</span> s.<span style=color:#a6e22e>charAt</span>(right); <span style=color:#75715e>// 获取当前字符</span>
</span></span><span style=display:flex><span>            right<span style=color:#f92672>++</span>; <span style=color:#75715e>// 扩大窗口</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果当前字符是 t 中的字符，更新 window 哈希表</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (need.<span style=color:#a6e22e>containsKey</span>(c)) {
</span></span><span style=display:flex><span>                window.<span style=color:#a6e22e>put</span>(c, window.<span style=color:#a6e22e>getOrDefault</span>(c, 0) <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果当前字符的出现次数满足 need 的条件，temp++</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (window.<span style=color:#a6e22e>get</span>(c).<span style=color:#a6e22e>equals</span>(need.<span style=color:#a6e22e>get</span>(c))) {
</span></span><span style=display:flex><span>                    temp<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 当窗口满足条件时，尝试缩小窗口</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (temp <span style=color:#f92672>==</span> need.<span style=color:#a6e22e>size</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 更新最小子串的起始位置和长度</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (right <span style=color:#f92672>-</span> left <span style=color:#f92672>&lt;</span> len) {
</span></span><span style=display:flex><span>                    start <span style=color:#f92672>=</span> left;
</span></span><span style=display:flex><span>                    len <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>char</span> d <span style=color:#f92672>=</span> s.<span style=color:#a6e22e>charAt</span>(left); <span style=color:#75715e>// 获取左边界字符</span>
</span></span><span style=display:flex><span>                left<span style=color:#f92672>++</span>; <span style=color:#75715e>// 缩小窗口</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果左边界字符是 t 中的字符，更新 window 哈希表</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (need.<span style=color:#a6e22e>containsKey</span>(d)) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 如果当前字符的出现次数不再满足 need 的条件，temp--</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (window.<span style=color:#a6e22e>get</span>(d).<span style=color:#a6e22e>equals</span>(need.<span style=color:#a6e22e>get</span>(d))) {
</span></span><span style=display:flex><span>                        temp<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    window.<span style=color:#a6e22e>put</span>(d, window.<span style=color:#a6e22e>get</span>(d) <span style=color:#f92672>-</span> 1);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 返回结果</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> len <span style=color:#f92672>==</span> Integer.<span style=color:#a6e22e>MAX_VALUE</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;&#34;</span> : s.<span style=color:#a6e22e>substring</span>(start, start <span style=color:#f92672>+</span> len);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h4 id=数组>数组<a hidden class=anchor aria-hidden=true href=#数组>#</a></h4><ul><li><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>maxSubArray</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(nums.<span style=color:#a6e22e>length</span><span style=color:#f92672>&lt;</span>1){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 0;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> res<span style=color:#f92672>=</span>nums<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>,max<span style=color:#f92672>=</span>0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> num:nums){<span style=color:#75715e>//上次能否大于0，为这次使用</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(max<span style=color:#f92672>&lt;=</span>0){
</span></span><span style=display:flex><span>                max<span style=color:#f92672>=</span>num;
</span></span><span style=display:flex><span>            }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>                max<span style=color:#f92672>=</span>max<span style=color:#f92672>+</span>num;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            res<span style=color:#f92672>=</span>Math.<span style=color:#a6e22e>max</span>(res,max);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em><strong>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> <span style=color:#a6e22e>merge</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> intervals) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(intervals<span style=color:#f92672>==</span><span style=color:#66d9ef>null</span><span style=color:#f92672>||</span>intervals.<span style=color:#a6e22e>length</span><span style=color:#f92672>&lt;</span>2){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> intervals;
</span></span><span style=display:flex><span>    } 
</span></span><span style=display:flex><span>    ArrayList<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>[]&gt;</span>list1<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    Arrays.<span style=color:#a6e22e>sort</span>(intervals, (e1, e2) <span style=color:#f92672>-&gt;</span> Integer.<span style=color:#a6e22e>compare</span>(e1<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>, e2<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> interval:intervals){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(list1.<span style=color:#a6e22e>isEmpty</span>()<span style=color:#f92672>||</span>interval<span style=color:#f92672>[</span>0<span style=color:#f92672>]&gt;</span>list1.<span style=color:#a6e22e>get</span>(list1.<span style=color:#a6e22e>size</span>()<span style=color:#f92672>-</span>1)<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>){
</span></span><span style=display:flex><span>            list1.<span style=color:#a6e22e>add</span>(interval);
</span></span><span style=display:flex><span>        }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>            list1.<span style=color:#a6e22e>get</span>(list1.<span style=color:#a6e22e>size</span>()<span style=color:#f92672>-</span>1)<span style=color:#f92672>[</span>1<span style=color:#f92672>]=</span>Math.<span style=color:#a6e22e>max</span>(list1.<span style=color:#a6e22e>get</span>(list1.<span style=color:#a6e22e>size</span>()<span style=color:#f92672>-</span>1)<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>,interval<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> list1.<span style=color:#a6e22e>toArray</span>(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>list1.<span style=color:#a6e22e>size</span>()<span style=color:#f92672>][</span>2<span style=color:#f92672>]</span>);    
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rotate</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> len<span style=color:#f92672>=</span>nums.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        k<span style=color:#f92672>=</span>k<span style=color:#f92672>%</span>len;
</span></span><span style=display:flex><span>        reverse(nums,0,len<span style=color:#f92672>-</span>1);
</span></span><span style=display:flex><span>        reverse(nums,0,k<span style=color:#f92672>-</span>1);
</span></span><span style=display:flex><span>        reverse(nums,k,len<span style=color:#f92672>-</span>1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>reverse</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> j) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> temp <span style=color:#f92672>=</span> nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            nums<span style=color:#f92672>[</span>i<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> nums<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            nums<span style=color:#f92672>[</span>j<span style=color:#f92672>--]</span> <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请 **不要使用除法，**且在 <code>O(n)</code> 时间复杂度内完成此题</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>productExceptSelf</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> len<span style=color:#f92672>=</span>nums.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span>res<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>len<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> k<span style=color:#f92672>=</span>1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0;i<span style=color:#f92672>&lt;</span>len;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            res<span style=color:#f92672>[</span>i<span style=color:#f92672>]=</span>k;
</span></span><span style=display:flex><span>            k<span style=color:#f92672>=</span>k<span style=color:#f92672>*</span>nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        k<span style=color:#f92672>=</span>1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>len<span style=color:#f92672>-</span>1;i<span style=color:#f92672>&gt;=</span>0;i<span style=color:#f92672>--</span>){
</span></span><span style=display:flex><span>            res<span style=color:#f92672>[</span>i<span style=color:#f92672>]*=</span>k;
</span></span><span style=display:flex><span>            k<span style=color:#f92672>=</span>k<span style=color:#f92672>*</span>nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h4 id=矩阵>矩阵<a hidden class=anchor aria-hidden=true href=#矩阵>#</a></h4><ul><li><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>spiralOrder</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> matrix) {
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span>res<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> l<span style=color:#f92672>=</span>0,r<span style=color:#f92672>=</span>matrix<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>.<span style=color:#a6e22e>length</span><span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> u<span style=color:#f92672>=</span>0,d<span style=color:#f92672>=</span>matrix.<span style=color:#a6e22e>length</span><span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(l<span style=color:#f92672>&lt;=</span>r<span style=color:#f92672>&amp;&amp;</span>u<span style=color:#f92672>&lt;=</span>d){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>l;i<span style=color:#f92672>&lt;=</span>r;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>                res.<span style=color:#a6e22e>add</span>(matrix<span style=color:#f92672>[</span>l<span style=color:#f92672>][</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>l<span style=color:#f92672>+</span>1;i<span style=color:#f92672>&lt;=</span>d;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>                res.<span style=color:#a6e22e>add</span>(matrix<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>r<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(u<span style=color:#f92672>==</span>d<span style=color:#f92672>||</span>l<span style=color:#f92672>==</span>r){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>r<span style=color:#f92672>-</span>1;i<span style=color:#f92672>&gt;=</span>l;i<span style=color:#f92672>--</span>){
</span></span><span style=display:flex><span>                res.<span style=color:#a6e22e>add</span>(matrix<span style=color:#f92672>[</span>d<span style=color:#f92672>][</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>d<span style=color:#f92672>-</span>1;i<span style=color:#f92672>&gt;</span>u;i<span style=color:#f92672>--</span>){
</span></span><span style=display:flex><span>                res.<span style=color:#a6e22e>add</span>(matrix<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>l<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            u<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            d<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            l<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            r<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href=https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rotate</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> matrix) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n<span style=color:#f92672>=</span>matrix.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span>0;j<span style=color:#f92672>&lt;</span>(n<span style=color:#f92672>-</span>i);j<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> temp<span style=color:#f92672>=</span>matrix<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>j<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                    matrix<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>j<span style=color:#f92672>]=</span>matrix<span style=color:#f92672>[</span>n<span style=color:#f92672>-</span>j<span style=color:#f92672>-</span>1<span style=color:#f92672>][</span>n<span style=color:#f92672>-</span>i<span style=color:#f92672>-</span>1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                    matrix<span style=color:#f92672>[</span>n<span style=color:#f92672>-</span>j<span style=color:#f92672>-</span>1<span style=color:#f92672>][</span>n<span style=color:#f92672>-</span>i<span style=color:#f92672>-</span>1<span style=color:#f92672>]=</span>temp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0;i<span style=color:#f92672>&lt;</span>n<span style=color:#f92672>/</span>2;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j<span style=color:#f92672>=</span>0;j<span style=color:#f92672>&lt;</span>n;j<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> temp<span style=color:#f92672>=</span>matrix<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>j<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                matrix<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>j<span style=color:#f92672>]=</span>matrix<span style=color:#f92672>[</span>n<span style=color:#f92672>-</span>1<span style=color:#f92672>-</span>i<span style=color:#f92672>][</span>j<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>                matrix<span style=color:#f92672>[</span>n<span style=color:#f92672>-</span>1<span style=color:#f92672>-</span>i<span style=color:#f92672>][</span>j<span style=color:#f92672>]=</span>temp;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>searchMatrix</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> matrix, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (matrix <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> matrix.<span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> 0 <span style=color:#f92672>||</span> matrix<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> 0) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> matrix.<span style=color:#a6e22e>length</span>, n <span style=color:#f92672>=</span> matrix<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> row <span style=color:#f92672>=</span> 0, col <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (row <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> col <span style=color:#f92672>&gt;=</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (target <span style=color:#f92672>==</span> matrix<span style=color:#f92672>[</span>row<span style=color:#f92672>][</span>col<span style=color:#f92672>]</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (target <span style=color:#f92672>&lt;</span> matrix<span style=color:#f92672>[</span>row<span style=color:#f92672>][</span>col<span style=color:#f92672>]</span>) col<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> row<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h4 id=链表>链表<a hidden class=anchor aria-hidden=true href=#链表>#</a></h4><ul><li><p>相交链表</p><ul><li>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ListNode <span style=color:#a6e22e>getIntersectionNode</span>(ListNode headA, ListNode headB) {
</span></span><span style=display:flex><span>        ListNode p1<span style=color:#f92672>=</span>headA,p2<span style=color:#f92672>=</span>headB;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(p1<span style=color:#f92672>!=</span>p2){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(p1<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>                p1<span style=color:#f92672>=</span>p1.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>                p1<span style=color:#f92672>=</span>headB;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(p2<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>                p2<span style=color:#f92672>=</span>p2.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>                p2<span style=color:#f92672>=</span>headA;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> p1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>反转链表</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ListNode <span style=color:#a6e22e>reverseList</span>(ListNode head) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(head<span style=color:#f92672>==</span><span style=color:#66d9ef>null</span><span style=color:#f92672>||</span>head.<span style=color:#a6e22e>next</span><span style=color:#f92672>==</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ListNode pre<span style=color:#f92672>=</span>reverseList(head.<span style=color:#a6e22e>next</span>);
</span></span><span style=display:flex><span>        head.<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>next</span><span style=color:#f92672>=</span>head;
</span></span><span style=display:flex><span>        head.<span style=color:#a6e22e>next</span><span style=color:#f92672>=</span><span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pre;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isPalindrome</span>(ListNode head) {
</span></span><span style=display:flex><span>        ListNode slow<span style=color:#f92672>=</span>head,fast<span style=color:#f92672>=</span>head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(fast<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span><span style=color:#f92672>&amp;&amp;</span>fast.<span style=color:#a6e22e>next</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>            slow<span style=color:#f92672>=</span>slow.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            fast<span style=color:#f92672>=</span>fast.<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(fast<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span><span style=color:#f92672>&amp;&amp;</span>fast.<span style=color:#a6e22e>next</span><span style=color:#f92672>==</span><span style=color:#66d9ef>null</span>){<span style=color:#75715e>//为奇数设置</span>
</span></span><span style=display:flex><span>            slow<span style=color:#f92672>=</span>slow.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ListNode flag<span style=color:#f92672>=</span>head;
</span></span><span style=display:flex><span>        ListNode temp<span style=color:#f92672>=</span>serve(slow);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(temp<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(temp.<span style=color:#a6e22e>val</span><span style=color:#f92672>!=</span>flag.<span style=color:#a6e22e>val</span>){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            temp<span style=color:#f92672>=</span>temp.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            flag<span style=color:#f92672>=</span>flag.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ListNode <span style=color:#a6e22e>serve</span>(ListNode head){<span style=color:#75715e>//反转</span>
</span></span><span style=display:flex><span>        ListNode cur<span style=color:#f92672>=</span>head,pre<span style=color:#f92672>=</span><span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(cur<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>            ListNode nex<span style=color:#f92672>=</span>cur.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            cur.<span style=color:#a6e22e>next</span><span style=color:#f92672>=</span>pre;
</span></span><span style=display:flex><span>            pre<span style=color:#f92672>=</span>cur;
</span></span><span style=display:flex><span>            cur<span style=color:#f92672>=</span>nex;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pre;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>hasCycle</span>(ListNode head) {
</span></span><span style=display:flex><span>    ListNode fast<span style=color:#f92672>=</span>head;
</span></span><span style=display:flex><span>    ListNode slow<span style=color:#f92672>=</span>head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(fast<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span><span style=color:#f92672>&amp;&amp;</span>fast.<span style=color:#a6e22e>next</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>        fast<span style=color:#f92672>=</span>fast.<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        slow<span style=color:#f92672>=</span>slow.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(fast<span style=color:#f92672>==</span>slow){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>给定一个链表的头节点 <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ListNode <span style=color:#a6e22e>detectCycle</span>(ListNode head) {
</span></span><span style=display:flex><span>    ListNode fast<span style=color:#f92672>=</span>head,slow<span style=color:#f92672>=</span>head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(fast<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span><span style=color:#f92672>&amp;&amp;</span>fast.<span style=color:#a6e22e>next</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>        slow<span style=color:#f92672>=</span>slow.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        fast<span style=color:#f92672>=</span>fast.<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(slow<span style=color:#f92672>==</span>fast) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(fast<span style=color:#f92672>==</span><span style=color:#66d9ef>null</span><span style=color:#f92672>||</span>fast.<span style=color:#a6e22e>next</span><span style=color:#f92672>==</span><span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    fast<span style=color:#f92672>=</span>head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(fast<span style=color:#f92672>!=</span>slow){
</span></span><span style=display:flex><span>        slow<span style=color:#f92672>=</span>slow.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        fast<span style=color:#f92672>=</span>fast.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fast;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ListNode <span style=color:#a6e22e>mergeTwoLists</span>(ListNode list1, ListNode list2) {
</span></span><span style=display:flex><span>        ListNode p1<span style=color:#f92672>=</span>list1;
</span></span><span style=display:flex><span>        ListNode p2<span style=color:#f92672>=</span>list2;
</span></span><span style=display:flex><span>        ListNode cur<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> ListNode();
</span></span><span style=display:flex><span>        ListNode res<span style=color:#f92672>=</span>cur;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(p1<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span><span style=color:#f92672>&amp;&amp;</span>p2<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(p1.<span style=color:#a6e22e>val</span><span style=color:#f92672>&lt;</span>p2.<span style=color:#a6e22e>val</span>){
</span></span><span style=display:flex><span>                res.<span style=color:#a6e22e>next</span><span style=color:#f92672>=</span>p1;
</span></span><span style=display:flex><span>                p1<span style=color:#f92672>=</span>p1.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            }<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>                res.<span style=color:#a6e22e>next</span><span style=color:#f92672>=</span>p2;
</span></span><span style=display:flex><span>                p2<span style=color:#f92672>=</span>p2.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>             res<span style=color:#f92672>=</span>res.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(p1<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>            res.<span style=color:#a6e22e>next</span><span style=color:#f92672>=</span>p1;
</span></span><span style=display:flex><span>            p1<span style=color:#f92672>=</span>p1.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            res<span style=color:#f92672>=</span>res.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(p2<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>            res.<span style=color:#a6e22e>next</span><span style=color:#f92672>=</span>p2;
</span></span><span style=display:flex><span>            p2<span style=color:#f92672>=</span>p2.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            res<span style=color:#f92672>=</span>res.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> cur.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ListNode <span style=color:#a6e22e>removeNthFromEnd</span>(ListNode head, <span style=color:#66d9ef>int</span> n) {   
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(head<span style=color:#f92672>==</span><span style=color:#66d9ef>null</span><span style=color:#f92672>||</span>n<span style=color:#f92672>==</span>0){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ListNode dummy <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(0, head);<span style=color:#75715e>//防止n刚好删去头结点</span>
</span></span><span style=display:flex><span>        ListNode fast<span style=color:#f92672>=</span>dummy;
</span></span><span style=display:flex><span>        ListNode slow<span style=color:#f92672>=</span>dummy;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(fast<span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span><span style=color:#f92672>&amp;&amp;</span>n<span style=color:#f92672>--&gt;</span>0)
</span></span><span style=display:flex><span>            fast<span style=color:#f92672>=</span>fast.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(n<span style=color:#f92672>&gt;</span>0){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(fast.<span style=color:#a6e22e>next</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>            fast<span style=color:#f92672>=</span>fast.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            slow<span style=color:#f92672>=</span>slow.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        slow.<span style=color:#a6e22e>next</span><span style=color:#f92672>=</span>slow.<span style=color:#a6e22e>next</span>.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> dummy.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ListNode <span style=color:#a6e22e>reverseKGroup</span>(ListNode head, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        ListNode last<span style=color:#f92672>=</span>head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0;i<span style=color:#f92672>&lt;</span>k;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(last<span style=color:#f92672>==</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            last<span style=color:#f92672>=</span>last.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ListNode t<span style=color:#f92672>=</span>res(head,last);
</span></span><span style=display:flex><span>        ListNode temp<span style=color:#f92672>=</span>t;<span style=color:#75715e>//反转后的位置逻辑和head其实一样</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0;i<span style=color:#f92672>&lt;</span>k<span style=color:#f92672>-</span>1;i<span style=color:#f92672>++</span>){
</span></span><span style=display:flex><span>            temp<span style=color:#f92672>=</span>temp.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>       temp.<span style=color:#a6e22e>next</span><span style=color:#f92672>=</span>reverseKGroup(last,k);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> t;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ListNode <span style=color:#a6e22e>res</span>(ListNode head,ListNode tail){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(head<span style=color:#f92672>==</span><span style=color:#66d9ef>null</span><span style=color:#f92672>||</span>head.<span style=color:#a6e22e>next</span><span style=color:#f92672>==</span><span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> head;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ListNode cur<span style=color:#f92672>=</span>head,nex<span style=color:#f92672>=</span>head;
</span></span><span style=display:flex><span>        ListNode pre<span style=color:#f92672>=</span>tail;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(nex<span style=color:#f92672>!=</span>tail){
</span></span><span style=display:flex><span>            nex<span style=color:#f92672>=</span>nex.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            cur.<span style=color:#a6e22e>next</span><span style=color:#f92672>=</span>pre;
</span></span><span style=display:flex><span>            pre<span style=color:#f92672>=</span>cur;
</span></span><span style=display:flex><span>            cur<span style=color:#f92672>=</span>nex;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pre;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/%E7%AE%97%E6%B3%95/>算法</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/algorithm02/><span class=title>« Prev Page</span><br><span>Hot100</span>
</a><a class=next href=https://zwlzls.github.io/posts/algorithm00/><span class=title>Next Page »</span><br><span>数据结构Java版</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>