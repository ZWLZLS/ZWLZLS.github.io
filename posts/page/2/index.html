<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 我的博客</title>
<meta name=keywords content><meta name=description content="Posts - 我的博客"><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/><link crossorigin=anonymous href=../../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate type=application/rss+xml href=https://zwlzls.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://zwlzls.github.io/posts/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>devops概述</h2></header><section class=entry-content><p>devops介绍 https://github.com/lcomplete/TechShare/blob/master/docs/engineering/devops.md全文
定义 DevOps 所要实现的目标都是一致的——缩短软件开发生命周期并使用 持续交付 提供高质量的软件，开发运维之间 沟通合作
发展背景： 敏态需求的增加，即探索性工作的增加： 软件开发从传统的瀑布流方式到敏捷开发，再到现在对敏捷开发提出了更高的要求，近些年创新型的应用不断涌现，这些应用的研发过程中多采用小步快跑、快速试错的方式，这些探索性工作要求运维能够具备一天发布多次的能力，需要企业完成由稳态到敏态的转变 软件开发活动在企业经营活动中占比的不断增加： 业务发展对软件的依赖由轻度依赖、中度依赖发展到目前的重度依赖。 企业存在对消除浪费的需求： 软件开发活动在企业中的位置越来越重要，软件开发活动中也存在着许多的浪费，企业管理上必然存在着 识别并消除浪费 的需求 软件开发中的浪费包括不必要和必要的浪费： 不必要的浪费有：无人使用的功能、软件bug、等待测试、等待审批等 必要的浪费包括：工作项移交、测试、项目管理 以上为深层原因，浅层原因有：容器化技术的发展、微服务架构的发展等等 DevOps原则 DevOps 原则是总体指导思想，实践是具体的执行方法，DevOps 是一个动态的过程，在进行相关实践的时候可以看看其应用了哪些原则，当违背原则的时候需要思考实践的合理性
三大原则：
流动原则：加速 从开发、运维到交付给客户的流程 反馈原则：建设 安全可靠 的工作体系 持续学习与实验原则：采用科学工作方式，将对组织的 改进和创新 作为工作一部分 流转原则： 坚持少做 产品开始开发时采用 MVP 原则（最小可行产品原则） MVP要求抓住最核心的产品流程，剥掉多余的功能或者高级功能，只要主流程可以跑起来可以。完美并不是我们的目标，快速试错才是我们目标 产品迭代时要适时做减法 持续分解问题 大的变更或需求拆解为一系列小的变更，快速解决 工作可视化 采用 Sprint 看板将工作可视化 控制任务数量 减少前置时间，降低测试人员的等待时间 任务越多，预估越不准确 减少交接次数 减少不必要的沟通和等待 持续识别和改善约束点 识别出影响流动的主要前置因素，比如搭建环境、需求文档 QA、开发、运维、产品持续提升生产力 为非功能性需求预留20%的开发时间，减少技术债务 消除价值流中的困境和浪费（导致交付延迟的主要因素） 半成品——未完全完成的工作 额外工序——从不使用的文档、重复编写接口文档等 额外功能——用户实际不需要的功能 任务切换——将人员分配到多个项目或截然不同的工作任务中 等待、移动、缺陷、非标准化的手动操作 返回原则 在复杂系统中安全地工作 管理复杂的工作，识别出设计和操作的问题 群策群力解决问题，从而快速构建新知识 在整个组织中，将区域性的知识应用到全局范围 领导者要持续培养有以上才能的人 及时发现问题 快速、频繁和高质量的信息流——每个工序的操作都会被度量和监控 技术价值流的每个阶段（产品管理、开发、QA、安全、运维），建立快速的反馈和前馈回路（包括自动化构建、集成和测试过程） 全方位的遥测系统 在源头保障质量 过多的检查和审批流程，使得做决策的地方远离执行工作的地方，这导致流程有效性降低，减弱了因果关系之间反馈的强度。 让开发人员也对系统质量负责，快速反馈，加速开发人员的学习。 为内部客户优化工作 运维的非功能性需求（如架构、性能、稳定性、可测试性、可配置性和安全性）与用户功能同样重要 持续学习和实验原则 建立学习型组织和安全文化 将日常工作的改进制度化 把局部发现转化为全局优化 在日常工作中注入弹性模式 缩短部署的前置时间、提高测试覆盖率、缩短测试执行时间，甚至在必要时解耦架构，都属于在系统中引入类似张力的做法。 领导层强化学习文化 领导者帮助一线工作者在日常工作中发现并解决问题 DevOps实践 基于 DevOps 的相关原则，有与其对应的实践，在应用这些实践之前还需认真设计组织结构，使其有利于实践的开展...</p></section><a class=entry-link aria-label="post link to devops概述" href=https://zwlzls.github.io/posts/devops00/></a></article><article class=post-entry><header class=entry-header><h2>Hot100</h2></header><section class=entry-content><p>Hot100 二叉树 给定一个二叉树的根节点 root ，返回 它的 中序 遍历
class Solution { public List&lt;Integer> inorderTraversal(TreeNode root) { List&lt;Integer> res = new ArrayList&lt;Integer>(); Stack&lt;TreeNode> stk = new Stack&lt;TreeNode>(); while (root != null || !stk.isEmpty()) { while (root != null) { stk.push(root); root = root.left; } root = stk.pop(); res.add(root.val); root = root.right; } return res; } } 思考中序过程就行
给定一个二叉树 root ，返回其最大深度。
二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。
class Solution { public int maxDepth(TreeNode root) { return Depth(root); } public int Depth(TreeNode root){ if(root==null){ return 0; } int left=Depth(root....</p></section><a class=entry-link aria-label="post link to Hot100" href=https://zwlzls.github.io/posts/algorithm02/></a></article><article class=post-entry><header class=entry-header><h2>Hot100</h2></header><section class=entry-content><p>Hot100 哈希 两数之和
class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer,Integer>map=new HashMap&lt;>(); int len=nums.length; for(int i=0;i&lt;len;i++){ int p=target-nums[i]; if(map.containsKey(p)){ return new int[]{i,map.get(p)}; } map.put(nums[i],i); } return new int[]{0,0}; } } 字母异位分组
class Solution { public List&lt;List&lt;String>> groupAnagrams(String[] strs) { HashMap&lt;String,LinkedList&lt;String>>cur=new HashMap&lt;>(); for(String str:strs){ char[] c1=str.toCharArray(); Arrays.sort(c1); String s=String.valueOf(c1); if(!cur.containsKey(s)){ cur.put(s,new LinkedList&lt;>()); cur.get(s).add(str); }else{ cur.get(s).add(str); } } return new LinkedList(cur.values()); } } 最长连续序列：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度
class Solution { public int longestConsecutive(int[] nums) { int ans = 0; Set&lt;Integer> st = new HashSet&lt;>(); for (int num : nums) { st....</p></section><a class=entry-link aria-label="post link to Hot100" href=https://zwlzls.github.io/posts/algorithm01/></a></article><article class=post-entry><header class=entry-header><h2>数据结构Java版</h2></header><section class=entry-content><p>数据结构 数组 ArrayList`&lt;Integer>`arr=new ArrayList&lt;>();int[]c=new int[3];数组建立 arr.add(99);数组增加 arr.toArray(a);集合变成数组类型 arr.add(3,99);数组插入 arr.get(3);获得元素值 arr.set(3,22);改变元素值 arr.remove(3);移除某索引的元素 Collections.reverse(arr);反转一个arr arr.size();长度 普通数组长度为：length arr.contains(99);是否含有某元素 Collections.sort(arr);集合类的排序 Arrays.sort(c);普通排序 Arrays.fill(c, 1);填充数组c的所有值为1 二维数组排序：第一列按升序排列，第一列相同，则第二列按升序排列 compare方法返回值int类型，返回值大于0，交换两数，小于零，排序正确，等于0，两数相等 Arrays.sort(arr, new Comparator&lt;int[]>() { public int compare(int[] e1, int[] e2) { // 如果第一列元素相等，则比较第二列元素 if (e1[0]==e2[0]) return e1[1]-e2[1]; // e1[1]-e2[1]表示对于第二列元素进行升序排序 return e1[0]-e2[0]; } Arrays.sort(intervals,new Comparator&lt;int[]>(){//两数相减或相加会产生int值溢出，因此通过比较后，直接返回-1，0，1 public int compare(int[]e1,int[]e2){// e1[0]-e2[0]表示对于第一列元素进行升序排序 if(e1[0]>e2[0]){ return 1; }else if(e1[0]==e2[0]){ return 0; }else{ return -1; } } }); Arrays.sort(intervals, (e1, e2) -> Integer.compare(e1[0], e2[0]));//上面可简写 Arrays.sort(strings,(s1,s2)-> (s1+s2).compareTo(s2+s1)); Collections....</p></section><a class=entry-link aria-label="post link to 数据结构Java版" href=https://zwlzls.github.io/posts/algorithm00/></a></article><article class=post-entry><header class=entry-header><h2>TestNG</h2></header><section class=entry-content><p>TestNG TestNG是一个Java语言的测试框架，也是QA最常用的测试框架之一
TestNG官网文档地址：TestNG 文档 — TestNG Documentation
有时间再依据这个重新学下https://lwmzz.blog.csdn.net/article/details/129173343有代码实践 简介 TestNG 是一个测试框架，从单元测试（与其他类隔离的情况下测试一个类）到集成测试（测试由多个类、多个包甚至多个外部框架（如应用服务器）组成的整个系统）
编写测试通常是一个三步过程：
编写您测试的业务逻辑，并在您的代码中插入TestNG注解。 到 testng.xml 文件中或在build.xml中添加有关您的测试信息（例如，类名、您希望运行的组等） 运行TestNG 可以在欢迎页面找到一个快速示例
文档中主要概念：
套件由一个XML文件表示。可以包含一个或多个测试，并由&lt;suite>标记定义 测试用例由&lt;test>表示，可以包含一个或多个TestNG类 TestNG类是一个包含至少一个TestNG注解的Java类。它由&lt;class>标记表示，可以包含一个或多个测试方法 测试方法是代码中的@Test注解的Java方法 可以通过@BeforeXXX和@AfterXXX注解进行配置，这些注解允许在某个特定点之前和之后执行一些 Java 逻辑，这些点可以是上述列表中的任何一项 其余部分将解释以下内容：
所有注解的列表以及简要说明。这将让您了解TestNG提供的各种功能，但可能需要查阅专用于每个注解的部分以了解详细信息。 testng.xml文件的说明，语法以及您可以在其中指定的内容。 各种功能的详细列表以及如何结合注解和testng.xml使用它们 注解 以下TestNG中可用注解及其属性的快速概述
注解：BeforeXXX & AfterXXX
TestNG类的配置信息：
@BeforeSuite：在此套件中的所有测试运行之前，将运行带注解的方法。 @AfterSuite：在此套件中的所有测试运行后，将运行带注解的方法。 @BeforeTest：在运行属于&lt;test>标记内的类的任何测试方法之前，将运行带注解的方法。 @AfterTest：在运行属于&lt;test>标记内的类的所有测试方法之后，将运行带注解的方法。 @BeforeGroups：此配置方法之前将运行的组列表。保证在调用属于任何这些组的第一个测试方法之前不久运行此方法。 @AfterGroups：此配置方法将在之后运行的组列表。保证在调用属于任何这些组的最后一个测试方法后不久运行此方法。 @BeforeClass：在调用当前类中的第一个测试方法之前，将运行带注解的方法。 @AfterClass：在运行当前类中的所有测试方法之后，将运行带注解的方法。 @BeforeMethod：带注解的方法将在每个测试方法之前运行。 @AfterMethod：带注解的方法将在每个测试方法之后运行 TestNG类的超类中的注解行为
超类是指被继承的类
超类中的注解行为会被继承到子类中。
执行顺序:
@Before 类注解 : 从超类到子类 @After 类注解：从子类到超类。 当放置在TestNG类的超类上时，上述注解也将被兑现（继承）。例如，这对于在公共超类中集中多个测试类的测试设置非常有用
import org.testng.annotations.BeforeClass; import org.testng.annotations.BeforeMethod; import org.testng.annotations.AfterClass; import org.testng.annotations.AfterMethod; public class BaseTest { @BeforeClass public void beforeClass() { System....</p></section><a class=entry-link aria-label="post link to TestNG" href=https://zwlzls.github.io/posts/testng/></a></article><article class=post-entry><header class=entry-header><h2>Jenkins01</h2></header><section class=entry-content><p></p></section><a class=entry-link aria-label="post link to Jenkins01" href=https://zwlzls.github.io/posts/jenkins01/></a></article><article class=post-entry><header class=entry-header><h2>Jenkins00</h2></header><section class=entry-content><p></p></section><a class=entry-link aria-label="post link to Jenkins00" href=https://zwlzls.github.io/posts/jenkins00/></a></article><article class=post-entry><header class=entry-header><h2>Docker01</h2></header><section class=entry-content><p></p></section><a class=entry-link aria-label="post link to Docker01" href=https://zwlzls.github.io/posts/docker01/></a></article><article class=post-entry><header class=entry-header><h2>Docker介绍</h2></header><section class=entry-content><p>总体概述 docker是什么 是什么？
开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化 完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,且容器性能开销极低 基于 Go 语言开源的应用容器引擎，遵从 Apache2.0 协议开源 为什么？
一次构建，随处运行 更快速的应用交付和部署 更便捷的升级和扩缩容 更简单的系统运维； Docker与虚拟机对比
Docker的镜像层一般很小，只有几十KB，而虚拟机则通常以GB为单位。
性能方面，Docker依附于宿主机，所以性能接近宿主机，而虚拟机相对于原主机来说性能较差。资源利用率方面，Docker的资源利用率较高，而虚拟机的资源利用率较低。
隔离性方面，Docker和虚拟机都具有安全隔离的特性。
Docker直接在宿主机内核上运行，而虚拟机运行在隔离层Hypervisor上。
Docker可同时运行上千个容器，而虚拟机相对厚重，最多只能启动几十个。
在运行速度方面，Docker优于虚拟机，Docker容器的启动和停止可以在秒级实现，而传统的虚拟机方式要慢得多
架构
三个基础概念
镜像（image）：Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器
镜像唯一标识是其 ID 和摘要，而一个镜像可以有多个标签 并非是像一个 ISO 那样的打包文件，是一个虚拟的概念。是由一组文件系统组成，或者说，由多层文件系统联合组成 容器（container）： Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。 可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。
可把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写
仓库（repository）：仓库（Repository）是集中存放镜像文件的场所
仓库注册服务器上存放着多个仓库，每个仓库中包含多个镜像，每个镜像有不同的标签（tag）
使用镜像 Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像
获取镜像
Docker 镜像仓库获取镜像的命令是 docker pull
$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 对Docker Hub，如果不给出用户名，则默认为 library，就是官方镜像
$ docker pull ubuntu:18....</p></section><a class=entry-link aria-label="post link to Docker介绍" href=https://zwlzls.github.io/posts/docker00/></a></article><article class=post-entry><header class=entry-header><h2>Redis(持久化一致性淘汰)</h2></header><section class=entry-content><p>持久化 AOF 文件的内容是操作命令； RDB 文件的内容是二进制数据 AOF Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 redis.conf
Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里
这保存写操作命令到日志的持久化方式，是 Redis 里的 AOF(Append Only File) 持久化功能，注意只会记录写操作命令，读操作命令是不会被记录的
Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的
避免额外的检查开销 不会阻塞当前写操作命令的执行，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志 风险：
执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险 写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是可能会给「下一个」命令带来阻塞风险 执行过程：
Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区； 通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘； 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定 写回硬盘策略： Always，「总是」，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘； Everysec，「每秒」，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，每隔一秒将缓冲区里的内容写回到硬盘； No，不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘 AOF重写机制
AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大 Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制 机制是在重写时，读取当前数据库中的所有键值对，将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件 妙处在于：尽管某个键值对被多条写命令反复修改，最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对 AOF后台重写...</p></section><a class=entry-link aria-label="post link to Redis(持久化一致性淘汰)" href=https://zwlzls.github.io/posts/redis01/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://zwlzls.github.io/posts/>« Prev Page</a>
<a class=next href=https://zwlzls.github.io/posts/page/3/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>