<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python中级 | 我的博客</title>
<meta name=keywords content="Python"><meta name=description content="Python中级使用 函数 调用函数 参数可以多个 >>> max(1, 2) 2 >>> max(2, 3, 1, -5) 3 参数类型需要一致 >>> abs('a') TypeError: bad operand type for abs(): 'str' 函数调用 >>> abs(100) 100 >>> abs(-20) 20 数据类型转换
>>> int('123') 123 >>> int(12.34) 12 >>> float('12.34') 12.34 >>> str(1.23) '1.23' >>> str(100) '100' >>> bool(1) True >>> bool('') False 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量
>>> a = abs # 变量a指向abs函数 >>> a(-1) # 所以也可以通过a调用abs函数 1 定义函数 要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回
def my_abs(x): if x >= 0: return x else: return -x print(my_abs(-99)) 空函数：定义一个什么事也不做的空函数，可以用pass语句"><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/python01/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/python01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Python中级"><meta property="og:description" content="Python中级使用 函数 调用函数 参数可以多个 >>> max(1, 2) 2 >>> max(2, 3, 1, -5) 3 参数类型需要一致 >>> abs('a') TypeError: bad operand type for abs(): 'str' 函数调用 >>> abs(100) 100 >>> abs(-20) 20 数据类型转换
>>> int('123') 123 >>> int(12.34) 12 >>> float('12.34') 12.34 >>> str(1.23) '1.23' >>> str(100) '100' >>> bool(1) True >>> bool('') False 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量
>>> a = abs # 变量a指向abs函数 >>> a(-1) # 所以也可以通过a调用abs函数 1 定义函数 要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回
def my_abs(x): if x >= 0: return x else: return -x print(my_abs(-99)) 空函数：定义一个什么事也不做的空函数，可以用pass语句"><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/python01/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-17T15:13:58+08:00"><meta property="article:modified_time" content="2025-01-17T15:13:58+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python中级"><meta name=twitter:description content="Python中级使用 函数 调用函数 参数可以多个 >>> max(1, 2) 2 >>> max(2, 3, 1, -5) 3 参数类型需要一致 >>> abs('a') TypeError: bad operand type for abs(): 'str' 函数调用 >>> abs(100) 100 >>> abs(-20) 20 数据类型转换
>>> int('123') 123 >>> int(12.34) 12 >>> float('12.34') 12.34 >>> str(1.23) '1.23' >>> str(100) '100' >>> bool(1) True >>> bool('') False 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量
>>> a = abs # 变量a指向abs函数 >>> a(-1) # 所以也可以通过a调用abs函数 1 定义函数 要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回
def my_abs(x): if x >= 0: return x else: return -x print(my_abs(-99)) 空函数：定义一个什么事也不做的空函数，可以用pass语句"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python中级","item":"https://zwlzls.github.io/posts/python01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python中级","name":"Python中级","description":"Python中级使用 函数 调用函数 参数可以多个 \u0026gt;\u0026gt;\u0026gt; max(1, 2) 2 \u0026gt;\u0026gt;\u0026gt; max(2, 3, 1, -5) 3 参数类型需要一致 \u0026gt;\u0026gt;\u0026gt; abs(\u0026#39;a\u0026#39;) TypeError: bad operand type for abs(): \u0026#39;str\u0026#39; 函数调用 \u0026gt;\u0026gt;\u0026gt; abs(100) 100 \u0026gt;\u0026gt;\u0026gt; abs(-20) 20 数据类型转换\n\u0026gt;\u0026gt;\u0026gt; int(\u0026#39;123\u0026#39;) 123 \u0026gt;\u0026gt;\u0026gt; int(12.34) 12 \u0026gt;\u0026gt;\u0026gt; float(\u0026#39;12.34\u0026#39;) 12.34 \u0026gt;\u0026gt;\u0026gt; str(1.23) \u0026#39;1.23\u0026#39; \u0026gt;\u0026gt;\u0026gt; str(100) \u0026#39;100\u0026#39; \u0026gt;\u0026gt;\u0026gt; bool(1) True \u0026gt;\u0026gt;\u0026gt; bool(\u0026#39;\u0026#39;) False 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量\n\u0026gt;\u0026gt;\u0026gt; a = abs # 变量a指向abs函数 \u0026gt;\u0026gt;\u0026gt; a(-1) # 所以也可以通过a调用abs函数 1 定义函数 要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回\ndef my_abs(x): if x \u0026gt;= 0: return x else: return -x print(my_abs(-99)) 空函数：定义一个什么事也不做的空函数，可以用pass语句","keywords":["Python"],"articleBody":"Python中级使用 函数 调用函数 参数可以多个 \u003e\u003e\u003e max(1, 2) 2 \u003e\u003e\u003e max(2, 3, 1, -5) 3 参数类型需要一致 \u003e\u003e\u003e abs('a') TypeError: bad operand type for abs(): 'str' 函数调用 \u003e\u003e\u003e abs(100) 100 \u003e\u003e\u003e abs(-20) 20 数据类型转换\n\u003e\u003e\u003e int('123') 123 \u003e\u003e\u003e int(12.34) 12 \u003e\u003e\u003e float('12.34') 12.34 \u003e\u003e\u003e str(1.23) '1.23' \u003e\u003e\u003e str(100) '100' \u003e\u003e\u003e bool(1) True \u003e\u003e\u003e bool('') False 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量\n\u003e\u003e\u003e a = abs # 变量a指向abs函数 \u003e\u003e\u003e a(-1) # 所以也可以通过a调用abs函数 1 定义函数 要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回\ndef my_abs(x): if x \u003e= 0: return x else: return -x print(my_abs(-99)) 空函数：定义一个什么事也不做的空函数，可以用pass语句\ndef nop(): pass pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来\n返回多个值\n需要从一个点移动到另一个点，给出坐标、位移和角度，就计算出新的坐标：\nimport math def move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 函数参数 普通形式\ndef power(x, n): s = 1 while n \u003e 0: n = n - 1 s = s * x return s 默认参数：降低调用函数的难度\ndef power(x, n=2): s = 1 while n \u003e 0: n = n - 1 s = s * x return s \u003e\u003e\u003e power(5) 25 一是必选参数在前，默认参数在后，否则Python的解释器会报错\n二是如何设置默认参数\n多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数 调用\n当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin') 按顺序提供默认参数，比如调用enroll('Bob', 'M', 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值 默认参数的常见陷阱\n定义一个函数，传入一个list，添加一个END再返回：\ndef add_end(L=[]): L.append('END') return L 使用默认参数调用时，一开始结果也是对的：\n\u003e\u003e\u003e add_end() ['END'] 但是，再次调用add_end()时，结果就不对了：\n\u003e\u003e\u003e add_end() ['END', 'END'] \u003e\u003e\u003e add_end() ['END', 'END', 'END'] 原因解释如下：\nPython函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了\n特别注意\n定义默认参数要牢记一点：默认参数必须指向不变对象！\ndef add_end(L=None): if L is None: L = [] L.append('END') return L \u003e\u003e\u003e add_end() ['END'] \u003e\u003e\u003e add_end() ['END'] 可变参数：允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple\ndef calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple\n\u003e\u003e\u003e calc(1, 2) 5 \u003e\u003e\u003e calc() 0 已经有一个list或者tuple，要调用一个可变参数\n\u003e\u003e\u003e nums = [1, 2, 3] \u003e\u003e\u003e calc(*nums) 14 *nums表示把nums这个list的所有元素作为可变参数传进去\n关键字参数\n允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict\ndef person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) \u003e\u003e\u003e person('Michael', 30) name: Michael age: 30 other: {} \u003e\u003e\u003e person('Adam', 45, gender='M', job='Engineer') name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'} \u003e\u003e\u003e extra = {'city': 'Beijing', 'job': 'Engineer'} \u003e\u003e\u003e person('Jack', 24, **extra) name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'} **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra\n命名关键字参数\n限制关键字参数的名字，就可以用命名关键字参数\ndef person(name, age, *, city, job): print(name, age, city, job) 命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。\n调用方式如下：\n\u003e\u003e\u003e person('Jack', 24, city='Beijing', job='Engineer') Jack 24 Beijing Engineer 函数定义中有一可变参数，后面的命名关键字参数就不需要一个特殊分隔符*：\ndef person(name, age, *args, city, job): print(name, age, args, city, job) 命名关键字参数必传入参数名，和位置参数不同。没有传入参数名，调用报错：\n\u003e\u003e\u003e person('Jack', 24, 'Beijing', 'Engineer') TypeError: person() missing 2 required keyword-only arguments: 'city' and 'job 命名关键字参数可以有缺省值，从而简化调用：\ndef person(name, age, *, city='Beijing', job): print(name, age, city, job) 由于命名关键字参数city具有默认值，调用时，可不传入city参数：\n\u003e\u003e\u003e person('Jack', 24, job='Engineer') Jack 24 Beijing Engineer 参数组合\n顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数 递归函数：一个函数在内部调用自身本身\ndef fact(n): if n==1: return 1 return n * fact(n - 1) 高级特性：减少代码量 切片 用于list及其变种，进行连续指定索引的操作[前索引:后索引:间隔]\n取指定索引范围的操作\n\u003e\u003e\u003e L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack'] \u003e\u003e\u003e L[0:3] ['Michael', 'Sarah', 'Tracy'] L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3\n\u003e\u003e\u003e L[:3] ['Michael', 'Sarah', 'Tracy'] 第一个索引是0，还可以省略\n\u003e\u003e\u003e L[-2:] ['Bob', 'Jack'] \u003e\u003e\u003e L[-2:-1] ['Bob'] 同样支持倒数切片，倒数第一个元素的索引是-1\n\u003e\u003e\u003e L[:10:2] [0, 2, 4, 6, 8] 前10个数，每两个取一个\n\u003e\u003e\u003e (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) tuple也可以用切片操作，只是操作的结果仍是tuple\n\u003e\u003e\u003e 'ABCDEFG'[:3] 'ABC' \u003e\u003e\u003e 'ABCDEFG'[::2] 'ACEG' 字符串'xxx'也可以看成是一种list，每个元素就是一个字符\n迭代 通过for ... in循环遍历\n比如dict就可以迭代：\n\u003e\u003e\u003e d = {'a': 1, 'b': 2, 'c': 3} \u003e\u003e\u003e for key in d: ... print(key) ... a c b 字符串也是可迭代对象，可以作用于for循环：\n\u003e\u003e\u003e for ch in 'ABC': ... print(ch) ... A B C 判断是否可迭代对象呢？方法是通过collections.abc模块的Iterable类型判断：\n\u003e\u003e\u003e from collections.abc import Iterable \u003e\u003e\u003e isinstance('abc', Iterable) # str是否可迭代 True \u003e\u003e\u003e isinstance([1,2,3], Iterable) # list是否可迭代 True \u003e\u003e\u003e isinstance(123, Iterable) # 整数是否可迭代 False Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身\n\u003e\u003e\u003e for i, value in enumerate(['A', 'B', 'C']): ... print(i, value) ... 0 A 1 B 2 C for循环里，同时引用了两个变量，比如下面的代码：\n\u003e\u003e\u003e for x, y in [(1, 1), (2, 4), (3, 9)]: ... print(x, y) ... 1 1 2 4 3 9 列表生成式 Python内置的非常简单却强大的可以用来创建list的生成式\n列表生成式则可以用一行语句代替循环生成上面的list：\n\u003e\u003e\u003e [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 列表生成式也可以使用两个变量来生成list：\n\u003e\u003e\u003e d = {'x': 'A', 'y': 'B', 'z': 'C' } \u003e\u003e\u003e [k + '=' + v for k, v in d.items()] ['y=B', 'x=A', 'z=C'] 使用两层循环，可以生成全排列：\n\u003e\u003e\u003e [m + n for m in 'ABC' for n in 'XYZ'] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：\n\u003e\u003e\u003e [x for x in range(1, 11) if x % 2 == 0] [2, 4, 6, 8, 10] 在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else\n\u003e\u003e\u003e [x if x % 2 == 0 else -x for x in range(1, 11)] [-1, 2, -3, 4, -5, 6, -7, 8, -9, 10] 生成器 列表生成式，创建一个列表。受到内存限制，列表容量是有限。创建包含100万个元素列表，占用很大的存储，如果仅仅访问前面几个元素，绝大多数元素占用空间浪费\nPython中，这种一边循环一边计算的机制，称为生成器：generator；generator保存的是算法\n创建一个generator\n只要把一个列表生成式的[]改成()，就创建了一个generator第一种方法\n\u003e\u003e\u003e L = [x * x for x in range(10)] \u003e\u003e\u003e L [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] \u003e\u003e\u003e g = (x * x for x in range(10)) \u003e\u003e\u003e next(g) 0 \u003e\u003e\u003e next(g) 1 \u003e\u003e\u003e next(g) 4 或者 \u003e\u003e\u003e for n in g: ... print(n) ... 0 1 4 9 16 25 36 49 64 81 把fib函数变成generator函数，只需要把print(b)改为yield b就可以第二种\n以斐波那契数列为例\ndef fib(max): n, a, b = 0, 0, 1 while n \u003c max: print(b) a, b = b, a + b n = n + 1 return 'done' 改为\ndef fib(max): n, a, b = 0, 0, 1 while n \u003c max: yield b a, b = b, a + b n = n + 1 return 'done' 理解\n普通函数是顺序执行，遇到return语句或者最后一行函数语句就返回。\ngenerator函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行\n请务必注意：调用generator函数会创建一个generator对象，多次调用generator函数会创建多个相互独立的generator\neg:先错误后正确\ndef odd(): print('step 1') yield 1 print('step 2') yield(3) print('step 3') yield(5) \u003e\u003e\u003e next(odd()) step 1 1 \u003e\u003e\u003e next(odd()) step 1 1 \u003e\u003e\u003e next(odd()) step 1 1 \u003e\u003e\u003e g = odd() \u003e\u003e\u003e next(g) step 1 1 \u003e\u003e\u003e next(g) step 2 3 \u003e\u003e\u003e next(g) step 3 5 迭代器 可以直接作用于for循环的数据类型有以下几种：\n一类是集合数据类型，如list、tuple、dict、set、str等；\n一类是generator，包括生成器和带yield的generator function。\n这些可以直接作用于for循环的对象统称为可迭代对象\nisinstance()判断一个对象是否是**Iterable**对象： \u003e\u003e\u003e from collections.abc import Iterable \u003e\u003e\u003e isinstance([], Iterable) True \u003e\u003e\u003e isinstance({}, Iterable) True \u003e\u003e\u003e isinstance('abc', Iterable) True \u003e\u003e\u003e isinstance((x for x in range(10)), Iterable) True \u003e\u003e\u003e isinstance(100, Iterable) False 使用isinstance()判断一个对象是否是**Iterator**对象：\n\u003e\u003e\u003e from collections.abc import Iterator \u003e\u003e\u003e isinstance((x for x in range(10)), Iterator) True \u003e\u003e\u003e isinstance([], Iterator) False \u003e\u003e\u003e isinstance({}, Iterator) False \u003e\u003e\u003e isinstance('abc', Iterator) False 可作用于next()函数的对象都是Iterator类型\n把list、dict、str等Iterable变成Iterator可以使用iter()函数：\n\u003e\u003e\u003e isinstance(iter([]), Iterator) True \u003e\u003e\u003e isinstance(iter('abc'), Iterator) True 总结\n集合数据类型如list、dict、str等是Iterable但不是Iterator 函数式编程 特点：允许把函数本身作为参数传入另一个函数，还允许返回一个函数\n高阶函数 特点：变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数\n变量指向函数\n\u003e\u003e\u003e f = abs \u003e\u003e\u003e f(-10) 10 变量f已经指向abs函数本身。调用abs()函数和调用变量f()完全相同\n函数名也是变量\n函数名就是指向函数的变量\n对abs()函数，可以把函数名abs看成变量，指向可以计算绝对值的函数\n\u003e\u003e\u003e abs = 10 \u003e\u003e\u003e abs(-10) Traceback (most recent call last): File \"\", line 1, in TypeError: 'int' object is not callable 实际代码不是这样写，只为说明\n高阶函数总结举例\ndef add(x, y, f): return f(x) + f(y) print(add(-5, 6, abs)) map()和reduce()函数\nmap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回\n\u003e\u003e\u003e def f(x): ... return x * x ... \u003e\u003e\u003e r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) \u003e\u003e\u003e list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算\nreduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) \u003e\u003e\u003e from functools import reduce \u003e\u003e\u003e def add(x, y): ... return x + y ... \u003e\u003e\u003e reduce(add, [1, 3, 5, 7, 9]) 25 返回函数 特点：把函数作为结果值返回\neg:如果不需要立刻求和，可以不返回求和的结果，而是返回求和的函数\ndef lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum 我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：\n\u003e\u003e\u003e f = lazy_sum(1, 3, 5, 7, 9) \u003e\u003e\u003e f ","wordCount":"1416","inLanguage":"en","datePublished":"2025-01-17T15:13:58+08:00","dateModified":"2025-01-17T15:13:58+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/python01/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Python中级</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#python%e4%b8%ad%e7%ba%a7%e4%bd%bf%e7%94%a8 aria-label=Python中级使用>Python中级使用</a><ul><li><a href=#%e5%87%bd%e6%95%b0 aria-label=函数>函数</a><ul><li><a href=#%e8%b0%83%e7%94%a8%e5%87%bd%e6%95%b0 aria-label=调用函数>调用函数</a></li><li><a href=#%e5%ae%9a%e4%b9%89%e5%87%bd%e6%95%b0 aria-label=定义函数>定义函数</a></li><li><a href=#%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0 aria-label=函数参数>函数参数</a></li></ul></li><li><a href=#%e9%ab%98%e7%ba%a7%e7%89%b9%e6%80%a7%e5%87%8f%e5%b0%91%e4%bb%a3%e7%a0%81%e9%87%8f aria-label=高级特性：减少代码量>高级特性：减少代码量</a><ul><li><a href=#%e5%88%87%e7%89%87 aria-label=切片>切片</a></li><li><a href=#%e8%bf%ad%e4%bb%a3 aria-label=迭代>迭代</a></li><li><a href=#%e5%88%97%e8%a1%a8%e7%94%9f%e6%88%90%e5%bc%8f aria-label=列表生成式>列表生成式</a></li><li><a href=#%e7%94%9f%e6%88%90%e5%99%a8 aria-label=生成器>生成器</a></li><li><a href=#%e8%bf%ad%e4%bb%a3%e5%99%a8 aria-label=迭代器>迭代器</a></li></ul></li><li><a href=#%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b aria-label=函数式编程>函数式编程</a><ul><li><a href=#%e9%ab%98%e9%98%b6%e5%87%bd%e6%95%b0 aria-label=高阶函数>高阶函数</a></li><li><a href=#%e8%bf%94%e5%9b%9e%e5%87%bd%e6%95%b0 aria-label=返回函数>返回函数</a></li><li><a href=#%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0 aria-label=匿名函数>匿名函数</a></li><li><a href=#%e8%a3%85%e9%a5%b0%e5%99%a8decorator aria-label=装饰器Decorator>装饰器Decorator</a></li><li><a href=#%e5%81%8f%e5%87%bd%e6%95%b0 aria-label=偏函数>偏函数</a></li></ul></li><li><a href=#%e6%a8%a1%e5%9d%97 aria-label=模块>模块</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=python中级使用>Python中级使用<a hidden class=anchor aria-hidden=true href=#python中级使用>#</a></h2><h3 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h3><ul><li><h4 id=调用函数>调用函数<a hidden class=anchor aria-hidden=true href=#调用函数>#</a></h4><ul><li>参数可以多个</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; max(1, 2)
</span></span><span style=display:flex><span>2
</span></span><span style=display:flex><span>&gt;&gt;&gt; max(2, 3, 1, -5)
</span></span><span style=display:flex><span>3
</span></span></code></pre></div><ul><li>参数类型需要一致</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; abs(&#39;a&#39;)
</span></span><span style=display:flex><span>TypeError: bad operand type for abs(): &#39;str&#39;
</span></span></code></pre></div><ul><li>函数调用</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; abs(100)
</span></span><span style=display:flex><span>100
</span></span><span style=display:flex><span>&gt;&gt;&gt; abs(-20)
</span></span><span style=display:flex><span>20
</span></span></code></pre></div><ul><li><p>数据类型转换</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; int(&#39;123&#39;)
</span></span><span style=display:flex><span>123
</span></span><span style=display:flex><span>&gt;&gt;&gt; int(12.34)
</span></span><span style=display:flex><span>12
</span></span><span style=display:flex><span>&gt;&gt;&gt; float(&#39;12.34&#39;)
</span></span><span style=display:flex><span>12.34
</span></span><span style=display:flex><span>&gt;&gt;&gt; str(1.23)
</span></span><span style=display:flex><span>&#39;1.23&#39;
</span></span><span style=display:flex><span>&gt;&gt;&gt; str(100)
</span></span><span style=display:flex><span>&#39;100&#39;
</span></span><span style=display:flex><span>&gt;&gt;&gt; bool(1)
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; bool(&#39;&#39;)
</span></span><span style=display:flex><span>False
</span></span></code></pre></div></li><li><p><em><strong>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; a = abs # 变量a指向abs函数
</span></span><span style=display:flex><span>&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数
</span></span><span style=display:flex><span>1
</span></span></code></pre></div></li></ul></li><li><h4 id=定义函数>定义函数<a hidden class=anchor aria-hidden=true href=#定义函数>#</a></h4><ul><li><p><em><strong>要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回</strong></em></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_abs</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> x
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(my_abs(<span style=color:#f92672>-</span><span style=color:#ae81ff>99</span>))
</span></span></code></pre></div></li></ul></li><li><p>空函数：定义一个什么事也不做的空函数，可以用<code>pass</code>语句</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>nop</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div></li><li><p><em><strong><code>pass</code>可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来</strong></em></p></li></ul></li><li><p>返回多个值</p><ul><li><p>需要从一个点移动到另一个点，给出坐标、位移和角度，就计算出新的坐标：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> math
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>move</span>(x, y, step, angle<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>):
</span></span><span style=display:flex><span>    nx <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> step <span style=color:#f92672>*</span> math<span style=color:#f92672>.</span>cos(angle)
</span></span><span style=display:flex><span>    ny <span style=color:#f92672>=</span> y <span style=color:#f92672>-</span> step <span style=color:#f92672>*</span> math<span style=color:#f92672>.</span>sin(angle)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> nx, ny
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=函数参数>函数参数<a hidden class=anchor aria-hidden=true href=#函数参数>#</a></h4><ul><li><p>普通形式</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>power</span>(x, n):
</span></span><span style=display:flex><span>    s <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        s <span style=color:#f92672>=</span> s <span style=color:#f92672>*</span> x
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> s
</span></span></code></pre></div></li></ul></li><li><p>默认参数：<strong>降低调用函数的难度</strong></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>power</span>(x, n<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>    s <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        s <span style=color:#f92672>=</span> s <span style=color:#f92672>*</span> x
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> power(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>25</span>
</span></span></code></pre></div></li><li><p><em><strong>一是必选参数在前，默认参数在后，否则Python的解释器会报错</strong></em></p></li><li><p><em><strong>二是如何设置默认参数</strong></em></p><ul><li><em><strong>多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数</strong></em></li></ul></li><li><p><strong>调用</strong></p><ul><li><strong>当不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll('Adam', 'M', city='Tianjin')</code></strong></li><li><strong>按顺序提供默认参数，比如调用<code>enroll('Bob', 'M', 7)</code>，意思是，除了<code>name</code>，<code>gender</code>这两个参数外，最后1个参数应用在参数<code>age</code>上，<code>city</code>参数由于没有提供，仍然使用默认值</strong></li></ul></li></ul></li><li><p><em><strong>默认参数的常见陷阱</strong></em></p><ul><li><p>定义一个函数，传入一个list，添加一个<code>END</code>再返回：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_end</span>(L<span style=color:#f92672>=</span>[]):
</span></span><span style=display:flex><span>    L<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;END&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> L
</span></span></code></pre></div></li><li><p>使用默认参数调用时，一开始结果也是对的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; add_end()
</span></span><span style=display:flex><span>[&#39;END&#39;]
</span></span></code></pre></div><p>但是，再次调用<code>add_end()</code>时，结果就不对了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; add_end()
</span></span><span style=display:flex><span>[&#39;END&#39;, &#39;END&#39;]
</span></span><span style=display:flex><span>&gt;&gt;&gt; add_end()
</span></span><span style=display:flex><span>[&#39;END&#39;, &#39;END&#39;, &#39;END&#39;]
</span></span></code></pre></div></li><li><p>原因解释如下：</p><p>Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，<strong>它指向对象<code>[]</code></strong>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了</p></li><li><p><em><strong>特别注意</strong></em></p></li></ul><p><em><strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_end</span>(L<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> L <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        L <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    L<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;END&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> L
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; add_end()
</span></span><span style=display:flex><span>[&#39;END&#39;]
</span></span><span style=display:flex><span>&gt;&gt;&gt; add_end()
</span></span><span style=display:flex><span>[&#39;END&#39;]
</span></span></code></pre></div></li><li><p>可变参数：<strong>允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple</strong></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calc</span>(<span style=color:#f92672>*</span>numbers):
</span></span><span style=display:flex><span>    sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> n <span style=color:#f92672>in</span> numbers:
</span></span><span style=display:flex><span>        sum <span style=color:#f92672>=</span> sum <span style=color:#f92672>+</span> n <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum
</span></span></code></pre></div><p><strong>在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; calc(1, 2)
</span></span><span style=display:flex><span>5
</span></span><span style=display:flex><span>&gt;&gt;&gt; calc()
</span></span><span style=display:flex><span>0
</span></span></code></pre></div></li><li><p>已经有一个list或者tuple，要调用一个可变参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; nums = [1, 2, 3]
</span></span><span style=display:flex><span>&gt;&gt;&gt; calc(*nums)
</span></span><span style=display:flex><span>14
</span></span></code></pre></div><p><em><strong><code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去</strong></em></p></li></ul></li><li><p>关键字参数</p><ul><li><p><strong>允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>person</span>(name, age, <span style=color:#f92672>**</span>kw):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;name:&#39;</span>, name, <span style=color:#e6db74>&#39;age:&#39;</span>, age, <span style=color:#e6db74>&#39;other:&#39;</span>, kw)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; person(&#39;Michael&#39;, 30)
</span></span><span style=display:flex><span>name: Michael age: 30 other: {}
</span></span><span style=display:flex><span>&gt;&gt;&gt; person(&#39;Adam&#39;, 45, gender=&#39;M&#39;, job=&#39;Engineer&#39;)
</span></span><span style=display:flex><span>name: Adam age: 45 other: {&#39;gender&#39;: &#39;M&#39;, &#39;job&#39;: &#39;Engineer&#39;}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; extra = {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}
</span></span><span style=display:flex><span>&gt;&gt;&gt; person(&#39;Jack&#39;, 24, **extra)
</span></span><span style=display:flex><span>name: Jack age: 24 other: {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}
</span></span></code></pre></div><p><strong><code>**extra</code>表示把<code>extra</code>这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个dict，注意<code>kw</code>获得的dict是<code>extra</code>的一份拷贝，对<code>kw</code>的改动不会影响到函数外的<code>extra</code></strong></p></li></ul></li><li><p>命名关键字参数</p><ul><li><p><strong>限制关键字参数的名字，就可以用命名关键字参数</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>person</span>(name, age, <span style=color:#f92672>*</span>, city, job):
</span></span><span style=display:flex><span>    print(name, age, city, job)
</span></span></code></pre></div><p>命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p><p>调用方式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; person(&#39;Jack&#39;, 24, city=&#39;Beijing&#39;, job=&#39;Engineer&#39;)
</span></span><span style=display:flex><span>Jack 24 Beijing Engineer
</span></span></code></pre></div><p>函数定义中有一可变参数，后面的命名关键字参数就不需要一个特殊分隔符<code>*</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>person</span>(name, age, <span style=color:#f92672>*</span>args, city, job):
</span></span><span style=display:flex><span>    print(name, age, args, city, job)
</span></span></code></pre></div><p>命名关键字参数必传入参数名，和位置参数不同。没有传入参数名，调用报错：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; person(&#39;Jack&#39;, 24, &#39;Beijing&#39;, &#39;Engineer&#39;)
</span></span><span style=display:flex><span>TypeError: person() missing 2 required keyword-only arguments: &#39;city&#39; and &#39;job
</span></span></code></pre></div></li><li><p>命名关键字参数可以有缺省值，从而简化调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>person</span>(name, age, <span style=color:#f92672>*</span>, city<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Beijing&#39;</span>, job):
</span></span><span style=display:flex><span>    print(name, age, city, job)
</span></span></code></pre></div><p>由于命名关键字参数<code>city</code>具有默认值，调用时，可不传入<code>city</code>参数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; person(&#39;Jack&#39;, 24, job=&#39;Engineer&#39;)
</span></span><span style=display:flex><span>Jack 24 Beijing Engineer
</span></span></code></pre></div></li></ul></li><li><p>参数组合</p><ul><li><em><strong>顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数</strong></em></li></ul></li></ul></li><li><p><strong>递归函数：一个函数在内部调用自身本身</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fact</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> n <span style=color:#f92672>*</span> fact(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div></li></ul><h3 id=高级特性减少代码量>高级特性：减少代码量<a hidden class=anchor aria-hidden=true href=#高级特性减少代码量>#</a></h3><ul><li><h4 id=切片>切片<a hidden class=anchor aria-hidden=true href=#切片>#</a></h4><ul><li><p><em><strong>用于<code>list</code>及其变种，进行连续指定索引的操作<code>[前索引:后索引:间隔]</code></strong></em></p></li><li><p><strong>取指定索引范围的操作</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; L = [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;, &#39;Bob&#39;, &#39;Jack&#39;]
</span></span></code></pre></div><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; L[0:3]
</span></span><span style=display:flex><span>[&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;]
</span></span></code></pre></div><p><strong><code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引<code>3</code>为止，但不包括索引<code>3</code></strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; L[:3]
</span></span><span style=display:flex><span>[&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;]
</span></span></code></pre></div><p><strong>第一个索引是<code>0</code>，还可以省略</strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; L[-2:]
</span></span><span style=display:flex><span>[&#39;Bob&#39;, &#39;Jack&#39;]
</span></span><span style=display:flex><span>&gt;&gt;&gt; L[-2:-1]
</span></span><span style=display:flex><span>[&#39;Bob&#39;]
</span></span></code></pre></div><p><strong>同样支持倒数切片，倒数第一个元素的索引是<code>-1</code></strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; L[:10:2]
</span></span><span style=display:flex><span>[0, 2, 4, 6, 8]
</span></span></code></pre></div><p><strong>前10个数，每两个取一个</strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]
</span></span><span style=display:flex><span>(0, 1, 2)
</span></span></code></pre></div><p><strong>tuple也可以用切片操作，只是操作的结果仍是tuple</strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; &#39;ABCDEFG&#39;[:3]
</span></span><span style=display:flex><span>&#39;ABC&#39;
</span></span><span style=display:flex><span>&gt;&gt;&gt; &#39;ABCDEFG&#39;[::2]
</span></span><span style=display:flex><span>&#39;ACEG&#39;
</span></span></code></pre></div><p><strong>字符串<code>'xxx'</code>也可以看成是一种list，每个元素就是一个字符</strong></p></li></ul></li></ul></li><li><h4 id=迭代>迭代<a hidden class=anchor aria-hidden=true href=#迭代>#</a></h4><ul><li><p><strong>通过<code>for ... in</code>循环遍历</strong></p><ul><li><p><strong>比如<code>dict</code>就可以迭代：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; d = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}
</span></span><span style=display:flex><span>&gt;&gt;&gt; for key in d:
</span></span><span style=display:flex><span>...     print(key)
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>a
</span></span><span style=display:flex><span>c
</span></span><span style=display:flex><span>b
</span></span></code></pre></div></li><li><p><strong>字符串也是可迭代对象，可以作用于<code>for</code>循环：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; for ch in &#39;ABC&#39;:
</span></span><span style=display:flex><span>...     print(ch)
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>A
</span></span><span style=display:flex><span>B
</span></span><span style=display:flex><span>C
</span></span></code></pre></div></li></ul></li><li><p>判断是否可迭代对象呢？方法是通过<code>collections.abc</code>模块的<code>Iterable</code>类型判断：</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; from collections.abc import Iterable
</span></span><span style=display:flex><span>&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable) # str是否可迭代
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代
</span></span><span style=display:flex><span>False
</span></span></code></pre></div></li><li><p><strong>Python内置的<code>enumerate</code>函数可以把一个<code>list</code>变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):
</span></span><span style=display:flex><span>...     print(i, value)
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>0 A
</span></span><span style=display:flex><span>1 B
</span></span><span style=display:flex><span>2 C
</span></span></code></pre></div></li><li><p><strong><code>for</code>循环里，同时引用了两个变量，比如下面的代码：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:
</span></span><span style=display:flex><span>...     print(x, y)
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>1 1
</span></span><span style=display:flex><span>2 4
</span></span><span style=display:flex><span>3 9
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=列表生成式>列表生成式<a hidden class=anchor aria-hidden=true href=#列表生成式>#</a></h4><ul><li><p><strong>Python内置的非常简单却强大的可以用来创建list的生成式</strong></p><ul><li><p>列表生成式则可以用一行语句代替循环生成上面的list：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; [x * x for x in range(1, 11)]
</span></span><span style=display:flex><span>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</span></span></code></pre></div></li><li><p>列表生成式也可以使用两个变量来生成list：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; d = {&#39;x&#39;: &#39;A&#39;, &#39;y&#39;: &#39;B&#39;, &#39;z&#39;: &#39;C&#39; }
</span></span><span style=display:flex><span>&gt;&gt;&gt; [k + &#39;=&#39; + v for k, v in d.items()]
</span></span><span style=display:flex><span>[&#39;y=B&#39;, &#39;x=A&#39;, &#39;z=C&#39;]
</span></span></code></pre></div></li><li><p>使用两层循环，可以生成全排列：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]
</span></span><span style=display:flex><span>[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]
</span></span></code></pre></div></li><li><p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0]
</span></span><span style=display:flex><span>[2, 4, 6, 8, 10]
</span></span></code></pre></div></li><li><p><strong>在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code></strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)]
</span></span><span style=display:flex><span>[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=生成器>生成器<a hidden class=anchor aria-hidden=true href=#生成器>#</a></h4><ul><li><p><strong>列表生成式，创建一个列表。受到内存限制，列表容量是有限。创建包含100万个元素列表，占用很大的存储，如果仅仅访问前面几个元素，绝大多数元素占用空间浪费</strong></p></li><li><p><strong>Python中，这种一边循环一边计算的机制，称为生成器：generator；generator保存的是算法</strong></p></li><li><p><strong>创建一个generator</strong></p><ul><li><p>只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator<strong>第一种方法</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; L = [x * x for x in range(10)]
</span></span><span style=display:flex><span>&gt;&gt;&gt; L
</span></span><span style=display:flex><span>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</span></span><span style=display:flex><span>&gt;&gt;&gt; g = (x * x for x in range(10))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; next(g)
</span></span><span style=display:flex><span>0
</span></span><span style=display:flex><span>&gt;&gt;&gt; next(g)
</span></span><span style=display:flex><span>1
</span></span><span style=display:flex><span>&gt;&gt;&gt; next(g)
</span></span><span style=display:flex><span>4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>或者
</span></span><span style=display:flex><span>&gt;&gt;&gt; for n in g:
</span></span><span style=display:flex><span>...     print(n)
</span></span><span style=display:flex><span>... 
</span></span><span style=display:flex><span>0
</span></span><span style=display:flex><span>1
</span></span><span style=display:flex><span>4
</span></span><span style=display:flex><span>9
</span></span><span style=display:flex><span>16
</span></span><span style=display:flex><span>25
</span></span><span style=display:flex><span>36
</span></span><span style=display:flex><span>49
</span></span><span style=display:flex><span>64
</span></span><span style=display:flex><span>81
</span></span></code></pre></div></li><li><p>把<code>fib</code>函数变成generator函数，只需要把<code>print(b)</code>改为<code>yield b</code>就可以<strong>第二种</strong></p><p><em>以斐波那契数列为例</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fib</span>(max):
</span></span><span style=display:flex><span>    n, a, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> n <span style=color:#f92672>&lt;</span> max:
</span></span><span style=display:flex><span>        print(b)
</span></span><span style=display:flex><span>        a, b <span style=color:#f92672>=</span> b, a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;done&#39;</span>
</span></span></code></pre></div><p>改为</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fib</span>(max):
</span></span><span style=display:flex><span>    n, a, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> n <span style=color:#f92672>&lt;</span> max:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> b
</span></span><span style=display:flex><span>        a, b <span style=color:#f92672>=</span> b, a <span style=color:#f92672>+</span> b
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;done&#39;</span>
</span></span></code></pre></div><p><em><strong>理解</strong></em></p><p><strong>普通函数是顺序执行，遇到<code>return</code>语句或者最后一行函数语句就返回。</strong></p><p><strong>generator函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行</strong></p></li></ul></li><li><p><strong>请务必注意：调用generator函数会创建一个generator对象，多次调用generator函数会创建多个相互独立的generator</strong></p><ul><li><p>eg:先错误后正确</p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>odd</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;step 1&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;step 2&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span>(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;step 3&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span>(<span style=color:#ae81ff>5</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; next(odd())
</span></span><span style=display:flex><span>step 1
</span></span><span style=display:flex><span>1
</span></span><span style=display:flex><span>&gt;&gt;&gt; next(odd())
</span></span><span style=display:flex><span>step 1
</span></span><span style=display:flex><span>1
</span></span><span style=display:flex><span>&gt;&gt;&gt; next(odd())
</span></span><span style=display:flex><span>step 1
</span></span><span style=display:flex><span>1
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; g = odd()
</span></span><span style=display:flex><span>&gt;&gt;&gt; next(g)
</span></span><span style=display:flex><span>step 1
</span></span><span style=display:flex><span>1
</span></span><span style=display:flex><span>&gt;&gt;&gt; next(g)
</span></span><span style=display:flex><span>step 2
</span></span><span style=display:flex><span>3
</span></span><span style=display:flex><span>&gt;&gt;&gt; next(g)
</span></span><span style=display:flex><span>step 3
</span></span><span style=display:flex><span>5
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=迭代器>迭代器<a hidden class=anchor aria-hidden=true href=#迭代器>#</a></h4><ul><li><p><strong>可以直接作用于<code>for</code>循环的数据类型有以下几种：</strong></p><p><strong>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</strong></p><p><strong>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</strong></p><p>这些可以直接作用于<code>for</code>循环的对象统称为<strong>可迭代对象</strong></p><ul><li><code>isinstance()</code>判断一个对象是否是**<code>Iterable</code>**对象：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; from collections.abc import Iterable
</span></span><span style=display:flex><span>&gt;&gt;&gt; isinstance([], Iterable)
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; isinstance({}, Iterable)
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable)
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; isinstance(100, Iterable)
</span></span><span style=display:flex><span>False
</span></span></code></pre></div></li><li><p>使用<code>isinstance()</code>判断一个对象是否是**<code>Iterator</code>**对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; from collections.abc import Iterator
</span></span><span style=display:flex><span>&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; isinstance([], Iterator)
</span></span><span style=display:flex><span>False
</span></span><span style=display:flex><span>&gt;&gt;&gt; isinstance({}, Iterator)
</span></span><span style=display:flex><span>False
</span></span><span style=display:flex><span>&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterator)
</span></span><span style=display:flex><span>False
</span></span></code></pre></div><p><strong>可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型</strong></p><ul><li><p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; isinstance(iter([]), Iterator)
</span></span><span style=display:flex><span>True
</span></span><span style=display:flex><span>&gt;&gt;&gt; isinstance(iter(&#39;abc&#39;), Iterator)
</span></span><span style=display:flex><span>True
</span></span></code></pre></div></li></ul></li><li><p>总结</p><ul><li><em><strong>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code></strong></em></li></ul></li></ul></li></ul><h3 id=函数式编程>函数式编程<a hidden class=anchor aria-hidden=true href=#函数式编程>#</a></h3><ul><li><p>特点：允许把函数本身作为参数传入另一个函数，还允许返回一个函数</p></li><li><h4 id=高阶函数>高阶函数<a hidden class=anchor aria-hidden=true href=#高阶函数>#</a></h4><ul><li><p>特点：<strong>变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数</strong></p></li><li><p>变量指向函数</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; f = abs
</span></span><span style=display:flex><span>&gt;&gt;&gt; f(-10)
</span></span><span style=display:flex><span>10
</span></span></code></pre></div></li><li><p><em><strong>变量<code>f</code>已经指向<code>abs</code>函数本身。调用<code>abs()</code>函数和调用变量<code>f()</code>完全相同</strong></em></p></li></ul></li><li><p>函数名也是变量</p><ul><li><p>函数名就是指向函数的变量</p></li><li><p>对<code>abs()</code>函数，可以把函数名<code>abs</code>看成变量，指向可以计算绝对值的函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; abs = 10
</span></span><span style=display:flex><span>&gt;&gt;&gt; abs(-10)
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
</span></span><span style=display:flex><span>TypeError: &#39;int&#39; object is not callable
</span></span></code></pre></div></li><li><p><strong>实际代码不是这样写，只为说明</strong></p></li></ul></li><li><p>高阶函数总结举例</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(x, y, f):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> f(x) <span style=color:#f92672>+</span> f(y)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(add(<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, abs))
</span></span></code></pre></div></li></ul></li><li><p><strong><code>map()</code>和<code>reduce()</code>函数</strong></p><ul><li><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; def f(x):
</span></span><span style=display:flex><span>...     return x * x
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
</span></span><span style=display:flex><span>&gt;&gt;&gt; list(r)
</span></span><span style=display:flex><span>[1, 4, 9, 16, 25, 36, 49, 64, 81]
</span></span></code></pre></div></li><li><p><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做<em><strong>累积计算</strong></em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>reduce(f, [x1, x2, x3, x4]) <span style=color:#f92672>=</span> f(f(f(x1, x2), x3), x4)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; from functools import reduce
</span></span><span style=display:flex><span>&gt;&gt;&gt; def add(x, y):
</span></span><span style=display:flex><span>...     return x + y
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])
</span></span><span style=display:flex><span>25
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=返回函数>返回函数<a hidden class=anchor aria-hidden=true href=#返回函数>#</a></h4><ul><li><p>特点：把函数作为结果值返回</p></li><li><p>eg:<strong>如果不需要立刻求和，可以不返回求和的结果，而是返回求和的函数</strong></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>lazy_sum</span>(<span style=color:#f92672>*</span>args):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sum</span>():
</span></span><span style=display:flex><span>        ax <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> n <span style=color:#f92672>in</span> args:
</span></span><span style=display:flex><span>            ax <span style=color:#f92672>=</span> ax <span style=color:#f92672>+</span> n
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ax
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum
</span></span></code></pre></div><p>我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)
</span></span><span style=display:flex><span>&gt;&gt;&gt; f
</span></span><span style=display:flex><span>&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;
</span></span></code></pre></div><p>调用函数<code>f</code>时，才真正计算求和的结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; f()
</span></span><span style=display:flex><span>25
</span></span></code></pre></div><p><strong>调用<code>lazy_sum()</code>时，每次调用都会返回一个新的函数，即使传入相同的参数：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)
</span></span><span style=display:flex><span>&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)
</span></span><span style=display:flex><span>&gt;&gt;&gt; f1==f2
</span></span><span style=display:flex><span>False
</span></span></code></pre></div></li></ul></li><li><p>闭包</p><ul><li>定义：<em><strong>返回的函数在其定义内部引用了局部变量<code>args</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用</strong></em></li><li><em><strong>注意：返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong></em></li></ul></li></ul></li><li><h4 id=匿名函数>匿名函数<a hidden class=anchor aria-hidden=true href=#匿名函数>#</a></h4><ul><li><p>定义：<em><strong>传入函数时，有些时候，不需要显式地定义函数</strong></em></p></li><li><p>使用：</p><ul><li><p>关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
</span></span><span style=display:flex><span>[1, 4, 9, 16, 25, 36, 49, 64, 81]
</span></span></code></pre></div><p>匿名函数<code>lambda x: x * x</code>实际上就是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>f</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>*</span> x
</span></span></code></pre></div><p>限制：只能有一个表达式，不用写<code>return</code>，返回值是该表达式的结果</p></li><li><p><strong>也是一个函数对象，可以把匿名函数赋值给一个变量，再利用变量来调用该函数</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; f = lambda x: x * x
</span></span><span style=display:flex><span>&gt;&gt;&gt; f
</span></span><span style=display:flex><span>&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;
</span></span><span style=display:flex><span>&gt;&gt;&gt; f(5)
</span></span><span style=display:flex><span>25
</span></span></code></pre></div></li><li><p><strong>可以把匿名函数作为返回值返回</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>build</span>(x, y):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>lambda</span>: x <span style=color:#f92672>*</span> x <span style=color:#f92672>+</span> y <span style=color:#f92672>*</span> y
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=装饰器decorator>装饰器Decorator<a hidden class=anchor aria-hidden=true href=#装饰器decorator>#</a></h4><ul><li><p>定义：<strong>这种在代码运行期间动态增加功能的方式</strong></p></li><li><p>函数是对象，函数对象可被赋值给变量，所以，变量能调用该函数</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; def now():
</span></span><span style=display:flex><span>...     print(&#39;2024-6-1&#39;)
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&gt;&gt;&gt; f = now
</span></span><span style=display:flex><span>&gt;&gt;&gt; f()
</span></span><span style=display:flex><span>2024-6-1
</span></span></code></pre></div><p>函数对象有<code>__name__</code>属性（注意：前后各两个下划线），<strong>可拿到函数的名字：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; now.__name__
</span></span><span style=display:flex><span>&#39;now&#39;
</span></span><span style=display:flex><span>&gt;&gt;&gt; f.__name__
</span></span><span style=display:flex><span>&#39;now&#39;
</span></span></code></pre></div></li><li><p><strong>decorator是返回函数的高阶函数。所以，要定义一个能打印日志的decorator</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>log</span>(func):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>wrapper</span>(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kw):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;call </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>():&#39;</span> <span style=color:#f92672>%</span> func<span style=color:#f92672>.</span>__name__)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> func(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kw)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> wrapper
</span></span></code></pre></div><p>上面的<code>log</code>，它是一个decorator，接受一个函数作为参数，并返回一个函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@log</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>now</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;2024-6-1&#39;</span>)
</span></span></code></pre></div><p>调用<code>now()</code>函数，不仅运行<code>now()</code>函数本身，还运行<code>now()</code>函数前打印一行日志：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; now()
</span></span><span style=display:flex><span>call now():
</span></span><span style=display:flex><span>2024-6-1
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=偏函数>偏函数<a hidden class=anchor aria-hidden=true href=#偏函数>#</a></h4><ul><li><p>定义：<code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code></p></li><li><p>举例：</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; import functools
</span></span><span style=display:flex><span>&gt;&gt;&gt; int2 = functools.partial(int, base=2)
</span></span><span style=display:flex><span>&gt;&gt;&gt; int2(&#39;1000000&#39;)
</span></span><span style=display:flex><span>64
</span></span><span style=display:flex><span>&gt;&gt;&gt; int2(&#39;1010101&#39;)
</span></span><span style=display:flex><span>85
</span></span></code></pre></div><p><em><strong><code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单</strong></em></p></li><li><p>最后，创建偏函数时，实际可以接收<strong>函数对象</strong>、**<code>*args</code><strong>和</strong><code>**kw</code>**这3个参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>int2 = functools.partial(int, base=2)
</span></span></code></pre></div><p>实际上固定了int()函数的关键字参数<code>base</code>，也就是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>int2(<span style=color:#e6db74>&#39;10010&#39;</span>)
</span></span></code></pre></div><p>相当于：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>kw <span style=color:#f92672>=</span> { <span style=color:#e6db74>&#39;base&#39;</span>: <span style=color:#ae81ff>2</span> }
</span></span><span style=display:flex><span>int(<span style=color:#e6db74>&#39;10010&#39;</span>, <span style=color:#f92672>**</span>kw)
</span></span></code></pre></div><p>当传入：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>max2 <span style=color:#f92672>=</span> functools<span style=color:#f92672>.</span>partial(max, <span style=color:#ae81ff>10</span>)
</span></span></code></pre></div><p>实际上会把<code>10</code>作为<code>*args</code>的一部分自动加到左边，也就是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>max2(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>)
</span></span></code></pre></div><p>相当于：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>args <span style=color:#f92672>=</span> (<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>)
</span></span><span style=display:flex><span>max(<span style=color:#f92672>*</span>args)
</span></span></code></pre></div><p>结果为<code>10</code></p></li></ul></li></ul></li></ul><h3 id=模块>模块<a hidden class=anchor aria-hidden=true href=#模块>#</a></h3><ul><li><p><strong>在python中，一个.py文件就称之为一个模块（Module）</strong></p><ul><li><p>一个<code>abc.py</code>的文件就是一个名字叫<code>abc</code>的模块</p></li><li><p>每一个包目录下面都有一个<code>__init__.py</code>的文件，这个文件<strong>必须存在</strong>，否则，Python把这个目录当普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是<code>mycompany</code></p><pre tabindex=0><code>mycompany
├─ __init__.py
├─ abc.py
└─ xyz.py
</code></pre></li></ul></li><li><p>使用模块</p><ul><li><p>编写一个<code>hello</code>的模块</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python3</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -*- coding: utf-8 -*-</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39; a test module &#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>__author__ <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Michael Liao&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test</span>():
</span></span><span style=display:flex><span>    args <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>argv
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(args)<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;Hello, world!&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> len(args)<span style=color:#f92672>==</span><span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;Hello, </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>!&#39;</span> <span style=color:#f92672>%</span> args[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;Too many arguments!&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__<span style=color:#f92672>==</span><span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    test()
</span></span></code></pre></div><ul><li><p>第1行和第2行是标准注释</p><ul><li>第1行注释可以让这个<code>hello.py</code>文件直接在Unix/Linux/Mac上运行</li><li>第2行注释表示.py文件本身使用标准UTF-8编码</li></ul></li><li><p>第4行是一个字符串，表示<strong>模块的文档注释</strong>，任何模块代码的第一个字符串都被视为模块的文档注释；</p></li><li><p>第6行使用<code>__author__</code>变量把作者写进去</p></li><li><p><em><strong>以上六行就是Python模块的标准文件模板，当然也可以全部删掉不写</strong></em></p></li><li><p>使用<code>sys</code>模块的第一步，就是导入该模块：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span></code></pre></div></li><li><p><em><strong><code>sys</code>模块有一个<code>argv</code>变量，用list存储了命令行的所有参数。<code>argv</code>至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：</strong></em></p><p>运行<code>python3 hello.py</code>获得的<code>sys.argv</code>就是<code>['hello.py']</code>；</p><p>运行<code>python3 hello.py Michael</code>获得<code>sys.argv</code>就是<code>['hello.py', 'Michael']</code></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__<span style=color:#f92672>==</span><span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    test()
</span></span></code></pre></div><p><strong>当在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ python3 hello.py
</span></span><span style=display:flex><span>Hello, world!
</span></span><span style=display:flex><span>$ python hello.py Michael
</span></span><span style=display:flex><span>Hello, Michael!
</span></span></code></pre></div></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ python3
</span></span><span style=display:flex><span>Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) 
</span></span><span style=display:flex><span>[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
</span></span><span style=display:flex><span>Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.
</span></span><span style=display:flex><span>&gt;&gt;&gt; import hello
</span></span><span style=display:flex><span>&gt;&gt;&gt;
</span></span></code></pre></div><p>导入时，没有打印<code>Hello, word!</code>，因为没有执行<code>test()</code>函数。</p><p>调用<code>hello.test()</code>时，才能打印出<code>Hello, word!</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&gt;&gt;&gt; hello.test()
</span></span><span style=display:flex><span>Hello, world!
</span></span></code></pre></div></li></ul></li><li><p>作用域</p><ul><li><em><strong>一个模块中，可能会定义很多函数和变量，但有的函数和变量希望给别人使用，有的函数和变量希望仅仅在模块内部使用</strong></em></li><li>正常的函数和变量名是公开(public),可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等</li><li>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，<strong>自己的变量一般不要用这种变量名</strong></li><li>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等<ul><li><strong>private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量</strong></li></ul></li><li>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public</li></ul></li></ul></li><li><p>安装第三方模块</p><ul><li><code>pip install 你想要安装的第三方库</code></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/python/>Python</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/python02/><span class=title>« Prev Page</span><br><span>Python高级</span>
</a><a class=next href=https://zwlzls.github.io/posts/git01/><span class=title>Next Page »</span><br><span>Git实战</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>