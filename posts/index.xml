<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 我的博客</title>
    <link>https://zwlzls.github.io/posts/</link>
    <description>Recent content in Posts on 我的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 02 Apr 2025 23:55:41 +0800</lastBuildDate><atom:link href="https://zwlzls.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Jmeter03</title>
      <link>https://zwlzls.github.io/posts/jmeter03/</link>
      <pubDate>Wed, 02 Apr 2025 23:55:41 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/jmeter03/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Jmeter02</title>
      <link>https://zwlzls.github.io/posts/jmeter02/</link>
      <pubDate>Wed, 02 Apr 2025 23:55:33 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/jmeter02/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Jmeter01</title>
      <link>https://zwlzls.github.io/posts/jmeter01/</link>
      <pubDate>Wed, 02 Apr 2025 23:55:29 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/jmeter01/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Jmeter00</title>
      <link>https://zwlzls.github.io/posts/jmeter00/</link>
      <pubDate>Wed, 02 Apr 2025 23:55:25 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/jmeter00/</guid>
      <description>内容来自用户手册_Apache JMeter中文网进行重点摘要
入门 概述 计划构建 在GUI模式下运行JMeter </description>
    </item>
    
    <item>
      <title>UnitTest01</title>
      <link>https://zwlzls.github.io/posts/unittest01/</link>
      <pubDate>Wed, 26 Mar 2025 21:37:13 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/unittest01/</guid>
      <description></description>
    </item>
    
    <item>
      <title>UnitTest00</title>
      <link>https://zwlzls.github.io/posts/unittest00/</link>
      <pubDate>Wed, 26 Mar 2025 21:37:10 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/unittest00/</guid>
      <description> 以下内容来自《单元测试之道Java版》 简介 **单元测试：**开发者编写的一小段代码，用于检验被测代码的一个很小的，很明确的功能是否正确。或言之，用于判断某个特定条件下特定函数的行为。 执行单元测试：证明某段代码的行为确实和开发者所期望的一致 意义： </description>
    </item>
    
    <item>
      <title>Ddia02</title>
      <link>https://zwlzls.github.io/posts/ddia02/</link>
      <pubDate>Thu, 06 Mar 2025 22:44:21 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/ddia02/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Ddia01</title>
      <link>https://zwlzls.github.io/posts/ddia01/</link>
      <pubDate>Thu, 06 Mar 2025 22:44:18 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/ddia01/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Ddia00</title>
      <link>https://zwlzls.github.io/posts/ddia00/</link>
      <pubDate>Thu, 06 Mar 2025 22:44:11 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/ddia00/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Hot100</title>
      <link>https://zwlzls.github.io/posts/algorithm05/</link>
      <pubDate>Sat, 01 Mar 2025 23:37:24 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/algorithm05/</guid>
      <description>Hot100 贪心算法 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0
class Solution { public int maxProfit(int[] prices) { if(prices.length==0){ return 0; } int max=0,len=prices.length; int pre=prices[0]; for(int p:prices){ if(p&amp;lt;pre){ pre=p; } max=Math.max(max,p-pre); } return max; } } 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false
class Solution { public boolean canJump(int[] nums) { int n = nums.length; int farthest = 0; for (int i = 0; i &amp;lt; n - 1; i++) { // 不断计算能跳到的最远距离 farthest = Math.</description>
    </item>
    
    <item>
      <title>Efficiency02</title>
      <link>https://zwlzls.github.io/posts/efficiency02/</link>
      <pubDate>Sat, 01 Mar 2025 18:54:22 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/efficiency02/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《软件研发效能提升之美01》</title>
      <link>https://zwlzls.github.io/posts/efficiency01/</link>
      <pubDate>Sat, 01 Mar 2025 18:54:18 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/efficiency01/</guid>
      <description>内容来自《软件研发效能提升之美》一书 上一节偏思想方面，这次更多偏实操相关 DevOps落地精要 核心解读 DevOps字面上是Development和Operations的组合，即开发、运维⼀体化，测试作为质量保障角色也会融合其中，⼀体化最大的优势就是打破壁垒、拉通职能，最终体现在效能的提升上，同时把握产品质量与业务增长的平衡点
DevOps的六大武器
标准化作业 好处是能够固化流程，将人力从重复劳动中解放出来，同时有效地减少错误的发生 快速失败 DevOps实践中，通常会引入CI/CD技术，通过高频集成和高频交付，将问题暴露在早期 快速反应 消除角色壁垒，尽可能用工具替代人力，并用流水线方式加速流程 高质量与高效率 DevOps通过持续部署、快速反馈的方式，更好地将不确定性逐步转变为确定性，从而保障⾼质量交付 降低成本 当DevOps模式运作成熟，尤其是快速迭代的流水线初成规模后，软件研发的效率将大大提升，研发成本将明显降低，应对变化的能力也将大幅提高 团队协作 DevOps依靠⼯具和自动化（尤其是流程自动化）来弥补开发与运维之间的技能鸿沟和沟通鸿沟，将软件研发中的三大角色（研发、运维、测试）有效地黏合在⼀起 DevOps是⼀种软件研发管理模式和思想，是⼀种文化实践，并不是具体的⼯具或技术，所有在保证质量的前提下提升效能的方法都属于DevOps的范畴
DevOps生命周期 持续开发 持续开发包含计划和编码⼯作，伴随这⼀阶段的工具主要有代码仓库、版本控制⼯具、包管理⼯具，以及⼀些计划可视化方法，如⽢特图、燃尽图等，也会涉及分⽀管理、单元测试等⼯作 持续集成 持续集成是DevOps中最核⼼的组成部分，通过频繁地提交代码、频繁地编译代码、频繁地构建项⽬、频繁地执⾏单元测试等，不断高频集成，贯彻快速失败的原则，尽可能早地收敛问题 持续测试 持续测试需要确保软件代码的每⼀次提交都能够被及时验证，并输出完整的质量反馈。纯⼈⼯的⽅式很难做到持续测试，⾃动化测试和容器化手段是这⼀阶段的标配 持续监控 这⾥的监控不仅是指对软件运行状况的监控，还包括对DevOps各项⼯作执⾏的监控，以便我们及时做出处理和纠正。持续监控还可以提供历史趋势信息，帮助我们更好地提供决策依据 持续反馈 整个软件研发周期的每⼀项⼯作都对外暴露了大量的信息，持续反馈在每个关键节点介入，以各种形式总结输出反馈建议，并不断改进，从而推动项目良性循环 持续部署 持续部署同样基于高频的理念，尽可能早地让软件产品接受生产的检验，快速发现并收敛问题，保证软件产品及早与用户见面 持续运营 运营阶段涉及对事件和变更的管理，如配置管理、容量管理、高可用管理、用户体验管理等，是DevOps的最后⼀个阶段。运营也是⼀项连续性的⼯作，是需要持续不断进行的。相对于其他周期项，持续运营更需要具备全局视角，才能做到目无全牛 不适合DevOps的场景
在⼀些传统行业或政府机关，软件需求较为固定，甚至会采用外包的方式，且研发周期较长，对质量要求很高 传统金融领域或⼀些从事机密行业的商业机构 代码，分支与流水线 代码是软件产品的原始生产产物，经过编译、构建、测试、发布、部署后，形成可用的产品对象
三个重要因素对研发效能起关键作用
代码，软件产品究其本质都是由代码构成的，代码的质量直接决定了整个研发周期的投入和产出
分支，我们探讨的不是小作坊式的单⼈开发模式，软件开发团队需要在同⼀代码基础上并发进行多个功能的代码编写活动，显然不可能让员工在相同文件上作业，这时候就需要分支和配套的⼯作流。分⽀的实质是能够让研发活动并发起来，提升效率
流水线，在上述例子中，无论是软件代码的集成和交付过程，还是厨师生产美味佳肴的过程，都是⼀道道⼯序不断向前推进的 持续过程。流水线⼀方面可以使流程固化，避免⼈为因素造成的不确定性；另⼀方面能够透明地将每道⼯序的结果呈现出来，便于及早识别问题
代码质量 代码质量不是研发单体的责任，发现质量问题也不是测试单体的责任。我们所谈到的代码质量是需要由软件项⽬中涉 及的所有角色共同保证的，⽬的就是尽可能早地将质量问题消除在源头。绝⼤部分缺陷都是在编码阶段“写”出来的，⽽问题发现得越早，修复的成本就越低
测试驱动开发
从实践⾓度来讲，狭义的TDD，即UTDD（Unit Test DrivenDevelopment，单元测试驱动开发）对研发模式的侵⼊性是⽐较⼤的，现实中很多研发⼈员会不习惯，导致推⼴困难。我们可以考虑将测试⼯作上升至业务层，推行ATDD（Acceptance Test DrivenDevelopment，验收测试驱动开发），先定义质量标准和验收细则，再通过⾃动化测试的⽅式进行验收，这样就能够在代码编写和交付阶段预防缺陷 静态扫描
⼀种成本较低的质量保障手段，它最⼤的好处是不需要运行代码，仅仅通过分析静态代码结构和抽象语法树，就能发现潜 在的风险和违反规约的地方。目前市面上比较流行的静态扫描⼯具有阿里的代码规约扫描⼯具、Sonar、Findbugs、PMD等 代码评审
代码评审对质量保障的重要性不言而喻，但实际⼯作中就是另⼀番景象了，做得好的团队经常能够主动发现代码问题，做得不好的团队则流于形式，草草签字、画押了事
并至主干分支前进行，评审完成后再进行正式的测试⼯作
分支与工作流 分⽀的存在允许多人同时⼯作而互不干扰，不过我们总要在某个时机，将多分⽀代码合并成⼀份，以便⽣成最终交付的代码版本，这个过程涉及版本管理、发布管理、缺陷修复等⼀系列环节 工作流： Git Flow⼀共设计了5种分支，其中包含两种长期存在的“主要分支”（master和develop）和三种暂时存在的“协助分 支”（feature、release和hotfix） master分支上保持的版本必须是时刻可以发布运行的，因此不允许在master上直接进行修改和提交，只有其他分支的代码经过⼀系列的流程验证后，才能合⼊master。 develop分支是代码开发的基准分支，也不允许直接修改和提交。 feature分⽀是开发者编码的主要⼯作分支，在develop分支建⽴完成后，通过PR的⽅式合并回develop分支。 release分⽀是⽤来进⾏版本发布的分支，发布成功后分别合⼊develop和master分⽀。 hotfix分⽀⽤于处理紧急bug修复，在master分支建⽴、修复完成后，hotfix分支将合⼊develop和master分支 流水线 从DevOps的视⾓看，流⽔线是持续交付的载体，通过构建⾃动化、集成⾃动化、验证⾃动化、部署⾃动化等⼯作，完成从开发到上线的持续交付过程。其中，每个环节相当于CPU中的各个电路单元，在整体上形成了并⾏的效果，通过持续向团队提供及时的反馈，让交付过程⾼效、顺畅 精益理论强调了价值流动的重要性，⽽价值流动需要通过⼀定的⽅式来体现，DevOps流⽔线从某种程度上说就是⼀个很好的 载体，因为它⼏乎覆盖了整个端到端的流程。在流⽔线上，各环节流转得越快，价值流动就越快，这间接体现了公司的研发效能 Jenkins Pipeline⽀持声明式和脚本式两种脚本编写⽅式，前者语法限制多，偏模板化，⽽后者则更⾃由，善于应对复杂的需求。下⾯我们以声明式的⽅式尝试编写⼀个流⽔线脚本，覆盖代码拉取、构建、部署、测试等⼀系列环节 持续集成与持续交付 集成，指部分向整体合并的过程，⽐如，某⼯程师研发的代码，将其合并到主干的过程就是集成，这其中涉及编译、打包、构建、单 元测试等工作。</description>
    </item>
    
    <item>
      <title>《软件研发效能提升之美00》</title>
      <link>https://zwlzls.github.io/posts/efficiency00/</link>
      <pubDate>Sat, 01 Mar 2025 18:54:14 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/efficiency00/</guid>
      <description>内容《软件研发效能提升之美》之书 总论 研发效能是多⼈组织协同效率的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统
研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视 整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率
**没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍
希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业
敏捷作为⼀种通过创造变化和响应变化在不确定和混乱的环境中取得成功的能力，具备高度的实践性和创造性，这样的特性在赋予敏捷强大适配度的同时，也给落地造成了困难
概述 研发效能提升案例
前端代码的自动生成
我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。
这种方式的引入将大幅提升原型构建环节的效率
临界参数下的API测试
考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值
进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露
例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题
基于流程优化的效能提升
效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便 第一性原理：顺畅、高质量地持续交付有效价值的闭环
顺畅：价值的流动过程必须顺畅，没有阻碍 高质量：如果质量不行，那么流动越快，死得也会越快 **持续：**不能时断时续，小步快跑才是正道 **有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题 **闭环：**强调快速反馈的重要性 鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让 鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋 从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践
举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤
架构相对简单，但是集群规模庞大，则优选金丝雀 架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势 研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的
研发效能提升实践：
找钉子，场景举例：
本地编译耗时长：提供增量编译和分布式编译能力 本地测试困难，测试环境准备复杂且耗时长：基于Kubernetes的Pod提供⼀键搭建测试环境的能力 自动化测试用例数量大，执行回归时间过长：采用并发测试用例执行机制，使用几百、几千台测试执行机并行执行用例，实现用硬件资源换时间 自动化测试用例维护成本高：测试用例采用模块化和分层体系，实现低成本的自动化用例维护 测试数据准备困难：引入统⼀的测试数据服务（Test DataService）能力 集群规模庞大，发布过程耗时过长：各个层级的并发部署能力，集群内节点的并发、集群间的并发等。 项目的过程数据都是后期集中填充，失去度量意义：项目的过程数据由⼯具自动填充，不再依赖⼯程师手工输入。比如，开发完成的时间不再依赖于开发人员手工填写，而是由Jenkins构建完成后自动填写，以保证所有过程数据的真实有效性，从⽽为后面的度量和改进提供可靠的信息输入 全局切入：
软件缺陷的流转，软件需求的实现与交付，软件制品包发布等待 持续改进：
比如，需要在Jenkins中通过hook机制去触发⼀些操作（比如代码静态扫描、单元测试等），最简单的做法就是在hook中实现操作的具体步骤，这种实现在开始时效率很高，也非常容易实现，但却不是最优的⽅案，因为hook中的代码只会被执行⼀次，而且hook越来越多以后，各种实现都散落在各个地方，难以维护，⼀旦有新的需要（比如要加⼊慢SQL扫描），就需要改hook实现，而且这种做法也违背了IaC（Infrastructure as Code）原则。
更好的做法是引入研发效能的消息中心，通过下游操作的订阅模式来实现未来的可扩展性
效能平台的灵活性
将Jenkins持续集成⼯具视为⼀个平台，在这个平台上支持安装各种插件，以增强平台功能，从而实现平台架构的灵活性 杜绝&amp;quot;掩耳盗铃&amp;quot;
代码质量门禁Sonar设而不卡 单元测试只是执行，不写断⾔Assert 代码覆盖率形同虚设 Peer Review走过场 代码递交过于随意 监控超配，有报警但无人认领 发展方向与未来展望
研发各个环节的全链路横向打通 CI/CD和测试不再是⼀个个独立的环节，软件研发从需求开始到最终线上交付采用⼀站式的研发效能平台，实现统⼀的研发⼯具和流程 研发全流程的可视化 研发流程的可视化在后期⼀定会成为⾏业的标配，通过流程的可视化，可以展示各个需求的进展情况，让各级管理者和⼀线⼯程师清楚地知道项目目前所处的状态。 “稳态”和“敏态”齐头并进 研发效能的提升并不⼀定都要绑定到敏捷开发实践上，事实上，对于那些需求明确并且稳定的项目，传统的瀑布模型依然是最佳的选择，此时采用“稳态”实践才是获得最佳效率的途径。只有那些需求变更频繁的项目才是践行敏捷实践的最佳选择。因此，敏捷对传统瀑布而言并不是取代，⽽是互补，“稳态”和“敏态”会在长时期内和谐共存。 研发能力的中台化沉淀 研发各阶段的垂直能⼒必然会沉淀到中台，以统⼀服务化的形式对外提供服务。⽐如，代码覆盖率的统计能⼒会统⼀到⼀个单⼀的服务中，为各个语⾔的业务提供代码覆盖率的统计；再如，分布式编译加速的能⼒也会成为企业级的服务，为各种⼤型项目提供编译加速。 数据驱动下的效能提升 以后的决策⼀定会基于数据来开展。效能提升实践的效果衡量也会⾼度依赖于数据。研发效能数据中台的建设必定会被提上⽇程，通过收集存储研发各阶段的各种过程数据，实现基于研发效能⼤数据平台的决策体系 进阶解读 软件生产作为智⼒密集型活动，掺杂着⼤量人的因素，很难严格地标准化 质量和效能是“既要、也要”的关系，效能的提升能够将软件研发中的⻛险更快、更及时地暴露出来，同时减轻⼈脑负担，反过来⼜ 能提升质量本身 渴望尊重和欣赏，是⼈性的需求之⼀。适度的关注和赞美能够产⽣强烈的心理暗示，继而带来效能的提升 反摩尔定律告诉我们，越迟交付的价值其价值越低 信息熵衰减对研发效能的影响是巨⼤的，要想方设法将信息传递的效率提升上去 自解释的代码不是无注释和无文档的代码，而是伴随着⾼信息熵的代码体系。内容简洁合理的注释与⽂档，同样也是优秀代码的⼀部分，能够给效能的提升带来帮助 基于流程优化，打破各个环节看不见的墙，去除不必要的等待，提升价值流动速度，这些是研发效能试图解决的一大类问题 项目管理提效 敏捷宣言</description>
    </item>
    
    <item>
      <title>数据结构知识</title>
      <link>https://zwlzls.github.io/posts/algorithm06/</link>
      <pubDate>Wed, 26 Feb 2025 23:38:15 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/algorithm06/</guid>
      <description>数据结构 数据结构知识 具体内容
数组：数组的内存空间是连续的，随机访问的时间复杂度是O1，适用于需要按索引访问元素的场景，但是插入和删除元素较慢，时间复杂度是On 链表：链表是由节点组成，节点之间是分散存储的，内存不连续，每个节点存储数据和指向下一个节点的指针。适用于频繁插入和删除元素的场景，随机访问元素较慢 栈：栈是一种后进先出的数据结构，只允许在栈顶进行插入和删除操作 队列：队列是一种先进先出（FIFO）的数据结构，允许在队尾插入元素，在队首删除元素 树：树是一种非线性数据结构，由节点和边组成，每个节点可以有多个子节点。树适用于表示层次关系的场景，例如文件系统、组织结构等 数组与链表区别？
访问效率，插入和删除操作效率，缓存命中率 应用场景：数组适合静态大小、频繁访问元素的场景，而链表适合动态大小、频繁插入、删除操作的场景 平衡二叉树
二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质： 非空左子树的所有键值小于其根结点的键值。 非空右子树的所有键值大于其根结点的键值。 左、右子树都是二叉搜索树。 二叉树搜索树的目的：缩短插入、删除、修改和查找节点的时间 一棵理想的二叉搜索树所有操作的时间可以缩短到 O(logn) 一棵每个结点只有右孩子的二叉搜索树，那么性质就和链表一样 平衡树将二叉查找树平衡均匀地分布，好处就是可以减少二叉查找树的深度 平衡二叉树平衡的特性： 左右两个子树的高度差（平衡因子）的绝对值不超过1 左右两个子树都是一棵平衡二叉树 红黑树
每个节点要么是红色，要么是黑色。 根节点是黑色。 每个叶子节点（NIL节点）是黑色。 如果一个节点是红色，则其子节点必须是黑色。 从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。 二叉查找树
当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n) 平衡二叉查找树 每个节点的左子树和右子树的高度差不能超过 1。也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 O(logn) B+树
B+树是一种自平衡的多路查找树，所有叶节点都位于同一层，保证了树的平衡，使得搜索、插入和删除操作的时间复杂度为对数级别的 非叶节点仅包含索引信息，不存储具体的数据记录，用来引导搜索到正确的叶节点 所有数据记录都存储在叶节点中，且叶节点中的数据是按关键字排序的。叶节点包含实际的数据和关键字，是数据存储和检索的实体单元。叶节点之间通过指针相互链接，形成一个链表，便于范围查询和顺序遍历 B+树与B-树
检索路径：B树在查找数据时，可能在非叶子节点找到目标数据，路径长度不固定。B+树中所有数据都在叶子节点，查找数据时必须走到叶子节点，路径长度固定（均等）。即查找总是要到叶子节点结束 叶子节点结构：B树中叶子节点之间没有特别的链接，彼此独立。B+树中叶子节点通过指针连接，形成一个有序链表，便于范围查询和顺序访问 非叶子节点内容：B树中非叶子节点存储数据和索引。B+树中非叶子节点只存储索引，不存储实际数据。当数据量比较大时，相对于B树，B+树的层高更少，查找效率也就更高。 **高效地范围查询：**B+树叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树在进行范围查询时需要进行中序遍历，性能较差 堆
堆是一颗完全二叉树，实现的堆也被称为二叉堆。堆中节点的值都大于等于（或小于等于）其子节点的值，堆中如果节点的值都大于等于其子节点的值，我们把它称为大顶堆，如果都小于等于其子节点的值，我们将其称为小顶堆 排序算法 冒泡排序：通过相邻元素的比较和交换，每次将最大（或最小）的元素逐步“冒泡”到最后（或最前）。时间复杂度：最好情况下O(n)，最坏情况下O(n^2)，平均情况下O(n^2)。，空间复杂度：O(1)
//冒泡排序 public static void bubbleSort(int[] arr) { int temp;//临时变量 boolean flag;//是否交换的标志 for (int i = 0; i &amp;lt; arr.</description>
    </item>
    
    <item>
      <title>Hot100</title>
      <link>https://zwlzls.github.io/posts/algorithm03/</link>
      <pubDate>Mon, 24 Feb 2025 13:13:09 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/algorithm03/</guid>
      <description>Hot100 回溯 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;res; int len=0; public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(int[] nums) { this.res=new LinkedList&amp;lt;&amp;gt;(); this.len=nums.length; dfs(nums,new LinkedList&amp;lt;&amp;gt;(),new boolean[len]); return res; } public void dfs(int[] nums,LinkedList path,boolean[]p){ if(path.size()==len){ res.add(new LinkedList&amp;lt;&amp;gt;(path)); return; } for(int i=0;i&amp;lt;len;i++){ if(p[i]){ continue; } p[i]=true; path.add(nums[i]); dfs(nums,path,p); p[i]=false; path.remove(path.size()-1); } } } 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;res=new LinkedList&amp;lt;&amp;gt;(); LinkedList&amp;lt;Integer&amp;gt;track=new LinkedList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) { backtracking(nums,0); return res; } public void backtracking(int[] nums,int start){ res.</description>
    </item>
    
    <item>
      <title>算法总结</title>
      <link>https://zwlzls.github.io/posts/algorithm04/</link>
      <pubDate>Mon, 24 Feb 2025 13:13:05 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/algorithm04/</guid>
      <description>以前写的总结 框架思维：
数据结构的存储方式：数组和链表 任何数据结构无非遍历和访问，在不同的场合高效增删改查 而遍历分为线性和非线性（for/while和递归） 算法心得：
算法的本质就是无穷举 数组/单链表常用：双指针，二分搜索，滑动窗口，回文子串，前缀和，差分数组 二叉树常用：1.遍历一遍二叉树(递归函数无返回值) 2.分解问题计算答案(递归函数有返回值) 二叉树：
void traverse(TreeNode root) { if (root == null) { return; } // 前序位置 :进入结点的时候 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 :离开结点的时候 } 层序遍历：竖while横for 链表：双指针
设置虚拟结点，用指针来进行变化，同时新建链表注意指明最后一个结点 回溯算法：
回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」 我们通过保证元素之间的相对顺序来防止出现重复子集&amp;mdash;-用start变量 标记那些元素可以被选择&amp;mdash;&amp;ndash;用used数组 重复元素中找可能解&amp;mdash;-先排序，用num[i]==num[i-1]来减枝 重复元素的全排列&amp;mdash;-先排序，用num[i]==num[i-1]&amp;amp;&amp;amp;!used[i-1]固定相同数值位置来减枝（规则：相同则前一个必走过），且used[i]标记该数值是否被使用 子集/组合问题必须用start，排列问题必用used数组 数组：
双指针
一维前缀和：preSum[i] 记录 nums[0..i-1] 的累加和
二维前缀和：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和 对于前缀和问题：申请新数组范围是n+1，数组实际从索引1开始
差分数组：差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。 后面数据靠前面的差值，diff[i] 就是 nums[i] 和 nums[i-1] 之差 如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可：</description>
    </item>
    
    <item>
      <title>devops概述</title>
      <link>https://zwlzls.github.io/posts/devops00/</link>
      <pubDate>Mon, 24 Feb 2025 13:13:01 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/devops00/</guid>
      <description>devops介绍 https://github.com/lcomplete/TechShare/blob/master/docs/engineering/devops.md全文
定义 DevOps 所要实现的目标都是一致的——缩短软件开发生命周期并使用 持续交付 提供高质量的软件，开发运维之间 沟通合作
发展背景： 敏态需求的增加，即探索性工作的增加： 软件开发从传统的瀑布流方式到敏捷开发，再到现在对敏捷开发提出了更高的要求，近些年创新型的应用不断涌现，这些应用的研发过程中多采用小步快跑、快速试错的方式，这些探索性工作要求运维能够具备一天发布多次的能力，需要企业完成由稳态到敏态的转变 软件开发活动在企业经营活动中占比的不断增加： 业务发展对软件的依赖由轻度依赖、中度依赖发展到目前的重度依赖。 企业存在对消除浪费的需求： 软件开发活动在企业中的位置越来越重要，软件开发活动中也存在着许多的浪费，企业管理上必然存在着 识别并消除浪费 的需求 软件开发中的浪费包括不必要和必要的浪费： 不必要的浪费有：无人使用的功能、软件bug、等待测试、等待审批等 必要的浪费包括：工作项移交、测试、项目管理 以上为深层原因，浅层原因有：容器化技术的发展、微服务架构的发展等等 DevOps原则 DevOps 原则是总体指导思想，实践是具体的执行方法，DevOps 是一个动态的过程，在进行相关实践的时候可以看看其应用了哪些原则，当违背原则的时候需要思考实践的合理性
三大原则：
流动原则：加速 从开发、运维到交付给客户的流程 反馈原则：建设 安全可靠 的工作体系 持续学习与实验原则：采用科学工作方式，将对组织的 改进和创新 作为工作一部分 流转原则： 坚持少做 产品开始开发时采用 MVP 原则（最小可行产品原则） MVP要求抓住最核心的产品流程，剥掉多余的功能或者高级功能，只要主流程可以跑起来可以。完美并不是我们的目标，快速试错才是我们目标 产品迭代时要适时做减法 持续分解问题 大的变更或需求拆解为一系列小的变更，快速解决 工作可视化 采用 Sprint 看板将工作可视化 控制任务数量 减少前置时间，降低测试人员的等待时间 任务越多，预估越不准确 减少交接次数 减少不必要的沟通和等待 持续识别和改善约束点 识别出影响流动的主要前置因素，比如搭建环境、需求文档 QA、开发、运维、产品持续提升生产力 为非功能性需求预留20%的开发时间，减少技术债务 消除价值流中的困境和浪费（导致交付延迟的主要因素） 半成品——未完全完成的工作 额外工序——从不使用的文档、重复编写接口文档等 额外功能——用户实际不需要的功能 任务切换——将人员分配到多个项目或截然不同的工作任务中 等待、移动、缺陷、非标准化的手动操作 返回原则 在复杂系统中安全地工作 管理复杂的工作，识别出设计和操作的问题 群策群力解决问题，从而快速构建新知识 在整个组织中，将区域性的知识应用到全局范围 领导者要持续培养有以上才能的人 及时发现问题 快速、频繁和高质量的信息流——每个工序的操作都会被度量和监控 技术价值流的每个阶段（产品管理、开发、QA、安全、运维），建立快速的反馈和前馈回路（包括自动化构建、集成和测试过程） 全方位的遥测系统 在源头保障质量 过多的检查和审批流程，使得做决策的地方远离执行工作的地方，这导致流程有效性降低，减弱了因果关系之间反馈的强度。 让开发人员也对系统质量负责，快速反馈，加速开发人员的学习。 为内部客户优化工作 运维的非功能性需求（如架构、性能、稳定性、可测试性、可配置性和安全性）与用户功能同样重要 持续学习和实验原则 建立学习型组织和安全文化 将日常工作的改进制度化 把局部发现转化为全局优化 在日常工作中注入弹性模式 缩短部署的前置时间、提高测试覆盖率、缩短测试执行时间，甚至在必要时解耦架构，都属于在系统中引入类似张力的做法。 领导层强化学习文化 领导者帮助一线工作者在日常工作中发现并解决问题 DevOps实践 基于 DevOps 的相关原则，有与其对应的实践，在应用这些实践之前还需认真设计组织结构，使其有利于实践的开展</description>
    </item>
    
    <item>
      <title>Hot100</title>
      <link>https://zwlzls.github.io/posts/algorithm02/</link>
      <pubDate>Mon, 24 Feb 2025 13:13:01 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/algorithm02/</guid>
      <description>Hot100 二叉树 给定一个二叉树的根节点 root ，返回 它的 中序 遍历
class Solution { public List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) { List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;Integer&amp;gt;(); Stack&amp;lt;TreeNode&amp;gt; stk = new Stack&amp;lt;TreeNode&amp;gt;(); while (root != null || !stk.isEmpty()) { while (root != null) { stk.push(root); root = root.left; } root = stk.pop(); res.add(root.val); root = root.right; } return res; } } 思考中序过程就行
给定一个二叉树 root ，返回其最大深度。
二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。
class Solution { public int maxDepth(TreeNode root) { return Depth(root); } public int Depth(TreeNode root){ if(root==null){ return 0; } int left=Depth(root.</description>
    </item>
    
    <item>
      <title>Hot100</title>
      <link>https://zwlzls.github.io/posts/algorithm01/</link>
      <pubDate>Mon, 24 Feb 2025 13:12:57 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/algorithm01/</guid>
      <description>Hot100 哈希 两数之和
class Solution { public int[] twoSum(int[] nums, int target) { HashMap&amp;lt;Integer,Integer&amp;gt;map=new HashMap&amp;lt;&amp;gt;(); int len=nums.length; for(int i=0;i&amp;lt;len;i++){ int p=target-nums[i]; if(map.containsKey(p)){ return new int[]{i,map.get(p)}; } map.put(nums[i],i); } return new int[]{0,0}; } } 字母异位分组
class Solution { public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupAnagrams(String[] strs) { HashMap&amp;lt;String,LinkedList&amp;lt;String&amp;gt;&amp;gt;cur=new HashMap&amp;lt;&amp;gt;(); for(String str:strs){ char[] c1=str.toCharArray(); Arrays.sort(c1); String s=String.valueOf(c1); if(!cur.containsKey(s)){ cur.put(s,new LinkedList&amp;lt;&amp;gt;()); cur.get(s).add(str); }else{ cur.get(s).add(str); } } return new LinkedList(cur.values()); } } 最长连续序列：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度
class Solution { public int longestConsecutive(int[] nums) { int ans = 0; Set&amp;lt;Integer&amp;gt; st = new HashSet&amp;lt;&amp;gt;(); for (int num : nums) { st.</description>
    </item>
    
    <item>
      <title>数据结构Java版</title>
      <link>https://zwlzls.github.io/posts/algorithm00/</link>
      <pubDate>Mon, 24 Feb 2025 13:12:54 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/algorithm00/</guid>
      <description>数据结构 数组 ArrayList`&amp;lt;Integer&amp;gt;`arr=new ArrayList&amp;lt;&amp;gt;();int[]c=new int[3];数组建立 arr.add(99);数组增加 arr.toArray(a);集合变成数组类型 arr.add(3,99);数组插入 arr.get(3);获得元素值 arr.set(3,22);改变元素值 arr.remove(3);移除某索引的元素 Collections.reverse(arr);反转一个arr arr.size();长度	普通数组长度为：length arr.contains(99);是否含有某元素 Collections.sort(arr);集合类的排序 Arrays.sort(c);普通排序 Arrays.fill(c, 1);填充数组c的所有值为1 二维数组排序：第一列按升序排列，第一列相同，则第二列按升序排列 compare方法返回值int类型，返回值大于0，交换两数，小于零，排序正确，等于0，两数相等 Arrays.sort(arr, new Comparator&amp;lt;int[]&amp;gt;() { public int compare(int[] e1, int[] e2) { // 如果第一列元素相等，则比较第二列元素 if (e1[0]==e2[0]) return e1[1]-e2[1]; // e1[1]-e2[1]表示对于第二列元素进行升序排序 return e1[0]-e2[0]; } Arrays.sort(intervals,new Comparator&amp;lt;int[]&amp;gt;(){//两数相减或相加会产生int值溢出，因此通过比较后，直接返回-1，0，1 public int compare(int[]e1,int[]e2){// e1[0]-e2[0]表示对于第一列元素进行升序排序 if(e1[0]&amp;gt;e2[0]){ return 1; }else if(e1[0]==e2[0]){ return 0; }else{ return -1; } } }); Arrays.sort(intervals, (e1, e2) -&amp;gt; Integer.compare(e1[0], e2[0]));//上面可简写 Arrays.sort(strings,(s1,s2)-&amp;gt; (s1+s2).compareTo(s2+s1)); Collections.</description>
    </item>
    
    <item>
      <title>TestNG</title>
      <link>https://zwlzls.github.io/posts/testng/</link>
      <pubDate>Mon, 17 Feb 2025 20:29:33 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/testng/</guid>
      <description>TestNG TestNG是一个Java语言的测试框架，也是QA最常用的测试框架之一
TestNG官网文档地址：TestNG 文档 &amp;mdash; TestNG Documentation
有时间再依据这个重新学下https://lwmzz.blog.csdn.net/article/details/129173343有代码实践 简介 TestNG 是一个测试框架，从单元测试（与其他类隔离的情况下测试一个类）到集成测试（测试由多个类、多个包甚至多个外部框架（如应用服务器）组成的整个系统）
编写测试通常是一个三步过程：
编写您测试的业务逻辑，并在您的代码中插入TestNG注解。 到 testng.xml 文件中或在build.xml中添加有关您的测试信息（例如，类名、您希望运行的组等） 运行TestNG 可以在欢迎页面找到一个快速示例
文档中主要概念：
套件由一个XML文件表示。可以包含一个或多个测试，并由&amp;lt;suite&amp;gt;标记定义 测试用例由&amp;lt;test&amp;gt;表示，可以包含一个或多个TestNG类 TestNG类是一个包含至少一个TestNG注解的Java类。它由&amp;lt;class&amp;gt;标记表示，可以包含一个或多个测试方法 测试方法是代码中的@Test注解的Java方法 可以通过@BeforeXXX和@AfterXXX注解进行配置，这些注解允许在某个特定点之前和之后执行一些 Java 逻辑，这些点可以是上述列表中的任何一项 其余部分将解释以下内容：
所有注解的列表以及简要说明。这将让您了解TestNG提供的各种功能，但可能需要查阅专用于每个注解的部分以了解详细信息。 testng.xml文件的说明，语法以及您可以在其中指定的内容。 各种功能的详细列表以及如何结合注解和testng.xml使用它们 注解 以下TestNG中可用注解及其属性的快速概述
注解：BeforeXXX &amp;amp; AfterXXX
TestNG类的配置信息：
@BeforeSuite：在此套件中的所有测试运行之前，将运行带注解的方法。 @AfterSuite：在此套件中的所有测试运行后，将运行带注解的方法。 @BeforeTest：在运行属于&amp;lt;test&amp;gt;标记内的类的任何测试方法之前，将运行带注解的方法。 @AfterTest：在运行属于&amp;lt;test&amp;gt;标记内的类的所有测试方法之后，将运行带注解的方法。 @BeforeGroups：此配置方法之前将运行的组列表。保证在调用属于任何这些组的第一个测试方法之前不久运行此方法。 @AfterGroups：此配置方法将在之后运行的组列表。保证在调用属于任何这些组的最后一个测试方法后不久运行此方法。 @BeforeClass：在调用当前类中的第一个测试方法之前，将运行带注解的方法。 @AfterClass：在运行当前类中的所有测试方法之后，将运行带注解的方法。 @BeforeMethod：带注解的方法将在每个测试方法之前运行。 @AfterMethod：带注解的方法将在每个测试方法之后运行 TestNG类的超类中的注解行为
超类是指被继承的类
超类中的注解行为会被继承到子类中。
执行顺序:
@Before 类注解 : 从超类到子类 @After 类注解：从子类到超类。 当放置在TestNG类的超类上时，上述注解也将被兑现（继承）。例如，这对于在公共超类中集中多个测试类的测试设置非常有用
import org.testng.annotations.BeforeClass; import org.testng.annotations.BeforeMethod; import org.testng.annotations.AfterClass; import org.testng.annotations.AfterMethod; public class BaseTest { @BeforeClass public void beforeClass() { System.</description>
    </item>
    
    <item>
      <title>Jenkins01</title>
      <link>https://zwlzls.github.io/posts/jenkins01/</link>
      <pubDate>Sun, 16 Feb 2025 21:54:58 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/jenkins01/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Jenkins00</title>
      <link>https://zwlzls.github.io/posts/jenkins00/</link>
      <pubDate>Sun, 16 Feb 2025 21:54:51 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/jenkins00/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Docker01</title>
      <link>https://zwlzls.github.io/posts/docker01/</link>
      <pubDate>Sun, 16 Feb 2025 21:52:29 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/docker01/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Docker介绍</title>
      <link>https://zwlzls.github.io/posts/docker00/</link>
      <pubDate>Sun, 16 Feb 2025 21:52:25 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/docker00/</guid>
      <description>总体概述 docker是什么 是什么？
开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化 完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,且容器性能开销极低 基于 Go 语言开源的应用容器引擎，遵从 Apache2.0 协议开源 为什么？
一次构建，随处运行 更快速的应用交付和部署 更便捷的升级和扩缩容 更简单的系统运维； Docker与虚拟机对比
Docker的镜像层一般很小，只有几十KB，而虚拟机则通常以GB为单位。
性能方面，Docker依附于宿主机，所以性能接近宿主机，而虚拟机相对于原主机来说性能较差。资源利用率方面，Docker的资源利用率较高，而虚拟机的资源利用率较低。
隔离性方面，Docker和虚拟机都具有安全隔离的特性。
Docker直接在宿主机内核上运行，而虚拟机运行在隔离层Hypervisor上。
Docker可同时运行上千个容器，而虚拟机相对厚重，最多只能启动几十个。
在运行速度方面，Docker优于虚拟机，Docker容器的启动和停止可以在秒级实现，而传统的虚拟机方式要慢得多
架构
三个基础概念
镜像（image）：Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器
镜像唯一标识是其 ID 和摘要，而一个镜像可以有多个标签 并非是像一个 ISO 那样的打包文件，是一个虚拟的概念。是由一组文件系统组成，或者说，由多层文件系统联合组成 容器（container）： Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。 可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。
可把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写
仓库（repository）：仓库（Repository）是集中存放镜像文件的场所
仓库注册服务器上存放着多个仓库，每个仓库中包含多个镜像，每个镜像有不同的标签（tag）
使用镜像 Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像
获取镜像
Docker 镜像仓库获取镜像的命令是 docker pull
$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 对Docker Hub，如果不给出用户名，则默认为 library，就是官方镜像
$ docker pull ubuntu:18.</description>
    </item>
    
    <item>
      <title>Redis(持久化一致性淘汰)</title>
      <link>https://zwlzls.github.io/posts/redis01/</link>
      <pubDate>Mon, 10 Feb 2025 15:11:19 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/redis01/</guid>
      <description>持久化 AOF 文件的内容是操作命令； RDB 文件的内容是二进制数据 AOF Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 redis.conf
Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里
这保存写操作命令到日志的持久化方式，是 Redis 里的 AOF(Append Only File) 持久化功能，注意只会记录写操作命令，读操作命令是不会被记录的
Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的
避免额外的检查开销 不会阻塞当前写操作命令的执行，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志 风险：
执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险 写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是可能会给「下一个」命令带来阻塞风险 执行过程：
Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区； 通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘； 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定 写回硬盘策略： Always，「总是」，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘； Everysec，「每秒」，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，每隔一秒将缓冲区里的内容写回到硬盘； No，不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘 AOF重写机制
AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大 Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制 机制是在重写时，读取当前数据库中的所有键值对，将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件 妙处在于：尽管某个键值对被多条写命令反复修改，最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对 AOF后台重写</description>
    </item>
    
    <item>
      <title>Redis(类型)</title>
      <link>https://zwlzls.github.io/posts/redis00/</link>
      <pubDate>Mon, 10 Feb 2025 15:11:14 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/redis00/</guid>
      <description>数据类型及应用 https://onecompiler.com/redis可以进行实践
String String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值
数据结构实现主要是int和SDS
SDS 不仅可以保存文本数据，还可以保存二进制数据 因为 SDS 使用 len 属性的值判断字符串是否结束 SDS 获取字符串长度的时间复杂度是 O(1) SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1) Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容 常用指令
# 设置 key-value 类型的值 &amp;gt; SET name lin OK # 根据 key 获得对应的 value &amp;gt; GET name &amp;#34;lin&amp;#34; # 判断某个 key 是否存在 &amp;gt; EXISTS name (integer) 1 # 返回 key 所储存的字符串值的长度 &amp;gt; STRLEN name (integer) 3 # 删除某个 key 对应的值 &amp;gt; DEL name (integer) 1 批量设置 :</description>
    </item>
    
    <item>
      <title>Mysql事务日志锁</title>
      <link>https://zwlzls.github.io/posts/mysql01/</link>
      <pubDate>Mon, 10 Feb 2025 15:10:54 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/mysql01/</guid>
      <description>事务 事务是由 MySQL 的引擎来实现，常见的 InnoDB 引擎它是支持事务的 并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务
特性 具体特性
原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节；事务在执行过程中发生错误，会被回滚到事务开始前的状态 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态 隔离性：允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失 如何保证特性？
持久性是通过 redo log （重做日志）来保证的 原子性是通过 undo log（回滚日志） 来保证的 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的 一致性则是通过持久性+原子性+隔离性来保证 隔离级别 MySQL服务端允许多个客户端连接，意味着 MySQL 会出现同时处理多个事务的情况 问题： 脏读：如果一个事务「读到」了另一个「未提交事务修改过的数据」 事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，被读 不可重复读：一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况 事务A两次读取过程中，事务B进行修改且提交 幻读：一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况 事务A两次读取过程中，事务B进行修改且提交 隔离级别 读未提交：一个事务还没提交时，它做的变更就能被其他事务看到 读提交：一个事务提交之后，它做的变更才能被其他事务看到 可重复读：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别 串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行 「可重复读」但是很大程度上避免幻读现象 针对快照读（普通 select 语句），通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的 针对当前读（select &amp;hellip; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，当执行 select &amp;hellip; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那这个插入语句就会被阻塞，无法成功插入 四种隔级别实现 「读未提交」可以读到未提交事务修改的数据，所以直接读取最新的数据就好 「串行化」通过加读写锁的方式来避免并行访问； 「读提交」和「可重复读」通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View 执行「开始事务」begin/start transaction 命令 执行了 begin/start transaction 命令后，并不代表事务启动了 只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机 Read View在MVCC工作 Read View 有四个重要的字段： m_ids ：在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务 min_trx_id ：在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值 max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，就是全局事务中最大的事务 id 值 + 1 creator_trx_id ：创建该 Read View 的事务的事务 id InnoDB 存储引擎的数据库表，聚簇索引记录中包含下面两个隐藏列： trx_id：一个事务对某条聚簇索引记录进行改动时，会把该事务的事务 id 记录在 trx_id 隐藏列里 roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录 通过「版本链」控制并发事务访问同一个记录时的行为叫 MVCC（多版本并发控制） 可重复读和读提交如何工作 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View 读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View 日志 undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC</description>
    </item>
    
    <item>
      <title>Mysql索引查询</title>
      <link>https://zwlzls.github.io/posts/mysql00/</link>
      <pubDate>Mon, 10 Feb 2025 15:10:24 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/mysql00/</guid>
      <description>MySQL查询过程 MySQL 的架构共分为两层：Server 层和存储引擎层
Server 层负责建立连接、分析和执行 SQL。主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现 存储引擎层负责数据的存储和提取。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。索引数据结构就是由存储引擎层实现，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引 第一步：连接器 启动Mysql服务，连接 MySQL 服务
# -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数； # -u 指定用户名，管理员角色名为 root； # -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码 mysql -h$ip -u$user -p 查看 MySQL 服务被多少客户端连接
执行 show processlist 命令进行查看
MySQL 定义空闲连接的最大空闲时长，由 wait_timeout 参数控制的，如果空闲连接超过了这个时间，连接器就会自动将它断开
mysql&amp;gt; show variables like &amp;#39;wait_timeout&amp;#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | wait_timeout | 28800 | +---------------+-------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title>OS调度网络</title>
      <link>https://zwlzls.github.io/posts/os01/</link>
      <pubDate>Mon, 10 Feb 2025 15:10:02 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/os01/</guid>
      <description>调度算法 进程调度 总论 当CPU空闲，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU 什么时候会发生 CPU 调度 当进程从运行状态转到等待状态 当进程从运行状态转到就绪状态 当进程从等待状态转到就绪状态 当进程从运行状态转到终止状态 其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」， 2 和 3 两种情况下发生的调度称为「抢占式调度」 非抢占式：当进程正在运行时，会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程 抢占式：进程正在运行的时，可以被打断，使其把 CPU 让给其他进程 先来先服务调度 先来后到，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行 对长作业有利，适用 CPU 繁忙型作业的系统，而不适用 I/O 繁忙型作业的系统 最短作业优先调度 会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量 显然对长作业不利，很容易造成一种极端现象 高响应比优先调度 每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行 时间片轮转调度 每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行 最高优先级调度 对多用户计算机系统就有不同的看法，它们希望调度是有优先级的，即希望调度程序能从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级调度 优先级可分为： 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化 动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，就随着时间的推移增加等待进程的优先级 多级反馈队列调度 「时间片轮转算法」和「最高优先级算法」的综合和发展 「多级」有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。 「反馈」如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列； 内存页面置换 缺页异常（缺页中断）
当 CPU 访问的页面不在物理内存，便产生一个缺页中断，请求操作系统将所缺页调入到物理内存。与一般中断区别在于： 缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号 缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行 页面置换算法：当出现缺页异常，需调入新页面但内存已满，选择被置换的物理页面，也就选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页 最佳页面置换
置换在「未来」最长时间不访问的页面，但无法实现 先进先出置换
选择在内存驻留时间很长的页面进行中置换，就是「先进先出置换」算法的思想 最近最久未使用置换
发生缺页时，选择最长时间没有被访问的页面进行置换，假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用 时钟页面置换
把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面
缺页中断时，首先检查表针指向的页面：
如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置； 如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止 网络 I/O多路复用 服务用户数量</description>
    </item>
    
    <item>
      <title>OS内存进程</title>
      <link>https://zwlzls.github.io/posts/os00/</link>
      <pubDate>Mon, 10 Feb 2025 15:09:56 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/os00/</guid>
      <description>总论 现代操作系统，内核一般会提供 4 个基本能力： 管理进程、线程，决定哪个进程、线程使用 CPU，也是进程调度的能力； 管理内存，决定内存的分配和回收，也是内存管理的能力； 管理硬件设备，为进程与硬件设备之间提供通信能力，也是硬件通信能力； 提供系统调用，如果应用程序要运行更高权限运行的服务，就需要有系统调用，是用户程序与操作系统之间的接口 内核具有很高的权限，可控制 cpu、内存、硬盘等硬件，而应用程序具有的权限很小。 因此大多数操作系统，把内存分成了两个区域 内核空间：这个内存空间只有内核程序可以访问 用户空间：这个内存空间专门给应用程序使用 用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间 当程序使用用户空间时，我们常说该程序在用户态执行 当程序使内核空间时，程序则在内核态执行 应用程序如果需要进入内核空间，就需要通过系统调用 内核程序执行在内核态，用户程序执行在用户态 应用程序使用系统调用时，会产生一个中断。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序（开始执行内核程序） 内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作 现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响 内存管理 虚拟内存 单片机的 CPU 是直接操作内存的「物理地址」 想在内存中同时运行两个程序是不可能的。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的 解决方法？ 把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，大家自己玩自己的地址就行，互不干涉 有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的 理解：之所以不能同时运行，就是因为两个程序引用相同物理地址，也就是不能让其使用相同的物理地址，加一层映射过去 操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来 程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了 引出两种地址概念： 我们程序所使用的内存地址叫做虚拟内存地址 实际存在硬件里面的空间地址叫物理内存地址 操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存 虚拟内存作用： 第一，虚拟内存使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域 理解：加载一个很大的存储，原本只能一次性，现在可分按需批 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性 内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来 分段机制下，虚拟地址的物理地址的映射 分段机制下的虚拟地址由两部分：段选择因子和段内偏移量 段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。 虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址 虚拟地址是通过段表与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址 问题： 第一个是内存碎片 内存分段管理可以做到段根据实际需求分配内存，有多少需求就分配多大的段，所以不会出现内部内存碎片，但是由于每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以会出现外部内存碎片 解决「外部内存碎片」的是内存交换 内存交换空间，在Linux中，是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换 第二个是内存交换的效率低 如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿 内存分页 分段的好处就是能产生连续的内存空间 但会出现「外部内存碎片和内存交换的空间太大」的问题 解决这些问题，那么就要想出能少出现一些内存碎片的办法 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小，这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB 虚拟地址与物理地址之间通过页表来映射 页表存储在内存里，内存管理单元 （MMU）将虚拟内存地址转换成物理地址工作 当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行 解决分段问题 内存分页由于内存空间都是预先划分好的，采用了分页，页与页之间是紧密排列的，所以不会有外部碎片 内存分页机制分配内存的最小单位是一页，即程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对内存分页机制会有内部内存碎片 内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高 分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中，只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去 分页机制，虚拟地址与物理地址的映射 分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址 总结一下，对于一个内存地址转换，就是这样三个步骤： 把虚拟内存地址，切分成页号和偏移量； 根据页号，从页表里面，查询对应的物理页号； 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址 缺陷： 操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大 在 32 位的环境，虚拟地址空间共 4GB，假设一个页大小是 4KB（2^12），就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节(4B)来存储，那整个 4GB 空间的映射就需要 4MB 的内存来存储页表 100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存 多级页表 解决分页的缺陷 把这 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 1024 页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页 算机组成原理里面无处不在的局部性原理 每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存 一级页表就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表 深入理解思想： 从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址 页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项 此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建 TLB 多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，带来了时间上的开销 程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域 最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB 有TLB 后，那么 CPU 在寻址时，先查 TLB，如果没找到，才会继续查常规的页表 TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个 段页式内存管理 内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为段页式内存管理 段页式内存管理实现方式： 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制 再把每个段划分为多个页，也就对分段划分出来的连续空间，再划分固定大小的页 这样，地址结构就由段号、段内页号和页内位移三部分组成 段页式地址变换中要得到物理地址须经过三次内存访问： 第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址 Linux内存结构 Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护 Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制 每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存 分配内存 应用程序通过 申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存</description>
    </item>
    
    <item>
      <title>Network(TCP)</title>
      <link>https://zwlzls.github.io/posts/network01/</link>
      <pubDate>Mon, 10 Feb 2025 15:09:41 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/network01/</guid>
      <description>TCP握手挥手 TCP TCP 是面向连接的、可靠的、基于字节流的传输层通信协议
面向连接：一定是「一对一」才能连接，不能像 UDP 协议一个主机同时向多个主机发送消息 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端 字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序不知道「消息的边界」，无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃 TCP连接
用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接 Socket：由 IP 地址和端口号组成 序列号：用来解决乱序问题等 窗口大小：用来做流量控制 TCP与UDP区别
1. 连接
TCP 是面向连接的传输层协议，传输数据前先要建立连接。 UDP 是不需要连接，即刻传输数据。 2. 服务对象
TCP 是一对一的两点服务，即一条连接只有两个端点。 UDP 支持一对一、一对多、多对多的交互通信 3. 可靠性
TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。 UDP 是尽最大努力交付，不保证可靠交付数据。但是可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议 4. 拥塞控制、流量控制
TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。 UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。 5. 传输方式
TCP 是流式传输，没有边界，但保证顺序和可靠。 UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。 6. 分片不同
TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。 UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层 传输层的「端口号」是为了区分同一个主机上不同应用程序的数据包 传输层两个传输协议 TCP 和 UDP，在内核中是两个完全独立的软件模块</description>
    </item>
    
    <item>
      <title>网络基础</title>
      <link>https://zwlzls.github.io/posts/network00/</link>
      <pubDate>Mon, 10 Feb 2025 15:09:37 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/network00/</guid>
      <description>网络模型 同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式
不同设备上的进程间通信，需要网络通信，而设备是多样性的，协商出了一套通用的网络协议
TCP/IP网络模型 应用层 最上层的，也是我们能直接接触到的，应用就把应用数据传给下一层，就是传输层 应用层为用户提供应用功能，比如 HTTP、FTP等 传输层 传输层会有两个传输协议，分别是 TCP 和 UDP TCP：大部分应用使用的正是 TCP 传输层协议，比如HTTP。TCP有流量控制、超时重传、拥塞控制等，为保证数据包能可靠地传输给对方 UDP：只负责发送数据包，不保证数据包是否能抵达对方，它实时性相对更好，传输效率也高 应用需要传输的数据可能会非常大，当传输层的数据包大小超过 MSS(TCP 最大报文段长度)，将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块 MTU：一个网络包最大长度，以太网中一般为 1500 字节。 MSS：除去 IP 和 TCP 头部后，一个网络包所能容纳的 TCP 数据的最大长度。 传输层负责把数据包传给应用，但一台设备上会有很多应用接收或者传输数据，用编号将应用区分开来，这个编号是端口 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的 对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号 网络层 传输层协议处理太多的事情，只需要服务好应用即可；而实际的传输功能就交给下一层，也就网络层，负责将数据从一个设备传输到另一个设备 IP 协议将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文；如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文 IP 地址给设备进行编号 IPv4 协议, IP 地址共 32 位，分成了四段（比如192.168.100.1），每段是8位 将 IP 地址分成两种意义： 网络号，负责标识该 IP 地址是属于哪个「子网」的； 主机号，负责标识同一「子网」下的不同主机 配合子网掩码才能算出 IP 地址 的网络号和主机号 比如 10.</description>
    </item>
    
    <item>
      <title>Java细知识</title>
      <link>https://zwlzls.github.io/posts/java03/</link>
      <pubDate>Wed, 22 Jan 2025 22:06:05 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/java03/</guid>
      <description>单元测试 单元测试：针对最小的功能单元编写测试代码
Java程序最小的功能单元是方法，对Java程序进行单元测试就是针对单个方法测试
测试驱动开发
先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码 举例子
public class Factorial { public static long fact(long n) { long r = 1; for (long i = 1; i &amp;lt;= n; i++) { r = r * i; } return r; } } 测试这方法，一个很自然的想法是编写一个main()方法，然后运行一些测试代码：
public class Test { public static void main(String[] args) { if (fact(10) == 3628800) { System.out.println(&amp;#34;pass&amp;#34;); } else { System.out.println(&amp;#34;fail&amp;#34;); } } } 只能有一个main()方法，不能把测试代码分离 是没有打印出测试结果和期望结果，例如，expected: 3628800, but actual: 123456 很难编写一组通用的测试代码 编写JUnit测试 JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计</description>
    </item>
    
    <item>
      <title>Java高级</title>
      <link>https://zwlzls.github.io/posts/java02/</link>
      <pubDate>Wed, 22 Jan 2025 22:06:01 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/java02/</guid>
      <description>异常处理 Java的异常 调用方获取调用失败的信息
约定返回错误码
处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码：
int code = processFile(&amp;#34;C:\\test.txt&amp;#34;); if (code == 0) { // ok: } else { // error: switch (code) { case 1: // file not found: case 2: // no read permission: default: // unknown error: } } 语言层面上提供一个异常处理机制、
try { String s = processFile(“C:\\test.txt”); // ok: } catch (FileNotFoundException e) { // file not found: } catch (SecurityException e) { // no read permission: } catch (IOException e) { // io error: } catch (Exception e) { // other error: } 异常是class，它的继承关系如下：</description>
    </item>
    
    <item>
      <title>Java中级</title>
      <link>https://zwlzls.github.io/posts/java01/</link>
      <pubDate>Wed, 22 Jan 2025 22:05:54 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/java01/</guid>
      <description>面向对象基础 理解： class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型
instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同
定义class
创建一个类，例如，给这个类命名为Person，就是定义一个class：
class Person { public String name; public int age; } class Book { public String name; public String author; public String isbn; public double price; } 创建实例
定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符
Person ming = new Person(); 区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例
ming.name = &amp;#34;Xiao Ming&amp;#34;; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = &amp;#34;Xiao Hong&amp;#34;; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：
┌──────────────────┐ ming ──────▶│Person instance │ ├──────────────────┤ │name = &amp;#34;Xiao Ming&amp;#34;│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────▶│Person instance │ ├──────────────────┤ │name = &amp;#34;Xiao Hong&amp;#34;│ │age = 15 │ └──────────────────┘ 方法 意义：</description>
    </item>
    
    <item>
      <title>Python高级</title>
      <link>https://zwlzls.github.io/posts/python02/</link>
      <pubDate>Fri, 17 Jan 2025 15:14:04 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/python02/</guid>
      <description>Python高级 面向对象编程 以一个例子来说明面向过程和面向对象在程序流程上的不同之处
假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：
std1 = { &amp;#39;name&amp;#39;: &amp;#39;Michael&amp;#39;, &amp;#39;score&amp;#39;: 98 } std2 = { &amp;#39;name&amp;#39;: &amp;#39;Bob&amp;#39;, &amp;#39;score&amp;#39;: 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩：
def print_score(std): print(&amp;#39;%s: %s&amp;#39; % (std[&amp;#39;name&amp;#39;], std[&amp;#39;score&amp;#39;])) 面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来
class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print(&amp;#39;%s: %s&amp;#39; % (self.name, self.score)) 给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：
bart = Student(&amp;#39;Bart Simpson&amp;#39;, 59) lisa = Student(&amp;#39;Lisa Simpson&amp;#39;, 87) bart.print_score() lisa.print_score() 类和实例 类是抽象的模板，实例是类创建的一个个具体的“对象”
和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数
定义类是通过class关键字：
class Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，没有合适的继承类，就使用object类，是所有类最终都会继承的类
由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：</description>
    </item>
    
    <item>
      <title>Python中级</title>
      <link>https://zwlzls.github.io/posts/python01/</link>
      <pubDate>Fri, 17 Jan 2025 15:13:58 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/python01/</guid>
      <description>Python中级使用 函数 调用函数 参数可以多个 &amp;gt;&amp;gt;&amp;gt; max(1, 2) 2 &amp;gt;&amp;gt;&amp;gt; max(2, 3, 1, -5) 3 参数类型需要一致 &amp;gt;&amp;gt;&amp;gt; abs(&amp;#39;a&amp;#39;) TypeError: bad operand type for abs(): &amp;#39;str&amp;#39; 函数调用 &amp;gt;&amp;gt;&amp;gt; abs(100) 100 &amp;gt;&amp;gt;&amp;gt; abs(-20) 20 数据类型转换
&amp;gt;&amp;gt;&amp;gt; int(&amp;#39;123&amp;#39;) 123 &amp;gt;&amp;gt;&amp;gt; int(12.34) 12 &amp;gt;&amp;gt;&amp;gt; float(&amp;#39;12.34&amp;#39;) 12.34 &amp;gt;&amp;gt;&amp;gt; str(1.23) &amp;#39;1.23&amp;#39; &amp;gt;&amp;gt;&amp;gt; str(100) &amp;#39;100&amp;#39; &amp;gt;&amp;gt;&amp;gt; bool(1) True &amp;gt;&amp;gt;&amp;gt; bool(&amp;#39;&amp;#39;) False 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量
&amp;gt;&amp;gt;&amp;gt; a = abs # 变量a指向abs函数 &amp;gt;&amp;gt;&amp;gt; a(-1) # 所以也可以通过a调用abs函数 1 定义函数 要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回
def my_abs(x): if x &amp;gt;= 0: return x else: return -x print(my_abs(-99)) 空函数：定义一个什么事也不做的空函数，可以用pass语句</description>
    </item>
    
    <item>
      <title>Git实战</title>
      <link>https://zwlzls.github.io/posts/git01/</link>
      <pubDate>Tue, 07 Jan 2025 23:41:00 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/git01/</guid>
      <description>Git使用 分布式工作流程 集中式工作流&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;单点协作
两个开发者从中心仓库克隆代码下来，同时作了一些修改，只有第一个开发者可以顺利地把数据推送回共享服务器。第二个开发者在推送修改之前，必须先将第一个人的工作合并进来，这样才不会覆盖第一个人的修改 集成管理工作流
项目维护者推送到主仓库。 贡献者克隆此仓库，做出修改。 贡献者将数据推送到自己的公开仓库。 贡献者给维护者发送邮件，请求拉取自己的更新。 维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。 维护者将合并后的修改推送到主仓库。 司令官与副官工作流&amp;mdash;&amp;mdash;-大型软件：Linux
普通开发者在自己的特性分支上工作，并根据 master 分支进行变基。 这里是司令官的master分支。
副官将普通开发者的特性分支合并到自己的 master 分支中。
司令官将所有副官的 master 分支并入自己的 master 分支中。
司令官将集成后的 master 分支推送到参考仓库中，以便所有其他开发者以此为基础进行变基。
向项目贡献 影响因素 ： 活跃贡献者的数量，项目的工作流程，提交权限
提交准则
git diff --check，它将会找到可能的空白错误并将它们为你列出来 空白错误是指行尾的空格、Tab 制表符，和行首空格后跟 Tab 制表符的行为 每一个提交成为一个逻辑上的独立变更集 不要一次提交解决好多问题 每个提交写清楚，让你的同事工作容易些 有一个优秀的提交信息 私有小团队
私有 ： 只有这几个开发者有仓库的推送权限 主采用SVN 区别：合并发生在客户端这边而不是在提交时发生在服务器那边 工作流程： 你通常在一个特性分支工作一会儿，当它准备好整合时合并回你的 master 分支。 当想要共享工作时，将其合并回你自己的 master 分支，如果有他人改动的话然后抓取并合并 origin/master，最终推送到服务器上的 master 分支 私有管理团队
公司使用了一种整合-管理者工作流程，独立小组的工作只能被特定的工程师整合，主仓库的 master 分支只能被那些工程师更新
所有的工作都是在基于团队的分支上完成的并且稍后会被整合者拉到一起
新建一个分支，与他人一起工作，可以加-u
也要注意 -u 标记；这是 --set-upstream 的简写，该标记会为之后轻松地推送与拉取配置分支</description>
    </item>
    
    <item>
      <title>Python基本</title>
      <link>https://zwlzls.github.io/posts/python00/</link>
      <pubDate>Tue, 07 Jan 2025 22:12:38 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/python00/</guid>
      <description>Python基础语法 Python基础 # print absolute value of an integer: a = 100 if a &amp;gt;= 0: print(a) else: print(-a) Python的语法比较简单 #开头的语句是注释
当语句以冒号:结尾时，缩进的语句视为代码块
缩进实用四个空格的缩进
议input
用input()读取用户的输入
birth = input(&amp;#39;birth: &amp;#39;) if birth &amp;lt; 2000: print(&amp;#39;00前&amp;#39;) TypeError: unorderable types: str() &amp;gt; int() 因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数
s = input(&amp;#39;birth: &amp;#39;) birth = int(s) if birth &amp;lt; 2000: print(&amp;#39;00前&amp;#39;) 可以得到正确地结果
议不可变对象：str是不变对象，list是可变对象
对于可变对象，比如list
&amp;gt;&amp;gt;&amp;gt; a = [&amp;#39;c&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;a&amp;#39;] &amp;gt;&amp;gt;&amp;gt; a.sort() &amp;gt;&amp;gt;&amp;gt; a [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;] 对于不可变对象，比如str</description>
    </item>
    
    <item>
      <title>Java基础</title>
      <link>https://zwlzls.github.io/posts/java00/</link>
      <pubDate>Tue, 07 Jan 2025 22:12:22 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/java00/</guid>
      <description>Java基础 程序流程 Java默认初始值与无默认区分
public class DefaultValuesExample { int instanceVar; // 默认值: 0 static int staticVar; // 默认值: 0 int[] array = new int[5]; // 数组元素默认值: 0 public void method() { int localVar; // 局部变量，必须显式初始化 // System.out.println(localVar); // 编译错误 } public static void main(String[] args) { DefaultValuesExample example = new DefaultValuesExample(); System.out.println(&amp;#34;Instance variable: &amp;#34; + example.instanceVar); System.out.println(&amp;#34;Static variable: &amp;#34; + staticVar); System.out.println(&amp;#34;Array element: &amp;#34; + example.array[0]); } } 局部变量必须有显式初始化
Java简易程序
public class Hello { public static void main(String[] args) { System.</description>
    </item>
    
    <item>
      <title>SQL语法</title>
      <link>https://zwlzls.github.io/posts/sql00/</link>
      <pubDate>Tue, 07 Jan 2025 22:12:09 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/sql00/</guid>
      <description>SQL基本使用 关系型数据库 数据库：保存用户数据
随着应用程序的功能越复杂，数据量越大，管理这些数据就成了大问题 读写文件并解析出数据需要大量重复代码； 从成千上万的数据中快速查询出指定数据需要复杂的逻辑 数据模型
层次模型：以“上下级”的层次关系来组织数据的一种方式，看起来就像一颗树 网状模型：每个数据节点和其他很多节点都连接起来，看起来就像很多城市之间的路网 关系模型：数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，看起来就是一个Excel表 常见数据类型
名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 SQL
结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还对数据库进行管理和维护操做 SQL语言关键字不区分大小写！！！但表名和列名不一定 MySQL本身只是一个SQL接口，内部包含多种数据引擎
InnoDB：一款支持事务的数据库引擎 MyISAM：MySQL早期默认数据库引擎，不支持事务 关系模型 表的每一行称为记录（Record），记录是一个逻辑意义上的数据。
表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。
主键
记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响 主键的一个基本原则：不使用任何业务相关的字段作为主键，也不应该允许NULL 一般字段命名为id ，常见类型有 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键 全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的 联合主键 通过多个字段唯一标识记录，即两个或更多的字段都设置为主键 外键
在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键
定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录
外键并不是通过列名实现的，而是通过定义外键约束实现的：</description>
    </item>
    
    <item>
      <title>Linux01(命令)</title>
      <link>https://zwlzls.github.io/posts/linux01/</link>
      <pubDate>Sun, 05 Jan 2025 15:10:55 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/linux01/</guid>
      <description>常用命令记录 帮助 man man cp 查看 cp 命令的帮助手册 man -f cp 查看 cp 命令的简要信息 man -w cp 查看 cp 命令帮助手册文件所在位置 man -k cp 搜索跟 cp 相关的帮助手册 whatis whatis cp 查询 cp 命令的功能 info：阅读info格式文件 info ls 查看ls命令的info文档 info -w ls 显示ls命令info文档的物理位置 磁盘与文件系统 du : 查看磁盘使用空间 du 列出当前目录下所有文件和目录的容量大小 du -h dir 以易读方式显示 dir 文件夹及其子文件夹大小 du -ah dir 以易读方式显示 dir 文件夹内所有文件大小 du f.txt 显示文件 f.txt 所占用的磁盘空间 du -s dir 仅显示目录的总大小 df : 显示磁盘空间使用情况 df 显示磁盘空间使用情况 df /home 显示指定文件/目录所在分区的磁盘使用情况 df -i 以 inode 模式来显示磁盘使用情况 inode ： 文件数据都储存在&amp;quot;块&amp;quot;中，还必须找到一个地方储存文件的元信息，储存文件元信息的区域就叫做inode，中文 “索引节点” sync : 强制将更改内容立刻写入磁盘 sync 所有挂载的文件系统的缓存数据写入磁盘 sync /path/to/file 同步指定文件的数据到磁盘 mount : 把文件系统过载到目录 mount 查看当前系统中挂载的所有文件系统信息 mount -t tmpfs 查看指定类型挂载的文件系统 sudo mount -o ro /dev/sdb/udisk 只读模式挂载 unmount : 卸载文件系统 umount -v /media/ALVIN/ 通过挂载点卸载 dd : 拷贝及转换文件(if=input file,of=output file,conv=conversion) dd if=/dev/one of=ﬁle.</description>
    </item>
    
    <item>
      <title>Git基本</title>
      <link>https://zwlzls.github.io/posts/git00/</link>
      <pubDate>Sun, 05 Jan 2025 15:03:12 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/git00/</guid>
      <description>git基本操作 由于学习更偏重点性记录或自己使用角度，深入度可能不足，详细见https://gitee.com/progit/index.html
安装及配置 ：Git · Pro Git 第二版 简体中文
起步 版本控制 ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统
本地版本控制
eg : RCS工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中版本控制 : 不同系统上的开发者协同工作
有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 优点 ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限 缺点 ： 中央服务器的单点故障，只有单独快照 分布式版本控制
客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来 git基础
Git 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容 计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 执行的 Git 操作，几乎只往 Git 数据库中增加数据 三种状态 已提交表示数据已经安全的保存在本地数据库中 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此 三个工作区 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方(github) 工作目录是对项目的某个版本独立提取出来的内容(本地仓库) 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作索引 基本Git工作流程 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 Git基础 获取Git仓库</description>
    </item>
    
    <item>
      <title>Linux介绍</title>
      <link>https://zwlzls.github.io/posts/linux00/</link>
      <pubDate>Sun, 05 Jan 2025 14:51:29 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/linux00/</guid>
      <description>Linux00 磁盘与目录树结构 linux 下所有的数据都是以文件的形态来呈现的，所以最重要的就是目录树架构 挂载 就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下 文件权限与目录配置 Linux 最优秀的就是多人任务，文件权限就很重要，将文件的可存取身份分为： owner、group、ohters，且都有 read、write、execute 等权限。
Linux系统里面账户，密码，群组目录
/etc/passwd：账户信息 /etc/shadow：账户密码，不过是加密了的 /etc/group：所有组名 </description>
    </item>
    
  </channel>
</rss>
