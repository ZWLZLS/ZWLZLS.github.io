<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 我的博客</title>
    <link>https://zwlzls.github.io/posts/</link>
    <description>Recent content in Posts on 我的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 10 Feb 2025 15:11:19 +0800</lastBuildDate><atom:link href="https://zwlzls.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Redis01</title>
      <link>https://zwlzls.github.io/posts/redis01/</link>
      <pubDate>Mon, 10 Feb 2025 15:11:19 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/redis01/</guid>
      <description>持久化 AOF 文件的内容是操作命令； RDB 文件的内容是二进制数据 AOF Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 redis.conf
Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里
这保存写操作命令到日志的持久化方式，是 Redis 里的 AOF(Append Only File) 持久化功能，注意只会记录写操作命令，读操作命令是不会被记录的
Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的
避免额外的检查开销 不会阻塞当前写操作命令的执行，因为当写操作命令执行成功后，才会将命令记录到 AOF 日志 风险：
执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险 写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是可能会给「下一个」命令带来阻塞风险 执行过程：
Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区； 通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘； 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定 写回硬盘策略： Always，「总是」，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘； Everysec，「每秒」，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，每隔一秒将缓冲区里的内容写回到硬盘； No，不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘 AOF重写机制
AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大 Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制 机制是在重写时，读取当前数据库中的所有键值对，将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件 妙处在于：尽管某个键值对被多条写命令反复修改，最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对 AOF后台重写</description>
    </item>
    
    <item>
      <title>Redis00</title>
      <link>https://zwlzls.github.io/posts/redis00/</link>
      <pubDate>Mon, 10 Feb 2025 15:11:14 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/redis00/</guid>
      <description>数据类型及应用 https://onecompiler.com/redis可以进行实践
String String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值
数据结构实现主要是int和SDS
SDS 不仅可以保存文本数据，还可以保存二进制数据 因为 SDS 使用 len 属性的值判断字符串是否结束 SDS 获取字符串长度的时间复杂度是 O(1) SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1) Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容 常用指令
# 设置 key-value 类型的值 &amp;gt; SET name lin OK # 根据 key 获得对应的 value &amp;gt; GET name &amp;#34;lin&amp;#34; # 判断某个 key 是否存在 &amp;gt; EXISTS name (integer) 1 # 返回 key 所储存的字符串值的长度 &amp;gt; STRLEN name (integer) 3 # 删除某个 key 对应的值 &amp;gt; DEL name (integer) 1 批量设置 :</description>
    </item>
    
    <item>
      <title>Mysql01</title>
      <link>https://zwlzls.github.io/posts/mysql01/</link>
      <pubDate>Mon, 10 Feb 2025 15:10:54 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/mysql01/</guid>
      <description>事务 事务是由 MySQL 的引擎来实现，常见的 InnoDB 引擎它是支持事务的 并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务
特性 具体特性
原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节；事务在执行过程中发生错误，会被回滚到事务开始前的状态 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态 隔离性：允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失 如何保证特性？
持久性是通过 redo log （重做日志）来保证的 原子性是通过 undo log（回滚日志） 来保证的 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的 一致性则是通过持久性+原子性+隔离性来保证 隔离级别 MySQL服务端允许多个客户端连接，意味着 MySQL 会出现同时处理多个事务的情况 问题： 脏读：如果一个事务「读到」了另一个「未提交事务修改过的数据」 事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，被读 不可重复读：一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况 事务A两次读取过程中，事务B进行修改且提交 幻读：一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况 事务A两次读取过程中，事务B进行修改且提交 隔离级别 读未提交：一个事务还没提交时，它做的变更就能被其他事务看到 读提交：一个事务提交之后，它做的变更才能被其他事务看到 可重复读：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别 串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行 「可重复读」但是很大程度上避免幻读现象 针对快照读（普通 select 语句），通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的 针对当前读（select &amp;hellip; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，当执行 select &amp;hellip; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那这个插入语句就会被阻塞，无法成功插入 四种隔级别实现 「读未提交」可以读到未提交事务修改的数据，所以直接读取最新的数据就好 「串行化」通过加读写锁的方式来避免并行访问； 「读提交」和「可重复读」通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View 执行「开始事务」begin/start transaction 命令 执行了 begin/start transaction 命令后，并不代表事务启动了 只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机 Read View在MVCC工作 Read View 有四个重要的字段： m_ids ：在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务 min_trx_id ：在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值 max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，就是全局事务中最大的事务 id 值 + 1 creator_trx_id ：创建该 Read View 的事务的事务 id InnoDB 存储引擎的数据库表，聚簇索引记录中包含下面两个隐藏列： trx_id：一个事务对某条聚簇索引记录进行改动时，会把该事务的事务 id 记录在 trx_id 隐藏列里 roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录 通过「版本链」控制并发事务访问同一个记录时的行为叫 MVCC（多版本并发控制） 可重复读和读提交如何工作 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View 读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View 日志 undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC</description>
    </item>
    
    <item>
      <title>Mysql00</title>
      <link>https://zwlzls.github.io/posts/mysql00/</link>
      <pubDate>Mon, 10 Feb 2025 15:10:24 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/mysql00/</guid>
      <description>MySQL查询过程 MySQL 的架构共分为两层：Server 层和存储引擎层
Server 层负责建立连接、分析和执行 SQL。主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现 存储引擎层负责数据的存储和提取。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。索引数据结构就是由存储引擎层实现，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引 第一步：连接器 启动Mysql服务，连接 MySQL 服务
# -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数； # -u 指定用户名，管理员角色名为 root； # -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码 mysql -h$ip -u$user -p 查看 MySQL 服务被多少客户端连接
执行 show processlist 命令进行查看
MySQL 定义空闲连接的最大空闲时长，由 wait_timeout 参数控制的，如果空闲连接超过了这个时间，连接器就会自动将它断开
mysql&amp;gt; show variables like &amp;#39;wait_timeout&amp;#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | wait_timeout | 28800 | +---------------+-------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title>OS01</title>
      <link>https://zwlzls.github.io/posts/os01/</link>
      <pubDate>Mon, 10 Feb 2025 15:10:02 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/os01/</guid>
      <description>调度算法 进程调度 总论 当CPU空闲，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU 什么时候会发生 CPU 调度 当进程从运行状态转到等待状态 当进程从运行状态转到就绪状态 当进程从等待状态转到就绪状态 当进程从运行状态转到终止状态 其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」， 2 和 3 两种情况下发生的调度称为「抢占式调度」 非抢占式：当进程正在运行时，会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程 抢占式：进程正在运行的时，可以被打断，使其把 CPU 让给其他进程 先来先服务调度 先来后到，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行 对长作业有利，适用 CPU 繁忙型作业的系统，而不适用 I/O 繁忙型作业的系统 最短作业优先调度 会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量 显然对长作业不利，很容易造成一种极端现象 高响应比优先调度 每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行 时间片轮转调度 每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行 最高优先级调度 对多用户计算机系统就有不同的看法，它们希望调度是有优先级的，即希望调度程序能从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级调度 优先级可分为： 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化 动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，就随着时间的推移增加等待进程的优先级 多级反馈队列调度 「时间片轮转算法」和「最高优先级算法」的综合和发展 「多级」有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。 「反馈」如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列； 内存页面置换 缺页异常（缺页中断）
当 CPU 访问的页面不在物理内存，便产生一个缺页中断，请求操作系统将所缺页调入到物理内存。与一般中断区别在于： 缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号 缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行 页面置换算法：当出现缺页异常，需调入新页面但内存已满，选择被置换的物理页面，也就选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页 最佳页面置换
置换在「未来」最长时间不访问的页面，但无法实现 先进先出置换
选择在内存驻留时间很长的页面进行中置换，就是「先进先出置换」算法的思想 最近最久未使用置换
发生缺页时，选择最长时间没有被访问的页面进行置换，假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用 时钟页面置换
把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面
缺页中断时，首先检查表针指向的页面：
如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置； 如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止 网络 I/O多路复用 服务用户数量</description>
    </item>
    
    <item>
      <title>OS00</title>
      <link>https://zwlzls.github.io/posts/os00/</link>
      <pubDate>Mon, 10 Feb 2025 15:09:56 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/os00/</guid>
      <description>总论 现代操作系统，内核一般会提供 4 个基本能力： 管理进程、线程，决定哪个进程、线程使用 CPU，也是进程调度的能力； 管理内存，决定内存的分配和回收，也是内存管理的能力； 管理硬件设备，为进程与硬件设备之间提供通信能力，也是硬件通信能力； 提供系统调用，如果应用程序要运行更高权限运行的服务，就需要有系统调用，是用户程序与操作系统之间的接口 内核具有很高的权限，可控制 cpu、内存、硬盘等硬件，而应用程序具有的权限很小。 因此大多数操作系统，把内存分成了两个区域 内核空间：这个内存空间只有内核程序可以访问 用户空间：这个内存空间专门给应用程序使用 用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间 当程序使用用户空间时，我们常说该程序在用户态执行 当程序使内核空间时，程序则在内核态执行 应用程序如果需要进入内核空间，就需要通过系统调用 内核程序执行在内核态，用户程序执行在用户态 应用程序使用系统调用时，会产生一个中断。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序（开始执行内核程序） 内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作 现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响 内存管理 虚拟内存 单片机的 CPU 是直接操作内存的「物理地址」 想在内存中同时运行两个程序是不可能的。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的 解决方法？ 把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，大家自己玩自己的地址就行，互不干涉 有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的 理解：之所以不能同时运行，就是因为两个程序引用相同物理地址，也就是不能让其使用相同的物理地址，加一层映射过去 操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来 程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了 引出两种地址概念： 我们程序所使用的内存地址叫做虚拟内存地址 实际存在硬件里面的空间地址叫物理内存地址 操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存 虚拟内存作用： 第一，虚拟内存使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域 理解：加载一个很大的存储，原本只能一次性，现在可分按需批 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性 内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来 分段机制下，虚拟地址的物理地址的映射 分段机制下的虚拟地址由两部分：段选择因子和段内偏移量 段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。 虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址 虚拟地址是通过段表与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址 问题： 第一个是内存碎片 内存分段管理可以做到段根据实际需求分配内存，有多少需求就分配多大的段，所以不会出现内部内存碎片，但是由于每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以会出现外部内存碎片 解决「外部内存碎片」的是内存交换 内存交换空间，在Linux中，是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换 第二个是内存交换的效率低 如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿 内存分页 分段的好处就是能产生连续的内存空间 但会出现「外部内存碎片和内存交换的空间太大」的问题 解决这些问题，那么就要想出能少出现一些内存碎片的办法 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小，这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB 虚拟地址与物理地址之间通过页表来映射 页表存储在内存里，内存管理单元 （MMU）将虚拟内存地址转换成物理地址工作 当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行 解决分段问题 内存分页由于内存空间都是预先划分好的，采用了分页，页与页之间是紧密排列的，所以不会有外部碎片 内存分页机制分配内存的最小单位是一页，即程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对内存分页机制会有内部内存碎片 内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高 分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中，只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去 分页机制，虚拟地址与物理地址的映射 分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址 总结一下，对于一个内存地址转换，就是这样三个步骤： 把虚拟内存地址，切分成页号和偏移量； 根据页号，从页表里面，查询对应的物理页号； 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址 缺陷： 操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大 在 32 位的环境，虚拟地址空间共 4GB，假设一个页大小是 4KB（2^12），就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节(4B)来存储，那整个 4GB 空间的映射就需要 4MB 的内存来存储页表 100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存 多级页表 解决分页的缺陷 把这 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 1024 页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页 算机组成原理里面无处不在的局部性原理 每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存 一级页表就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表 深入理解思想： 从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址 页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项 此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建 TLB 多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，带来了时间上的开销 程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域 最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB 有TLB 后，那么 CPU 在寻址时，先查 TLB，如果没找到，才会继续查常规的页表 TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个 段页式内存管理 内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为段页式内存管理 段页式内存管理实现方式： 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制 再把每个段划分为多个页，也就对分段划分出来的连续空间，再划分固定大小的页 这样，地址结构就由段号、段内页号和页内位移三部分组成 段页式地址变换中要得到物理地址须经过三次内存访问： 第一次访问段表，得到页表起始地址； 第二次访问页表，得到物理页号； 第三次将物理页号与页内位移组合，得到物理地址 Linux内存结构 Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护 Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制 每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存 分配内存 应用程序通过 申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存</description>
    </item>
    
    <item>
      <title>Network01</title>
      <link>https://zwlzls.github.io/posts/network01/</link>
      <pubDate>Mon, 10 Feb 2025 15:09:41 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/network01/</guid>
      <description></description>
    </item>
    
    <item>
      <title>网络基础</title>
      <link>https://zwlzls.github.io/posts/network00/</link>
      <pubDate>Mon, 10 Feb 2025 15:09:37 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/network00/</guid>
      <description>网络模型 同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式
不同设备上的进程间通信，需要网络通信，而设备是多样性的，协商出了一套通用的网络协议
TCP/IP网络模型 应用层 最上层的，也是我们能直接接触到的，应用就把应用数据传给下一层，就是传输层 应用层为用户提供应用功能，比如 HTTP、FTP等 传输层 传输层会有两个传输协议，分别是 TCP 和 UDP TCP：大部分应用使用的正是 TCP 传输层协议，比如HTTP。TCP有流量控制、超时重传、拥塞控制等，为保证数据包能可靠地传输给对方 UDP：只负责发送数据包，不保证数据包是否能抵达对方，它实时性相对更好，传输效率也高 应用需要传输的数据可能会非常大，当传输层的数据包大小超过 MSS(TCP 最大报文段长度)，将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块 MTU：一个网络包最大长度，以太网中一般为 1500 字节。 MSS：除去 IP 和 TCP 头部后，一个网络包所能容纳的 TCP 数据的最大长度。 传输层负责把数据包传给应用，但一台设备上会有很多应用接收或者传输数据，用编号将应用区分开来，这个编号是端口 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的 对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号 网络层 传输层协议处理太多的事情，只需要服务好应用即可；而实际的传输功能就交给下一层，也就网络层，负责将数据从一个设备传输到另一个设备 IP 协议将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文；如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文 IP 地址给设备进行编号 IPv4 协议, IP 地址共 32 位，分成了四段（比如192.168.100.1），每段是8位 将 IP 地址分成两种意义： 网络号，负责标识该 IP 地址是属于哪个「子网」的； 主机号，负责标识同一「子网」下的不同主机 配合子网掩码才能算出 IP 地址 的网络号和主机号 比如 10.</description>
    </item>
    
    <item>
      <title>Java细知识</title>
      <link>https://zwlzls.github.io/posts/java03/</link>
      <pubDate>Wed, 22 Jan 2025 22:06:05 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/java03/</guid>
      <description>单元测试 单元测试：针对最小的功能单元编写测试代码
Java程序最小的功能单元是方法，对Java程序进行单元测试就是针对单个方法测试
测试驱动开发
先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码 举例子
public class Factorial { public static long fact(long n) { long r = 1; for (long i = 1; i &amp;lt;= n; i++) { r = r * i; } return r; } } 测试这方法，一个很自然的想法是编写一个main()方法，然后运行一些测试代码：
public class Test { public static void main(String[] args) { if (fact(10) == 3628800) { System.out.println(&amp;#34;pass&amp;#34;); } else { System.out.println(&amp;#34;fail&amp;#34;); } } } 只能有一个main()方法，不能把测试代码分离 是没有打印出测试结果和期望结果，例如，expected: 3628800, but actual: 123456 很难编写一组通用的测试代码 编写JUnit测试 JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计</description>
    </item>
    
    <item>
      <title>Java高级</title>
      <link>https://zwlzls.github.io/posts/java02/</link>
      <pubDate>Wed, 22 Jan 2025 22:06:01 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/java02/</guid>
      <description>异常处理 Java的异常 调用方获取调用失败的信息
约定返回错误码
处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码：
int code = processFile(&amp;#34;C:\\test.txt&amp;#34;); if (code == 0) { // ok: } else { // error: switch (code) { case 1: // file not found: case 2: // no read permission: default: // unknown error: } } 语言层面上提供一个异常处理机制、
try { String s = processFile(“C:\\test.txt”); // ok: } catch (FileNotFoundException e) { // file not found: } catch (SecurityException e) { // no read permission: } catch (IOException e) { // io error: } catch (Exception e) { // other error: } 异常是class，它的继承关系如下：</description>
    </item>
    
    <item>
      <title>Java中级</title>
      <link>https://zwlzls.github.io/posts/java01/</link>
      <pubDate>Wed, 22 Jan 2025 22:05:54 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/java01/</guid>
      <description>面向对象基础 理解： class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型
instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同
定义class
创建一个类，例如，给这个类命名为Person，就是定义一个class：
class Person { public String name; public int age; } class Book { public String name; public String author; public String isbn; public double price; } 创建实例
定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符
Person ming = new Person(); 区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例
ming.name = &amp;#34;Xiao Ming&amp;#34;; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = &amp;#34;Xiao Hong&amp;#34;; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：
┌──────────────────┐ ming ──────▶│Person instance │ ├──────────────────┤ │name = &amp;#34;Xiao Ming&amp;#34;│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────▶│Person instance │ ├──────────────────┤ │name = &amp;#34;Xiao Hong&amp;#34;│ │age = 15 │ └──────────────────┘ 方法 意义：</description>
    </item>
    
    <item>
      <title>Python高级</title>
      <link>https://zwlzls.github.io/posts/python02/</link>
      <pubDate>Fri, 17 Jan 2025 15:14:04 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/python02/</guid>
      <description>Python高级 面向对象编程 以一个例子来说明面向过程和面向对象在程序流程上的不同之处
假设我们要处理学生的成绩表，表示学生的成绩，面向过程的程序可以用dict表示：
std1 = { &amp;#39;name&amp;#39;: &amp;#39;Michael&amp;#39;, &amp;#39;score&amp;#39;: 98 } std2 = { &amp;#39;name&amp;#39;: &amp;#39;Bob&amp;#39;, &amp;#39;score&amp;#39;: 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩：
def print_score(std): print(&amp;#39;%s: %s&amp;#39; % (std[&amp;#39;name&amp;#39;], std[&amp;#39;score&amp;#39;])) 面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来
class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print(&amp;#39;%s: %s&amp;#39; % (self.name, self.score)) 给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：
bart = Student(&amp;#39;Bart Simpson&amp;#39;, 59) lisa = Student(&amp;#39;Lisa Simpson&amp;#39;, 87) bart.print_score() lisa.print_score() 类和实例 类是抽象的模板，实例是类创建的一个个具体的“对象”
和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数
定义类是通过class关键字：
class Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，没有合适的继承类，就使用object类，是所有类最终都会继承的类
由于类可以起到模板的作用，因此，在创建实例的时候，把我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：</description>
    </item>
    
    <item>
      <title>Python中级</title>
      <link>https://zwlzls.github.io/posts/python01/</link>
      <pubDate>Fri, 17 Jan 2025 15:13:58 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/python01/</guid>
      <description>Python中级使用 函数 调用函数 参数可以多个 &amp;gt;&amp;gt;&amp;gt; max(1, 2) 2 &amp;gt;&amp;gt;&amp;gt; max(2, 3, 1, -5) 3 参数类型需要一致 &amp;gt;&amp;gt;&amp;gt; abs(&amp;#39;a&amp;#39;) TypeError: bad operand type for abs(): &amp;#39;str&amp;#39; 函数调用 &amp;gt;&amp;gt;&amp;gt; abs(100) 100 &amp;gt;&amp;gt;&amp;gt; abs(-20) 20 数据类型转换
&amp;gt;&amp;gt;&amp;gt; int(&amp;#39;123&amp;#39;) 123 &amp;gt;&amp;gt;&amp;gt; int(12.34) 12 &amp;gt;&amp;gt;&amp;gt; float(&amp;#39;12.34&amp;#39;) 12.34 &amp;gt;&amp;gt;&amp;gt; str(1.23) &amp;#39;1.23&amp;#39; &amp;gt;&amp;gt;&amp;gt; str(100) &amp;#39;100&amp;#39; &amp;gt;&amp;gt;&amp;gt; bool(1) True &amp;gt;&amp;gt;&amp;gt; bool(&amp;#39;&amp;#39;) False 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量
&amp;gt;&amp;gt;&amp;gt; a = abs # 变量a指向abs函数 &amp;gt;&amp;gt;&amp;gt; a(-1) # 所以也可以通过a调用abs函数 1 定义函数 要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回
def my_abs(x): if x &amp;gt;= 0: return x else: return -x print(my_abs(-99)) 空函数：定义一个什么事也不做的空函数，可以用pass语句</description>
    </item>
    
    <item>
      <title>Git01</title>
      <link>https://zwlzls.github.io/posts/git01/</link>
      <pubDate>Tue, 07 Jan 2025 23:41:00 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/git01/</guid>
      <description>Git使用 分布式工作流程 集中式工作流&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;单点协作
两个开发者从中心仓库克隆代码下来，同时作了一些修改，只有第一个开发者可以顺利地把数据推送回共享服务器。第二个开发者在推送修改之前，必须先将第一个人的工作合并进来，这样才不会覆盖第一个人的修改 集成管理工作流
项目维护者推送到主仓库。 贡献者克隆此仓库，做出修改。 贡献者将数据推送到自己的公开仓库。 贡献者给维护者发送邮件，请求拉取自己的更新。 维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。 维护者将合并后的修改推送到主仓库。 司令官与副官工作流&amp;mdash;&amp;mdash;-大型软件：Linux
普通开发者在自己的特性分支上工作，并根据 master 分支进行变基。 这里是司令官的master分支。
副官将普通开发者的特性分支合并到自己的 master 分支中。
司令官将所有副官的 master 分支并入自己的 master 分支中。
司令官将集成后的 master 分支推送到参考仓库中，以便所有其他开发者以此为基础进行变基。
向项目贡献 影响因素 ： 活跃贡献者的数量，项目的工作流程，提交权限
提交准则
git diff --check，它将会找到可能的空白错误并将它们为你列出来 空白错误是指行尾的空格、Tab 制表符，和行首空格后跟 Tab 制表符的行为 每一个提交成为一个逻辑上的独立变更集 不要一次提交解决好多问题 每个提交写清楚，让你的同事工作容易些 有一个优秀的提交信息 私有小团队
私有 ： 只有这几个开发者有仓库的推送权限 主采用SVN 区别：合并发生在客户端这边而不是在提交时发生在服务器那边 工作流程： 你通常在一个特性分支工作一会儿，当它准备好整合时合并回你的 master 分支。 当想要共享工作时，将其合并回你自己的 master 分支，如果有他人改动的话然后抓取并合并 origin/master，最终推送到服务器上的 master 分支 私有管理团队
公司使用了一种整合-管理者工作流程，独立小组的工作只能被特定的工程师整合，主仓库的 master 分支只能被那些工程师更新
所有的工作都是在基于团队的分支上完成的并且稍后会被整合者拉到一起
新建一个分支，与他人一起工作，可以加-u
也要注意 -u 标记；这是 --set-upstream 的简写，该标记会为之后轻松地推送与拉取配置分支</description>
    </item>
    
    <item>
      <title>Python基本</title>
      <link>https://zwlzls.github.io/posts/python00/</link>
      <pubDate>Tue, 07 Jan 2025 22:12:38 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/python00/</guid>
      <description>Python基础语法 Python基础 # print absolute value of an integer: a = 100 if a &amp;gt;= 0: print(a) else: print(-a) Python的语法比较简单 #开头的语句是注释
当语句以冒号:结尾时，缩进的语句视为代码块
缩进实用四个空格的缩进
议input
用input()读取用户的输入
birth = input(&amp;#39;birth: &amp;#39;) if birth &amp;lt; 2000: print(&amp;#39;00前&amp;#39;) TypeError: unorderable types: str() &amp;gt; int() 因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数
s = input(&amp;#39;birth: &amp;#39;) birth = int(s) if birth &amp;lt; 2000: print(&amp;#39;00前&amp;#39;) 可以得到正确地结果
议不可变对象：str是不变对象，list是可变对象
对于可变对象，比如list
&amp;gt;&amp;gt;&amp;gt; a = [&amp;#39;c&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;a&amp;#39;] &amp;gt;&amp;gt;&amp;gt; a.sort() &amp;gt;&amp;gt;&amp;gt; a [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;] 对于不可变对象，比如str</description>
    </item>
    
    <item>
      <title>Java00</title>
      <link>https://zwlzls.github.io/posts/java00/</link>
      <pubDate>Tue, 07 Jan 2025 22:12:22 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/java00/</guid>
      <description>Java基础 程序流程 Java默认初始值与无默认区分
public class DefaultValuesExample { int instanceVar; // 默认值: 0 static int staticVar; // 默认值: 0 int[] array = new int[5]; // 数组元素默认值: 0 public void method() { int localVar; // 局部变量，必须显式初始化 // System.out.println(localVar); // 编译错误 } public static void main(String[] args) { DefaultValuesExample example = new DefaultValuesExample(); System.out.println(&amp;#34;Instance variable: &amp;#34; + example.instanceVar); System.out.println(&amp;#34;Static variable: &amp;#34; + staticVar); System.out.println(&amp;#34;Array element: &amp;#34; + example.array[0]); } } 局部变量必须有显式初始化
Java简易程序
public class Hello { public static void main(String[] args) { System.</description>
    </item>
    
    <item>
      <title>SQL语法</title>
      <link>https://zwlzls.github.io/posts/sql00/</link>
      <pubDate>Tue, 07 Jan 2025 22:12:09 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/sql00/</guid>
      <description>SQL基本使用 关系型数据库 数据库：保存用户数据
随着应用程序的功能越复杂，数据量越大，管理这些数据就成了大问题 读写文件并解析出数据需要大量重复代码； 从成千上万的数据中快速查询出指定数据需要复杂的逻辑 数据模型
层次模型：以“上下级”的层次关系来组织数据的一种方式，看起来就像一颗树 网状模型：每个数据节点和其他很多节点都连接起来，看起来就像很多城市之间的路网 关系模型：数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，看起来就是一个Excel表 常见数据类型
名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 SQL
结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还对数据库进行管理和维护操做 SQL语言关键字不区分大小写！！！但表名和列名不一定 MySQL本身只是一个SQL接口，内部包含多种数据引擎
InnoDB：一款支持事务的数据库引擎 MyISAM：MySQL早期默认数据库引擎，不支持事务 关系模型 表的每一行称为记录（Record），记录是一个逻辑意义上的数据。
表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。
主键
记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响 主键的一个基本原则：不使用任何业务相关的字段作为主键，也不应该允许NULL 一般字段命名为id ，常见类型有 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键 全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的 联合主键 通过多个字段唯一标识记录，即两个或更多的字段都设置为主键 外键
在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键
定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录
外键并不是通过列名实现的，而是通过定义外键约束实现的：</description>
    </item>
    
    <item>
      <title>Linux01(命令)</title>
      <link>https://zwlzls.github.io/posts/linux01/</link>
      <pubDate>Sun, 05 Jan 2025 15:10:55 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/linux01/</guid>
      <description>常用命令记录 帮助 man man cp 查看 cp 命令的帮助手册 man -f cp 查看 cp 命令的简要信息 man -w cp 查看 cp 命令帮助手册文件所在位置 man -k cp 搜索跟 cp 相关的帮助手册 whatis whatis cp 查询 cp 命令的功能 info：阅读info格式文件 info ls 查看ls命令的info文档 info -w ls 显示ls命令info文档的物理位置 磁盘与文件系统 du : 查看磁盘使用空间 du 列出当前目录下所有文件和目录的容量大小 du -h dir 以易读方式显示 dir 文件夹及其子文件夹大小 du -ah dir 以易读方式显示 dir 文件夹内所有文件大小 du f.txt 显示文件 f.txt 所占用的磁盘空间 du -s dir 仅显示目录的总大小 df : 显示磁盘空间使用情况 df 显示磁盘空间使用情况 df /home 显示指定文件/目录所在分区的磁盘使用情况 df -i 以 inode 模式来显示磁盘使用情况 inode ： 文件数据都储存在&amp;quot;块&amp;quot;中，还必须找到一个地方储存文件的元信息，储存文件元信息的区域就叫做inode，中文 “索引节点” sync : 强制将更改内容立刻写入磁盘 sync 所有挂载的文件系统的缓存数据写入磁盘 sync /path/to/file 同步指定文件的数据到磁盘 mount : 把文件系统过载到目录 mount 查看当前系统中挂载的所有文件系统信息 mount -t tmpfs 查看指定类型挂载的文件系统 sudo mount -o ro /dev/sdb/udisk 只读模式挂载 unmount : 卸载文件系统 umount -v /media/ALVIN/ 通过挂载点卸载 dd : 拷贝及转换文件(if=input file,of=output file,conv=conversion) dd if=/dev/one of=ﬁle.</description>
    </item>
    
    <item>
      <title>Git00</title>
      <link>https://zwlzls.github.io/posts/git00/</link>
      <pubDate>Sun, 05 Jan 2025 15:03:12 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/git00/</guid>
      <description>git基本操作 由于学习更偏重点性记录或自己使用角度，深入度可能不足，详细见https://gitee.com/progit/index.html
安装及配置 ：Git · Pro Git 第二版 简体中文
起步 版本控制 ： 记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统
本地版本控制
eg : RCS工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中版本控制 : 不同系统上的开发者协同工作
有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 优点 ： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限 缺点 ： 中央服务器的单点故障，只有单独快照 分布式版本控制
客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来 git基础
Git 是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，主要对当时的全部文件制作一个快照并保存这个快照的索引。 如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容 计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名 执行的 Git 操作，几乎只往 Git 数据库中增加数据 三种状态 已提交表示数据已经安全的保存在本地数据库中 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此 三个工作区 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方(github) 工作目录是对项目的某个版本独立提取出来的内容(本地仓库) 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。称作索引 基本Git工作流程 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 Git基础 获取Git仓库</description>
    </item>
    
    <item>
      <title>Linux00</title>
      <link>https://zwlzls.github.io/posts/linux00/</link>
      <pubDate>Sun, 05 Jan 2025 14:51:29 +0800</pubDate>
      
      <guid>https://zwlzls.github.io/posts/linux00/</guid>
      <description>Linux00 磁盘与目录树结构 linux 下所有的数据都是以文件的形态来呈现的，所以最重要的就是目录树架构 挂载 就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下 文件权限与目录配置 Linux 最优秀的就是多人任务，文件权限就很重要，将文件的可存取身份分为： owner、group、ohters，且都有 read、write、execute 等权限。
Linux系统里面账户，密码，群组目录
/etc/passwd：账户信息 /etc/shadow：账户密码，不过是加密了的 /etc/group：所有组名 </description>
    </item>
    
  </channel>
</rss>
