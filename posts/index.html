<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 我的博客</title>
<meta name=keywords content><meta name=description content="Posts - 我的博客"><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/><link crossorigin=anonymous href=../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate type=application/rss+xml href=https://zwlzls.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://zwlzls.github.io/posts/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>Hot100</h2></header><section class=entry-content><p>Hot100 贪心算法 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0
class Solution { public int maxProfit(int[] prices) { if(prices.length==0){ return 0; } int max=0,len=prices.length; int pre=prices[0]; for(int p:prices){ if(p&lt;pre){ pre=p; } max=Math.max(max,p-pre); } return max; } } 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false
class Solution { public boolean canJump(int[] nums) { int n = nums.length; int farthest = 0; for (int i = 0; i &lt; n - 1; i++) { // 不断计算能跳到的最远距离 farthest = Math....</p></section><a class=entry-link aria-label="post link to Hot100" href=https://zwlzls.github.io/posts/algorithm05/></a></article><article class=post-entry><header class=entry-header><h2>Efficiency02</h2></header><section class=entry-content><p></p></section><a class=entry-link aria-label="post link to Efficiency02" href=https://zwlzls.github.io/posts/efficiency02/></a></article><article class=post-entry><header class=entry-header><h2>Efficiency01</h2></header><section class=entry-content><p></p></section><a class=entry-link aria-label="post link to Efficiency01" href=https://zwlzls.github.io/posts/efficiency01/></a></article><article class=post-entry><header class=entry-header><h2>《软件研发效能提升之美00》</h2></header><section class=entry-content><p>内容《软件研发效能提升之美》之书 总论 研发效能是多⼈组织协同效率的课题，在现代基础设施、架构理论和AI算法的加持下，研发效能的内容也从敏捷方法论快速进化到非常具体的⼯具、流程和指标系统 研发效能定义：在保证质量的前提下，尽可能⾼效地持续交付价值。为此，我们重新审视 整个软件⽣产流程（需求、设计、开发、测试、部署、发布、运营），在不增加成本和保证质量的前提下，提升各个步骤的标准化、⾃动化、系统化和⼀致性⽔平，并不断优化团队的交付效率 **没有银弹：**没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍 希望软件研发能够成为⼀个技术密集型产业，⽽不是劳动密集型产业 概述 研发效能提升案例
前端代码的自动生成
我们手绘出GUI界⾯的草稿；通过Sketch2Code可以直接将这份草稿转换成目标平台的代码，如果我们指定的目标平台是Web，那么代码格式就是HTML，如果我们指定的目标平台是iOS，那么代码就以XCode项目的形式呈现；最后，完成编译打包，可直接在iPhone上安装执⾏了。
这种方式的引入将大幅提升原型构建环节的效率
临界参数下的API测试
考虑引⼊⼀种机制，通过⼯具或脚本去主动检测API输入参数的类型，根据不同的类型⽣成相应的容易出错的临界值，我们⽤这些临界值作为测试数据去⾃动调⽤API。如果API返回预期外的异常或错误（如HTTP-500错误），那就说明这个API没有妥善处理我们传⼊的临界值
进⼀步的，我们可以将这个机制与CI流水线集成，在CI执行走过程中主动执⾏临界参数下的API测试，以求问题更早地被暴露
例如：当⼯具或脚本识别到某API的输⼊参数是String类型的时候，就可以⽣成NULL、超⻓的字符串、包含⾮英语字符的字符串、SQL注⼊字符串等⼀系列临界值，将其作为测试数据去检测程序潜在的问题
基于流程优化的效能提升
效率的提升既可以由技术来驱动，也可以由流程来驱动，流程要整体方便 第一性原理：顺畅、高质量地持续交付有效价值的闭环
顺畅：价值的流动过程必须顺畅，没有阻碍 高质量：如果质量不行，那么流动越快，死得也会越快 **持续：**不能时断时续，小步快跑才是正道 **有效价值：**这是从需求层⾯来说的，你的交付物是不是真正解决了用户的本质问题 **闭环：**强调快速反馈的重要性 鹅生金蛋的故事。是不是鹅生的金蛋越多，效能就越高呢？其实不是，⼀味地让 鹅全日无休地生金蛋，早晚会把鹅累死，这不是可持续的长远战略。真正的效能应该是让鹅生鹅，鹅再生鹅，让更多的鹅⼀起来下金蛋 从软件开发、测试和发布的视角来看⼀下各个阶段研发效能提升需要关注的问题，其主线是围绕CI/CD的⼀些实践
举例：选择合适的发布策略也会对效能和风险之间的平衡起到积极的作⽤
架构相对简单，但是集群规模庞大，则优选金丝雀 架构⽐较复杂，但是集群规模不是太大，可能蓝绿发布更占优势 研发效能这个领域，要保证我们所做的研发效能工具⼀定是能解决实际问题的
研发效能提升实践： +</p></section><a class=entry-link aria-label="post link to 《软件研发效能提升之美00》" href=https://zwlzls.github.io/posts/efficiency00/></a></article><article class=post-entry><header class=entry-header><h2>数据结构知识</h2></header><section class=entry-content><p>数据结构 数据结构知识 具体内容
数组：数组的内存空间是连续的，随机访问的时间复杂度是O1，适用于需要按索引访问元素的场景，但是插入和删除元素较慢，时间复杂度是On 链表：链表是由节点组成，节点之间是分散存储的，内存不连续，每个节点存储数据和指向下一个节点的指针。适用于频繁插入和删除元素的场景，随机访问元素较慢 栈：栈是一种后进先出的数据结构，只允许在栈顶进行插入和删除操作 队列：队列是一种先进先出（FIFO）的数据结构，允许在队尾插入元素，在队首删除元素 树：树是一种非线性数据结构，由节点和边组成，每个节点可以有多个子节点。树适用于表示层次关系的场景，例如文件系统、组织结构等 数组与链表区别？
访问效率，插入和删除操作效率，缓存命中率 应用场景：数组适合静态大小、频繁访问元素的场景，而链表适合动态大小、频繁插入、删除操作的场景 平衡二叉树
二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质： 非空左子树的所有键值小于其根结点的键值。 非空右子树的所有键值大于其根结点的键值。 左、右子树都是二叉搜索树。 二叉树搜索树的目的：缩短插入、删除、修改和查找节点的时间 一棵理想的二叉搜索树所有操作的时间可以缩短到 O(logn) 一棵每个结点只有右孩子的二叉搜索树，那么性质就和链表一样 平衡树将二叉查找树平衡均匀地分布，好处就是可以减少二叉查找树的深度 平衡二叉树平衡的特性： 左右两个子树的高度差（平衡因子）的绝对值不超过1 左右两个子树都是一棵平衡二叉树 红黑树
每个节点要么是红色，要么是黑色。 根节点是黑色。 每个叶子节点（NIL节点）是黑色。 如果一个节点是红色，则其子节点必须是黑色。 从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。 二叉查找树
当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n) 平衡二叉查找树 每个节点的左子树和右子树的高度差不能超过 1。也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 O(logn) B+树
B+树是一种自平衡的多路查找树，所有叶节点都位于同一层，保证了树的平衡，使得搜索、插入和删除操作的时间复杂度为对数级别的 非叶节点仅包含索引信息，不存储具体的数据记录，用来引导搜索到正确的叶节点 所有数据记录都存储在叶节点中，且叶节点中的数据是按关键字排序的。叶节点包含实际的数据和关键字，是数据存储和检索的实体单元。叶节点之间通过指针相互链接，形成一个链表，便于范围查询和顺序遍历</p></section><a class=entry-link aria-label="post link to 数据结构知识" href=https://zwlzls.github.io/posts/algorithm06/></a></article><article class=post-entry><header class=entry-header><h2>Hot100</h2></header><section class=entry-content><p>Hot100 回溯 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案
class Solution { List&lt;List&lt;Integer>>res; int len=0; public List&lt;List&lt;Integer>> permute(int[] nums) { this.res=new LinkedList&lt;>(); this.len=nums.length; dfs(nums,new LinkedList&lt;>(),new boolean[len]); return res; } public void dfs(int[] nums,LinkedList path,boolean[]p){ if(path.size()==len){ res.add(new LinkedList&lt;>(path)); return; } for(int i=0;i&lt;len;i++){ if(p[i]){ continue; } p[i]=true; path.add(nums[i]); dfs(nums,path,p); p[i]=false; path.remove(path.size()-1); } } } 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集
class Solution { List&lt;List&lt;Integer>>res=new LinkedList&lt;>(); LinkedList&lt;Integer>track=new LinkedList&lt;>(); public List&lt;List&lt;Integer>> subsets(int[] nums) { backtracking(nums,0); return res; } public void backtracking(int[] nums,int start){ res....</p></section><a class=entry-link aria-label="post link to Hot100" href=https://zwlzls.github.io/posts/algorithm03/></a></article><article class=post-entry><header class=entry-header><h2>算法总结</h2></header><section class=entry-content><p>以前写的总结 框架思维：
数据结构的存储方式：数组和链表 任何数据结构无非遍历和访问，在不同的场合高效增删改查 而遍历分为线性和非线性（for/while和递归） 算法心得：
算法的本质就是无穷举 数组/单链表常用：双指针，二分搜索，滑动窗口，回文子串，前缀和，差分数组 二叉树常用：1.遍历一遍二叉树(递归函数无返回值) 2.分解问题计算答案(递归函数有返回值) 二叉树：
void traverse(TreeNode root) { if (root == null) { return; } // 前序位置 :进入结点的时候 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 :离开结点的时候 } 层序遍历：竖while横for 链表：双指针
设置虚拟结点，用指针来进行变化，同时新建链表注意指明最后一个结点 回溯算法：
回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」 我们通过保证元素之间的相对顺序来防止出现重复子集—-用start变量 标记那些元素可以被选择—–用used数组 重复元素中找可能解—-先排序，用num[i]==num[i-1]来减枝 重复元素的全排列—-先排序，用num[i]==num[i-1]&&!used[i-1]固定相同数值位置来减枝（规则：相同则前一个必走过），且used[i]标记该数值是否被使用 子集/组合问题必须用start，排列问题必用used数组 数组：
双指针
一维前缀和：preSum[i] 记录 nums[0..i-1] 的累加和
二维前缀和：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和 对于前缀和问题：申请新数组范围是n+1，数组实际从索引1开始
差分数组：差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。 后面数据靠前面的差值，diff[i] 就是 nums[i] 和 nums[i-1] 之差 如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可：...</p></section><a class=entry-link aria-label="post link to 算法总结" href=https://zwlzls.github.io/posts/algorithm04/></a></article><article class=post-entry><header class=entry-header><h2>devops概述</h2></header><section class=entry-content><p>devops介绍 https://github.com/lcomplete/TechShare/blob/master/docs/engineering/devops.md全文
定义 DevOps 所要实现的目标都是一致的——缩短软件开发生命周期并使用 持续交付 提供高质量的软件，开发运维之间 沟通合作
发展背景： 敏态需求的增加，即探索性工作的增加： 软件开发从传统的瀑布流方式到敏捷开发，再到现在对敏捷开发提出了更高的要求，近些年创新型的应用不断涌现，这些应用的研发过程中多采用小步快跑、快速试错的方式，这些探索性工作要求运维能够具备一天发布多次的能力，需要企业完成由稳态到敏态的转变 软件开发活动在企业经营活动中占比的不断增加： 业务发展对软件的依赖由轻度依赖、中度依赖发展到目前的重度依赖。 企业存在对消除浪费的需求： 软件开发活动在企业中的位置越来越重要，软件开发活动中也存在着许多的浪费，企业管理上必然存在着 识别并消除浪费 的需求 软件开发中的浪费包括不必要和必要的浪费： 不必要的浪费有：无人使用的功能、软件bug、等待测试、等待审批等 必要的浪费包括：工作项移交、测试、项目管理 以上为深层原因，浅层原因有：容器化技术的发展、微服务架构的发展等等 DevOps原则 DevOps 原则是总体指导思想，实践是具体的执行方法，DevOps 是一个动态的过程，在进行相关实践的时候可以看看其应用了哪些原则，当违背原则的时候需要思考实践的合理性
三大原则：
流动原则：加速 从开发、运维到交付给客户的流程 反馈原则：建设 安全可靠 的工作体系 持续学习与实验原则：采用科学工作方式，将对组织的 改进和创新 作为工作一部分 流转原则： 坚持少做 产品开始开发时采用 MVP 原则（最小可行产品原则） MVP要求抓住最核心的产品流程，剥掉多余的功能或者高级功能，只要主流程可以跑起来可以。完美并不是我们的目标，快速试错才是我们目标 产品迭代时要适时做减法 持续分解问题 大的变更或需求拆解为一系列小的变更，快速解决 工作可视化 采用 Sprint 看板将工作可视化 控制任务数量 减少前置时间，降低测试人员的等待时间 任务越多，预估越不准确 减少交接次数 减少不必要的沟通和等待 持续识别和改善约束点 识别出影响流动的主要前置因素，比如搭建环境、需求文档 QA、开发、运维、产品持续提升生产力 为非功能性需求预留20%的开发时间，减少技术债务 消除价值流中的困境和浪费（导致交付延迟的主要因素） 半成品——未完全完成的工作 额外工序——从不使用的文档、重复编写接口文档等 额外功能——用户实际不需要的功能 任务切换——将人员分配到多个项目或截然不同的工作任务中 等待、移动、缺陷、非标准化的手动操作 返回原则 在复杂系统中安全地工作 管理复杂的工作，识别出设计和操作的问题 群策群力解决问题，从而快速构建新知识 在整个组织中，将区域性的知识应用到全局范围 领导者要持续培养有以上才能的人 及时发现问题 快速、频繁和高质量的信息流——每个工序的操作都会被度量和监控 技术价值流的每个阶段（产品管理、开发、QA、安全、运维），建立快速的反馈和前馈回路（包括自动化构建、集成和测试过程） 全方位的遥测系统 在源头保障质量 过多的检查和审批流程，使得做决策的地方远离执行工作的地方，这导致流程有效性降低，减弱了因果关系之间反馈的强度。 让开发人员也对系统质量负责，快速反馈，加速开发人员的学习。 为内部客户优化工作 运维的非功能性需求（如架构、性能、稳定性、可测试性、可配置性和安全性）与用户功能同样重要 持续学习和实验原则 建立学习型组织和安全文化 将日常工作的改进制度化 把局部发现转化为全局优化 在日常工作中注入弹性模式 缩短部署的前置时间、提高测试覆盖率、缩短测试执行时间，甚至在必要时解耦架构，都属于在系统中引入类似张力的做法。 领导层强化学习文化 领导者帮助一线工作者在日常工作中发现并解决问题 DevOps实践 基于 DevOps 的相关原则，有与其对应的实践，在应用这些实践之前还需认真设计组织结构，使其有利于实践的开展...</p></section><a class=entry-link aria-label="post link to devops概述" href=https://zwlzls.github.io/posts/devops00/></a></article><article class=post-entry><header class=entry-header><h2>Hot100</h2></header><section class=entry-content><p>Hot100 二叉树 给定一个二叉树的根节点 root ，返回 它的 中序 遍历
class Solution { public List&lt;Integer> inorderTraversal(TreeNode root) { List&lt;Integer> res = new ArrayList&lt;Integer>(); Stack&lt;TreeNode> stk = new Stack&lt;TreeNode>(); while (root != null || !stk.isEmpty()) { while (root != null) { stk.push(root); root = root.left; } root = stk.pop(); res.add(root.val); root = root.right; } return res; } } 思考中序过程就行
给定一个二叉树 root ，返回其最大深度。
二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。
class Solution { public int maxDepth(TreeNode root) { return Depth(root); } public int Depth(TreeNode root){ if(root==null){ return 0; } int left=Depth(root....</p></section><a class=entry-link aria-label="post link to Hot100" href=https://zwlzls.github.io/posts/algorithm02/></a></article><article class=post-entry><header class=entry-header><h2>Hot100</h2></header><section class=entry-content><p>Hot100 哈希 两数之和
class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer,Integer>map=new HashMap&lt;>(); int len=nums.length; for(int i=0;i&lt;len;i++){ int p=target-nums[i]; if(map.containsKey(p)){ return new int[]{i,map.get(p)}; } map.put(nums[i],i); } return new int[]{0,0}; } } 字母异位分组
class Solution { public List&lt;List&lt;String>> groupAnagrams(String[] strs) { HashMap&lt;String,LinkedList&lt;String>>cur=new HashMap&lt;>(); for(String str:strs){ char[] c1=str.toCharArray(); Arrays.sort(c1); String s=String.valueOf(c1); if(!cur.containsKey(s)){ cur.put(s,new LinkedList&lt;>()); cur.get(s).add(str); }else{ cur.get(s).add(str); } } return new LinkedList(cur.values()); } } 最长连续序列：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度
class Solution { public int longestConsecutive(int[] nums) { int ans = 0; Set&lt;Integer> st = new HashSet&lt;>(); for (int num : nums) { st....</p></section><a class=entry-link aria-label="post link to Hot100" href=https://zwlzls.github.io/posts/algorithm01/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://zwlzls.github.io/posts/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>