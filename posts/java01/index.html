<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java中级 | 我的博客</title>
<meta name=keywords content="Java"><meta name=description content='面向对象基础 理解： class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型
instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同
定义class
创建一个类，例如，给这个类命名为Person，就是定义一个class：
class Person { public String name; public int age; } class Book { public String name; public String author; public String isbn; public double price; } 创建实例
定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符
Person ming = new Person(); 区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例
ming.name = "Xiao Ming"; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = "Xiao Hong"; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：
┌──────────────────┐ ming ──────▶│Person instance │ ├──────────────────┤ │name = "Xiao Ming"│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────▶│Person instance │ ├──────────────────┤ │name = "Xiao Hong"│ │age = 15 │ └──────────────────┘ 方法 意义：'><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/java01/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/java01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Java中级"><meta property="og:description" content='面向对象基础 理解： class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型
instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同
定义class
创建一个类，例如，给这个类命名为Person，就是定义一个class：
class Person { public String name; public int age; } class Book { public String name; public String author; public String isbn; public double price; } 创建实例
定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符
Person ming = new Person(); 区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例
ming.name = "Xiao Ming"; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = "Xiao Hong"; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：
┌──────────────────┐ ming ──────▶│Person instance │ ├──────────────────┤ │name = "Xiao Ming"│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────▶│Person instance │ ├──────────────────┤ │name = "Xiao Hong"│ │age = 15 │ └──────────────────┘ 方法 意义：'><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/java01/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-22T22:05:54+08:00"><meta property="article:modified_time" content="2025-01-22T22:05:54+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java中级"><meta name=twitter:description content='面向对象基础 理解： class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型
instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同
定义class
创建一个类，例如，给这个类命名为Person，就是定义一个class：
class Person { public String name; public int age; } class Book { public String name; public String author; public String isbn; public double price; } 创建实例
定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符
Person ming = new Person(); 区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例
ming.name = "Xiao Ming"; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = "Xiao Hong"; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：
┌──────────────────┐ ming ──────▶│Person instance │ ├──────────────────┤ │name = "Xiao Ming"│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────▶│Person instance │ ├──────────────────┤ │name = "Xiao Hong"│ │age = 15 │ └──────────────────┘ 方法 意义：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Java中级","item":"https://zwlzls.github.io/posts/java01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java中级","name":"Java中级","description":"面向对象基础 理解： class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型\ninstance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同\n定义class\n创建一个类，例如，给这个类命名为Person，就是定义一个class：\nclass Person { public String name; public int age; } class Book { public String name; public String author; public String isbn; public double price; } 创建实例\n定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符\nPerson ming = new Person(); 区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例\nming.name = \u0026#34;Xiao Ming\u0026#34;; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = \u0026#34;Xiao Hong\u0026#34;; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：\n┌──────────────────┐ ming ──────▶│Person instance │ ├──────────────────┤ │name = \u0026#34;Xiao Ming\u0026#34;│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────▶│Person instance │ ├──────────────────┤ │name = \u0026#34;Xiao Hong\u0026#34;│ │age = 15 │ └──────────────────┘ 方法 意义：","keywords":["Java"],"articleBody":"面向对象基础 理解： class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型\ninstance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同\n定义class\n创建一个类，例如，给这个类命名为Person，就是定义一个class：\nclass Person { public String name; public int age; } class Book { public String name; public String author; public String isbn; public double price; } 创建实例\n定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符\nPerson ming = new Person(); 区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例\nming.name = \"Xiao Ming\"; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = \"Xiao Hong\"; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：\n┌──────────────────┐ ming ──────▶│Person instance │ ├──────────────────┤ │name = \"Xiao Ming\"│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────▶│Person instance │ ├──────────────────┤ │name = \"Xiao Hong\"│ │age = 15 │ └──────────────────┘ 方法 意义：\n一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性\n外部代码不能直接读取private字段，但可以通过getName()和getAge()间接获取private字段的值\n**调用方法**的语法是实例变量.方法名(参数);。一个方法调用就是一个语句，所以不要忘了在末尾加;\nming.setName(\"Xiao Ming\"); 定义方法\n修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值; } 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return\n定义private方法的理由是内部方法是可以调用private方法的\nthis变量\n在方法内部，可以使用一个隐含的变量this，它始终指向当前实例\n如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this：\nclass Person { private String name; public void setName(String name) { this.name = name; // 前面的this不可少，少了就变成局部变量name了 } } 方法参数\n包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。\nclass Person { ... public void setNameAndAge(String name, int age) { ... } } 可变参数\n可变参数用类型...定义，可变参数相当于数组类型：\nclass Group { private String[] names; public void setNames(String... names) { this.names = names; } } 上面的setNames()就定义了一个可变参数。调用时，可以这么写：\nGroup g = new Group(); g.setNames(\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"); // 传入3个String g.setNames(\"Xiao Ming\", \"Xiao Hong\"); // 传入2个String g.setNames(\"Xiao Ming\"); // 传入1个String g.setNames(); // 传入0个String 参数绑定\n基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响\n// 基本类型参数绑定 public class Main { public static void main(String[] args) { Person p = new Person(); int n = 15; // n的值为15 p.setAge(n); // 传入n的值 System.out.println(p.getAge()); // 15 n = 20; // n的值改为20 System.out.println(p.getAge()); // 15 } } class Person { private int age; public int getAge() { return this.age; } public void setAge(int age) { this.age = age; } } 引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）\n// 引用类型参数绑定 public class Main { public static void main(String[] args) { Person p = new Person(); String[] fullname = new String[] { \"Homer\", \"Simpson\" }; p.setName(fullname); // 传入fullname数组 System.out.println(p.getName()); // \"Homer Simpson\" fullname[0] = \"Bart\"; // fullname数组的第一个元素修改为\"Bart\" System.out.println(p.getName()); // \"Bart Simpson\" } } class Person { private String[] name; public String getName() { return this.name[0] + \" \" + this.name[1]; } public void setName(String[] name) { this.name = name; } } string的\npublic class Main { public static void main(String[] args) { Person p = new Person(); String bob = \"Bob\"; p.setName(bob); // 传入bob变量 System.out.println(p.getName()); // \"Bob\" bob = \"Alice\"; // bob改名为Alice System.out.println(p.getName()); // \"Bob\" } } class Person { private String name; public String getName() { return this.name; } public void setName(String name) { this.name = name; } } 构造方法 创建对象实例时就把内部字段全部初始化为合适的值\n// 构造方法 public class Main { public static void main(String[] args) { Person p = new Person(\"Xiao Ming\", 15); System.out.println(p.getName()); System.out.println(p.getAge()); } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } } 默认构造方法\n特别注意的是，如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法：\n// 构造方法 public class Main { public static void main(String[] args) { Person p = new Person(); // 编译错误:找不到这个构造方法 } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } } 既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来：\n// 构造方法 public class Main { public static void main(String[] args) { Person p1 = new Person(\"Xiao Ming\", 15); // 既可以调用带参数的构造方法 Person p2 = new Person(); // 也可以调用无参数构造方法 } } class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } } 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false：\nclass Person { private String name; // 默认初始化为null private int age; // 默认初始化为0 public Person() { } } 多个构造方法\nclass Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this.name = name; this.age = 12; } public Person() { } } 如果调用new Person(\"Xiao Ming\", 20);，会自动匹配到构造方法public Person(String, int)\n如果调用new Person(\"Xiao Ming\");，会自动匹配到构造方法public Person(String)。\n如果调用new Person();，会自动匹配到构造方法public Person()\n可以改为\nclass Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this(name, 18); // 调用另一个构造方法Person(String, int) } public Person() { this(\"Unnamed\"); // 调用另一个构造方法Person(String) } } 方法重载 有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法\nclass Hello { public void hello() { System.out.println(\"Hello, world!\"); } public void hello(String name) { System.out.println(\"Hello, \" + name + \"!\"); } public void hello(String name, int age) { if (age \u003c 18) { System.out.println(\"Hi, \" + name + \"!\"); } else { System.out.println(\"Hello, \" + name + \"!\"); } } } 这种方法名相同，但各自的参数不同，称为方法重载（Overload）\n重载目的：功能类似的方法使用同一名字，更容易记住，调用起来更简单\n继承 可以复用代码\nclass Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...} } class Student extends Person { // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() { … } public void setScore(int score) { … } } 子类自动获得了父类的所有字段，严禁定义与父类重名的字段！\nprtected\n子类无法访问父类的private字段或者private方法。\n例如，Student类就无法访问Person类的name和age字段：\nclass Person { private String name; private int age; } class Student extends Person { public String hello() { return \"Hello, \" + name; // 编译错误：无法访问name字段 } } 让子类可以访问父类的字段，我们需要把private改为protected\n用protected修饰的字段可以被子类访问：\nclass Person { protected String name; protected int age; } class Student extends Person { public String hello() { return \"Hello, \" + name; // OK! } } super\nsuper关键字表示父类（超类）。子类引用父类的字段时，可用super.fieldName\npublic class Main { public static void main(String[] args) { Student s = new Student(\"Xiao Ming\", 12, 89); } } class Person { protected String name; protected int age; public Person(String name, int age) { this.name = name; this.age = age; } } class Student extends Person { protected int score; public Student(String name, int age, int score) { this.score = score; } } 以上运行就会失误\n解决方法是调用Person类存在的某个构造方法。例如：\nclass Student extends Person { protected int score; public Student(String name, int age, int score) { super(name, age); // 调用父类的构造方法Person(String, int) this.score = score; } } 阻止继承\n只要某个class没有final修饰符，那么任何类都可以从该class继承\nJava 15开始，允许使用sealed修饰class，并通过permits明确写出能够从该class继承的子类名称\n例如，定义一个Shape类：\npublic sealed class Shape permits Rect, Circle, Triangle { ... } 上述Shape类就是一个sealed类，它只允许指定的3个类继承它。如果写：\npublic final class Rect extends Shape {...} 是没问题的，因为Rect出现在Shape的permits列表中。但是，如果定义一个Ellipse就会报错：\npublic final class Ellipse extends Shape {...} // Compile error: class is not allowed to extend sealed class: Shape 向上转型\n把一个子类类型安全地变为父类类型的赋值，被称为向上转型\n向上转型实际上是把一个子类型安全地变为更加抽象的父类型：\nStudent s = new Student(); Person p = s; // upcasting, ok Object o1 = p; // upcasting, ok Object o2 = s; // upcasting, ok 向下转型\n把一个父类类型强制转型为子类类型，就是向下转型\nPerson p1 = new Student(); // upcasting, ok Person p2 = new Person(); Student s1 = (Student) p1; // ok Student s2 = (Student) p2; // runtime error! ClassCastException! instanceof判断一个变量所指向的实例是否指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false。\n利用instanceof，在向下转型前可以先判断：\nPerson p = new Student(); if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功 } 多态 继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为重写\n方法名相同，方法参数相同，但方法返回值不同，也是不同的方法\nJava的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型\n多态的特性就是，运行期才能动态决定调用的子类方法\npublic class Main { public static void main(String[] args) { // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes = new Income[] { new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) }; System.out.println(totalTax(incomes)); } public static double totalTax(Income... incomes) { double total = 0; for (Income income: incomes) { total = total + income.getTax(); } return total; } } class Income { protected double income; public Income(double income) { this.income = income; } public double getTax() { return income * 0.1; // 税率10% } } class Salary extends Income { public Salary(double income) { super(income); } @Override public double getTax() { if (income \u003c= 5000) { return 0; } return (income - 5000) * 0.2; } } class StateCouncilSpecialAllowance extends Income { public StateCouncilSpecialAllowance(double income) { super(income); } @Override public double getTax() { return 0; } } 重写Object方法\n因为所有的class最终都继承自Object，而Object定义了几个重要的方法：\ntoString()：把instance输出为String equals()：判断两个instance是否逻辑相等 hashCode()：计算一个instance的哈希值 class Person { ... // 显示更有意义的字符串: @Override public String toString() { return \"Person:name=\" + name; } // 比较是否相等: @Override public boolean equals(Object o) { // 当且仅当o为Person类型: if (o instanceof Person) { Person p = (Person) o; // 并且name字段相同时，返回true: return this.name.equals(p.name); } return false; } // 计算hash: @Override public int hashCode() { return this.name.hashCode(); } } 调用super\n在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用\nclass Person { protected String name; public String hello() { return \"Hello, \" + name; } } class Student extends Person { @Override public String hello() { // 调用父类的hello()方法: return super.hello() + \"!\"; } } final\n用final修饰的方法不能被Override\nclass Person { protected String name; public final String hello() { return \"Hello, \" + name; } } class Student extends Person { // compile error: 不允许覆写 @Override public String hello() { } } 用final修饰的类不能被继承\nfinal class Person { protected String name; } // compile error: 不允许继承自Person class Student extends Person { } 用final修饰的字段在初始化后不能被修改\nclass Person { public final String name = \"Unamed\"; } Person p = new Person(); p.name = \"New Name\"; // compile error! 可在构造方法中初始化final字段：\nclass Person { public final String name; public Person(String name) { this.name = name; } } 抽象类 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，可以把父类的方法声明为抽象方法：\nclass Person { public abstract void run();//无法编译`Person`类 } 方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。Person类也无法被实例化\n必须把Person类本身也声明为abstract，才能正确编译它：\nabstract class Person { public abstract void run(); } 使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类：\nPerson p = new Person(); // 编译错误 抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错\n抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力\n接口 一个抽象类没有字段，所有方法全部都是抽象方法：\nabstract class Person { public abstract void run(); public abstract String getName(); } 可以把该抽象类改写为接口：interface。\ninterface Person { void run(); String getName(); } 接口定义的所有方法默认都是public abstract的，这两个修饰符不需要写出来\n当一个具体的class去实现一个interface时，使用implements关键字\nclass Student implements Person { private String name; public Student(String name) { this.name = name; } @Override public void run() { System.out.println(this.name + \" run\"); } @Override public String getName() { return this.name; } } 接口继承\ninterface继承自interface使用extends，它相当于扩展了接口的方法\ninterface Hello { void hello(); } interface Person extends Hello { void run(); String getName(); } Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口\ndefault方法\n// interface public class Main { public static void main(String[] args) { Person p = new Student(\"Xiao Ming\"); p.run();//Xiao Ming run } } interface Person { String getName(); default void run() { System.out.println(getName() + \" run\"); } } class Student implements Person { private String name; public Student(String name) { this.name = name; } public String getName() { return this.name; } } default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类; 如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法\n静态字段和静态方法 class中定义的字段，我们称之为实例字段，特点是，每个实例都有独立的字段，各个实例的同名字段互不影响\n用static修饰的字段，称为静态字段，只有一个共享“空间”，所有实例都会共享该字段\npublic class Main { public static void main(String[] args) { Person ming = new Person(\"Xiao Ming\", 12); Person hong = new Person(\"Xiao Hong\", 15); ming.number = 88; System.out.println(hong.number); hong.number = 99; System.out.println(ming.number); } } class Person { public String name; public int age; public static int number; public Person(String name, int age) { this.name = name; this.age = age; } } 推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段\nPerson.number = 99; System.out.println(Person.number); 静态方法：static修饰的方法称为静态方法\n调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用\npublic class Main { public static void main(String[] args) { Person.setNumber(99); System.out.println(Person.number); } } class Person { public static int number; public static void setNumber(int value) { number = value; } } 静态方法属于class而不属于实例，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段\n接口的静态字段\ninterface字段只能public static final，可把这些修饰符都去掉，可简写为：\npublic interface Person { // 编译器会自动加上public static final: int MALE = 1; int FEMALE = 2; } 编译器会自动把该字段变为public static final类型\n包 Java定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是包名.类名\n小明的Person类存放在包ming下面，因此，完整类名是ming.Person\nJDK的Arrays类存放在包java.util下面，因此，完整类名是java.util.Arrays\n在定义class的时候，需要在第一行声明这个class属于哪个包。\n小明的Person.java文件：\npackage ming; // 申明包名ming public class Person { } 包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系\n包结构把上面的Java文件组织\n假设以package_sample作为根目录，src作为源码目录，那所有文件结构就是：\npackage_sample └─ src ├─ hong │ └─ Person.java │ ming │ └─ Person.java └─ mr └─ jun └─ Arrays.java 即所有Java文件对应的目录层次要和包的层次一致\n编译后的.class文件也需要按照包结构存放。如果使用IDE，把编译后的.class文件放到bin目录下，那么，编译的文件结构就是：\npackage_sample └─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class import\n一个class中，我们总会引用其他的class\n写法是用import语句，导入小军的Arrays，然后写简单类名：\n// Person.java package ming; // 导入完整类名: import mr.jun.Arrays; public class Person { public void run() { // 写简单类名: Arrays Arrays arrays = new Arrays(); } } 写import的时候，可以使用*，表示把这个包下面的所有class都导入进来\nimport mr.jun.*;// 导入mr.jun包的所有class: 一般不推荐这种写法，因为在导入了多个包后，很难看出Arrays类属于哪个包\n作用域：修饰符可用来限定访问作用域 public\n定义为public的class、interface可以被其他任何类访问：\npackage abc; public class Hello { public void hi() { } } 上面的Hello是public，因此，可以被其他包的类访问：\npackage xyz; class Main { void foo() { // Main可以访问Hello Hello h = new Hello(); } } private\n定义为private的field、method无法被其他类访问：\npackage abc; public class Hello { // 不能被其他类调用: private void hi() { } public void hello() { this.hi(); } } 实际上，确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关，推荐把private方法放到后面\n由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限：\n// private public class Main { public static void main(String[] args) { Inner i = new Inner(); i.hi(); } // private方法: private static void hello() { System.out.println(\"private hello!\"); } // 静态内部类: static class Inner { public void hi() { Main.hello(); } } } protected\nprotected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类：\npackage abc; public class Hello { // protected方法: protected void hi() { } } package xyz; class Main extends Hello { void foo() { // 可以访问protected方法: hi(); } } package\n包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法\npackage abc; // package权限的类: class Hello { // package权限的方法: void hi() { } } package abc; class Main { void foo() { // 可以访问package权限的类: Hello h = new Hello(); // 可以调用package权限的方法: h.hi(); } } 局部变量\n在方法内部定义的变量称为局部变量，作用域**从变量声明处开始到对应的块结束** final\n用final修饰class可以阻止被继承：\npackage abc; // 无法被继承: public final class Hello { private int n = 0; protected void hi(int t) { long i = t; } } 用final修饰method可以阻止被子类覆写： package abc; public class Hello { // 无法被覆写: protected final void hi() { } } 用final修饰field可以阻止被重新赋值： package abc; public class Hello { private final int n = 0; protected void hi() { this.n = 1; // error! } } 用final修饰局部变量可以阻止被重新赋值： package abc; public class Hello { protected void hi(final int t) { t = 1; // error! } } 内部类 **定义在另一个类的内部，所以称为内部类 **\n一个类定义在另一个类的内部：Inner Class\nclass Outer { class Inner { // 定义了一个Inner Class } } // inner class public class Main { public static void main(String[] args) { Outer outer = new Outer(\"Nested\"); // 实例化一个Outer Outer.Inner inner = outer.new Inner(); // 实例化一个Inner inner.hello(); } } class Outer { private String name; Outer(String name) { this.name = name; } class Inner { void hello() { System.out.println(\"Hello, \" + Outer.this.name); } } } 不需要在Outer Class中明确地定义这个Class，而是在方法内部：匿名类\n// Anonymous Class public class Main { public static void main(String[] args) { Outer outer = new Outer(\"Nested\"); outer.asyncHello(); } } class Outer { private String name; Outer(String name) { this.name = name; } void asyncHello() { Runnable r = new Runnable() { @Override public void run() { System.out.println(\"Hello, \" + Outer.this.name); } }; new Thread(r).start(); } } 观察asyncHello()方法，我们在方法内部实例化了一个Runnable。Runnable本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了Runnable接口的匿名类，并且通过new实例化该匿名类，然后转型为Runnable。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：\nRunnable r = new Runnable() { // 实现必要的抽象方法... }; 观察Java编译器编译后的.class文件可以发现，Outer类被编译为Outer.class，而匿名类被编译为Outer$1.class。如果有多个匿名类，Java编译器会将每个匿名类依次命名为Outer$1、Outer$2、Outer$3……\nstatic nested class\npublic class Main { public static void main(String[] args) { Outer.StaticNested sn = new Outer.StaticNested(); sn.hello(); } } class Outer { private static String NAME = \"OUTER\"; private String name; Outer(String name) { this.name = name; } static class StaticNested { void hello() { System.out.println(\"Hello, \" + Outer.NAME); } } } 用static修饰的内部类和Inner Class有很大的不同，它不再依附于Outer的实例，而是一个完全独立的类，因此无法引用Outer.this，但它可以访问Outer的private静态字段和静态方法。如果把StaticNested移到Outer之外，就失去了访问private的权限\nclasspath和jar classpath`是JVM用到的一个环境变量，它用来指示JVM如何搜索`class 因Java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件 classpath就是一组目录的集合，它设置的搜索路径与操作系统相关\n在Windows系统上，用;分隔，带空格的目录用\"\"括起来，可能长这样：\nC:\\work\\project1\\bin;C:\\shared;\"D:\\My Documents\\project1\\bin\" 在Linux系统上，用:分隔，可能长这样：\n/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin 假设classpath是.;C:\\work\\project1\\bin;C:\\shared，当JVM在加载abc.xyz.Hello这个类时，会依次查找：\n\u003c当前目录\u003e\\abc\\xyz\\Hello.class C:\\work\\project1\\bin\\abc\\xyz\\Hello.class C:\\shared\\abc\\xyz\\Hello.class 在启动JVM时设置classpath才是推荐的做法。实际上就是给java命令传入-classpath参数：\njava -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello jar包\n有很多.class文件，散落在各层目录中，肯定不便于管理；jar包就是用来干这个事的，它可以把package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件）都打成一个jar文件\njar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的class，就可以把jar包放到classpath中：\njava -cp ./hello.jar abc.xyz.Hello 这样JVM会自动在hello.jar文件里去搜索某个类\n如何创建jar包？\n直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从.zip改为.jar，一个jar包就创建成功\n假设编译输出的目录结构是这样：\npackage_sample └─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class 特别注意的是，jar包里的第一层目录，不能是bin，而应该是hong、ming、mr\n上面的hello.zip包含有bin目录，说明打包打得有问题，JVM仍然无法从jar包中查找正确的class，原因是hong.Person必须按hong/Person.class存放，而不是bin/hong/Person.class\nclass版本 Java 8，Java 11，Java 17，是指JDK的版本，也就是JVM的版本\n是java.exe这个程序的版本：\n$ java -version java version \"17\" 2021-09-14 LTS 而每个版本的JVM，它能执行的class文件版本也不同。例如，Java 11对应的class文件版本是55，而Java 17对应的class文件版本是61\n指定编译输出有两种方式\n一种是在javac命令行中用参数--release设置： $ javac --release 11 Main.java 参数--release 11表示源码兼容Java 11，编译的class输出版本为Java 11兼容，即class版本55。\n​\t第二种方式是用参数--source指定源码版本，用参数--target指定输出class版本：\n$ javac --source 9 --target 11 Main.java 如果使用Java 17的JDK编译，它会把源码视为Java 9兼容版本，并输出class为Java 11兼容版本\n运行时使用哪个JDK版本，编译时就尽量使用同一版本的JDK编译源码\n模块 .class文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆.class文件，很不便于管理，所以，jar文件就是class文件的容器 jar只是用于存放class的容器，它并不关心class之间的依赖 如果a.jar必须依赖另一个b.jar才能运行，那我们应该给a.jar加点说明啥的，让程序在编译和运行的时候能自动定位到b.jar，这种**自带“依赖关系”的class容器就是模块** ","wordCount":"2370","inLanguage":"en","datePublished":"2025-01-22T22:05:54+08:00","dateModified":"2025-01-22T22:05:54+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/java01/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Java中级</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e5%9f%ba%e7%a1%80 aria-label=面向对象基础>面向对象基础</a><ul><li><a href=#%e7%90%86%e8%a7%a3 aria-label=理解：>理解：</a></li><li><a href=#%e6%96%b9%e6%b3%95 aria-label=方法>方法</a></li><li><a href=#%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95 aria-label=构造方法>构造方法</a></li><li><a href=#%e6%96%b9%e6%b3%95%e9%87%8d%e8%bd%bd aria-label=方法重载>方法重载</a></li><li><a href=#%e7%bb%a7%e6%89%bf aria-label=继承>继承</a></li><li><a href=#%e5%a4%9a%e6%80%81 aria-label=多态>多态</a></li><li><a href=#%e6%8a%bd%e8%b1%a1%e7%b1%bb aria-label=抽象类>抽象类</a></li><li><a href=#%e6%8e%a5%e5%8f%a3 aria-label=接口>接口</a></li><li><a href=#%e9%9d%99%e6%80%81%e5%ad%97%e6%ae%b5%e5%92%8c%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95 aria-label=静态字段和静态方法>静态字段和静态方法</a></li><li><a href=#%e5%8c%85 aria-label=包>包</a></li><li><a href=#%e4%bd%9c%e7%94%a8%e5%9f%9f%e4%bf%ae%e9%a5%b0%e7%ac%a6%e5%8f%af%e7%94%a8%e6%9d%a5%e9%99%90%e5%ae%9a%e8%ae%bf%e9%97%ae%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label=作用域：修饰符可用来限定访问作用域>作用域：修饰符可用来限定访问作用域</a></li><li><a href=#%e5%86%85%e9%83%a8%e7%b1%bb aria-label=内部类>内部类</a></li><li><a href=#classpath%e5%92%8cjar aria-label=classpath和jar><code>classpath</code>和<code>jar</code></a></li><li><a href=#class%e7%89%88%e6%9c%ac aria-label=class版本><code>class</code>版本</a></li><li><a href=#%e6%a8%a1%e5%9d%97 aria-label=模块>模块</a></li></ul></li></ul></div></details></div><div class=post-content><h3 id=面向对象基础>面向对象基础<a hidden class=anchor aria-hidden=true href=#面向对象基础>#</a></h3><ul><li><h4 id=理解>理解：<a hidden class=anchor aria-hidden=true href=#理解>#</a></h4><ul><li><p>class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型</p></li><li><p>instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同</p></li><li><p>定义class</p><ul><li><p>创建一个类，例如，给这个类命名为<code>Person</code>，就是定义一个<code>class</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Book</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String author;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String isbn;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> price;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>创建实例</p><ul><li><p><strong>定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person ming <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span></code></pre></div><p><strong>区分<code>Person ming</code>是定义<code>Person</code>类型的变量<code>ming</code>，而<code>new Person()</code>是创建<code>Person</code>实例</strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ming.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Xiao Ming&#34;</span>; <span style=color:#75715e>// 对字段name赋值</span>
</span></span><span style=display:flex><span>ming.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> 12; <span style=color:#75715e>// 对字段age赋值</span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(ming.<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// 访问字段name</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Person hong <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>hong.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Xiao Hong&#34;</span>;
</span></span><span style=display:flex><span>hong.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> 15;
</span></span></code></pre></div><p>上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：</p><pre tabindex=0><code>            ┌──────────────────┐
ming ──────▶│Person instance   │
            ├──────────────────┤
            │name = &#34;Xiao Ming&#34;│
            │age = 12          │
            └──────────────────┘
            ┌──────────────────┐
hong ──────▶│Person instance   │
            ├──────────────────┤
            │name = &#34;Xiao Hong&#34;│
            │age = 15          │
            └──────────────────┘
</code></pre></li></ul></li></ul></li><li><h4 id=方法>方法<a hidden class=anchor aria-hidden=true href=#方法>#</a></h4><ul><li><p>意义：</p><ul><li><p>一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性</p><p>外部代码不能直接读取<code>private</code>字段，但可以通过<code>getName()</code>和<code>getAge()</code>间接获取<code>private</code>字段的值</p></li><li><p>**调用方法**的语法是<code>实例变量.方法名(参数);</code>。一个方法调用就是一个语句，所以不要忘了在末尾加<code>;</code></p><pre tabindex=0><code>ming.setName(&#34;Xiao Ming&#34;);
</code></pre></li></ul></li><li><p>定义方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>修饰符 方法返回类型 <span style=color:#a6e22e>方法名</span>(方法参数列表) {
</span></span><span style=display:flex><span>    若干方法语句;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> 方法返回值;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>方法返回值通过<code>return</code>语句实现，如果没有返回值，返回类型设置为<code>void</code>，可以省略<code>return</code></p></li><li><p>定义<code>private</code>方法的理由是内部方法是可以调用<code>private</code>方法的</p></li><li><p><code>this</code>变量</p><ul><li><p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例</p></li><li><p>如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上<code>this</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name; <span style=color:#75715e>// 前面的this不可少，少了就变成局部变量name了</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>方法参数</p><ul><li><p>包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setNameAndAge</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>可变参数</p><ul><li><p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Group</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String<span style=color:#f92672>[]</span> names;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setNames</span>(String... names) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>names</span> <span style=color:#f92672>=</span> names;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>上面的<code>setNames()</code>就定义了一个可变参数。调用时，可以这么写：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Group g <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Group();
</span></span><span style=display:flex><span>g.<span style=color:#a6e22e>setNames</span>(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>, <span style=color:#e6db74>&#34;Xiao Hong&#34;</span>, <span style=color:#e6db74>&#34;Xiao Jun&#34;</span>); <span style=color:#75715e>// 传入3个String</span>
</span></span><span style=display:flex><span>g.<span style=color:#a6e22e>setNames</span>(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>, <span style=color:#e6db74>&#34;Xiao Hong&#34;</span>); <span style=color:#75715e>// 传入2个String</span>
</span></span><span style=display:flex><span>g.<span style=color:#a6e22e>setNames</span>(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>); <span style=color:#75715e>// 传入1个String</span>
</span></span><span style=display:flex><span>g.<span style=color:#a6e22e>setNames</span>(); <span style=color:#75715e>// 传入0个String</span>
</span></span></code></pre></div></li></ul></li><li><p>参数绑定</p><ul><li><p><strong>基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 基本类型参数绑定</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> 15; <span style=color:#75715e>// n的值为15</span>
</span></span><span style=display:flex><span>        p.<span style=color:#a6e22e>setAge</span>(n); <span style=color:#75715e>// 传入n的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getAge</span>()); <span style=color:#75715e>// 15</span>
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> 20; <span style=color:#75715e>// n的值改为20</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getAge</span>()); <span style=color:#75715e>// 15</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setAge</span>(<span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 引用类型参数绑定</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>        String<span style=color:#f92672>[]</span> fullname <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>[]</span> { <span style=color:#e6db74>&#34;Homer&#34;</span>, <span style=color:#e6db74>&#34;Simpson&#34;</span> };
</span></span><span style=display:flex><span>        p.<span style=color:#a6e22e>setName</span>(fullname); <span style=color:#75715e>// 传入fullname数组</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getName</span>()); <span style=color:#75715e>// &#34;Homer Simpson&#34;</span>
</span></span><span style=display:flex><span>        fullname<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Bart&#34;</span>; <span style=color:#75715e>// fullname数组的第一个元素修改为&#34;Bart&#34;</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getName</span>()); <span style=color:#75715e>// &#34;Bart Simpson&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String<span style=color:#f92672>[]</span> name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span>(String<span style=color:#f92672>[]</span> name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>string</code>的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>        String bob <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Bob&#34;</span>;
</span></span><span style=display:flex><span>        p.<span style=color:#a6e22e>setName</span>(bob); <span style=color:#75715e>// 传入bob变量</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getName</span>()); <span style=color:#75715e>// &#34;Bob&#34;</span>
</span></span><span style=display:flex><span>        bob <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Alice&#34;</span>; <span style=color:#75715e>// bob改名为Alice</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getName</span>()); <span style=color:#75715e>// &#34;Bob&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=构造方法>构造方法<a hidden class=anchor aria-hidden=true href=#构造方法>#</a></h4><ul><li><p><strong>创建对象实例时就把内部字段全部初始化为合适的值</strong></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 构造方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>, 15);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getAge</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>默认构造方法</p><ul><li><p>特别注意的是，如果我们自定义了一个构造方法，那么，编译器就<em>不再</em>自动创建默认构造方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 构造方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(); <span style=color:#75715e>// 编译错误:找不到这个构造方法</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 构造方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>, 15); <span style=color:#75715e>// 既可以调用带参数的构造方法</span>
</span></span><span style=display:flex><span>        Person p2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(); <span style=color:#75715e>// 也可以调用无参数构造方法</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>没有在构造方法中初始化字段时，引用类型的字段默认是<code>null</code>，数值类型的字段用默认值，<code>int</code>类型默认值是<code>0</code>，布尔类型默认值是<code>false</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name; <span style=color:#75715e>// 默认初始化为null</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age; <span style=color:#75715e>// 默认初始化为0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>多个构造方法</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> 12;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果调用<code>new Person("Xiao Ming", 20);</code>，会自动匹配到构造方法<code>public Person(String, int)</code></p><p>如果调用<code>new Person("Xiao Ming");</code>，会自动匹配到构造方法<code>public Person(String)</code>。</p><p>如果调用<code>new Person();</code>，会自动匹配到构造方法<code>public Person()</code></p></li><li><p>可以改为</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>(name, 18); <span style=color:#75715e>// 调用另一个构造方法Person(String, int)</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>(<span style=color:#e6db74>&#34;Unnamed&#34;</span>); <span style=color:#75715e>// 调用另一个构造方法Person(String)</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=方法重载>方法重载<a hidden class=anchor aria-hidden=true href=#方法重载>#</a></h4><ul><li><p><strong>有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成<em>同名</em>方法</strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Hello, world!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>(String name) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (age <span style=color:#f92672>&lt;</span> 18) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Hi, &#34;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;!&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;!&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>这种方法名相同，但各自的参数不同，称为方法重载（<code>Overload</code>）</strong></p><p><strong>重载目的：功能类似的方法使用同一名字，更容易记住，调用起来更简单</strong></p></li></ul></li><li><h4 id=继承>继承<a hidden class=anchor aria-hidden=true href=#继承>#</a></h4><ul><li><p>可以复用代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {...}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span>(String name) {...}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() {...}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setAge</span>(<span style=color:#66d9ef>int</span> age) {...}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 不要重复name和age字段/方法,</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 只需要定义新增score字段/方法:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> score;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getScore</span>() { <span style=color:#960050;background-color:#1e0010>…</span> }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setScore</span>(<span style=color:#66d9ef>int</span> score) { <span style=color:#960050;background-color:#1e0010>…</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</p></li><li><p><code>prtected</code></p><p><strong>子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。</strong></p><p>例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> name; <span style=color:#75715e>// 编译错误：无法访问name字段</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code></strong></p><p>用<code>protected</code>修饰的字段可以被子类访问：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> name; <span style=color:#75715e>// OK!</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>super</code></p><p><strong><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可用<code>super.fieldName</code></strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Student s <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>, 12, 89);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>int</span> score;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Student</span>(String name, <span style=color:#66d9ef>int</span> age, <span style=color:#66d9ef>int</span> score) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>score</span> <span style=color:#f92672>=</span> score;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>以上运行就会失误</strong></p><p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>int</span> score;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Student</span>(String name, <span style=color:#66d9ef>int</span> age, <span style=color:#66d9ef>int</span> score) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(name, age); <span style=color:#75715e>// 调用父类的构造方法Person(String, int)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>score</span> <span style=color:#f92672>=</span> score;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>阻止继承</p><ul><li><p><strong>只要某个class没有<code>final</code>修饰符，那么任何类都可以从该class继承</strong></p></li><li><p><strong>Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称</strong></p><p>例如，定义一个<code>Shape</code>类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Shape</span> permits Rect, Circle, Triangle {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述<code>Shape</code>类就是一个<code>sealed</code>类，它只允许指定的3个类继承它。如果写：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Rect</span> <span style=color:#66d9ef>extends</span> Shape {...}
</span></span></code></pre></div><p>是没问题的，因为<code>Rect</code>出现在<code>Shape</code>的<code>permits</code>列表中。但是，如果定义一个<code>Ellipse</code>就会报错：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ellipse</span> <span style=color:#66d9ef>extends</span> Shape {...}
</span></span><span style=display:flex><span><span style=color:#75715e>// Compile error: class is not allowed to extend sealed class: Shape</span>
</span></span></code></pre></div></li></ul></li><li><p>向上转型</p><ul><li><p><strong>把一个子类类型安全地变为父类类型的赋值，被称为向上转型</strong></p><p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Student s <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student();
</span></span><span style=display:flex><span>Person p <span style=color:#f92672>=</span> s; <span style=color:#75715e>// upcasting, ok</span>
</span></span><span style=display:flex><span>Object o1 <span style=color:#f92672>=</span> p; <span style=color:#75715e>// upcasting, ok</span>
</span></span><span style=display:flex><span>Object o2 <span style=color:#f92672>=</span> s; <span style=color:#75715e>// upcasting, ok</span>
</span></span></code></pre></div></li></ul></li><li><p>向下转型</p><ul><li><p>把一个父类类型强制转型为子类类型，就是向下转型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person p1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student(); <span style=color:#75715e>// upcasting, ok</span>
</span></span><span style=display:flex><span>Person p2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>Student s1 <span style=color:#f92672>=</span> (Student) p1; <span style=color:#75715e>// ok</span>
</span></span><span style=display:flex><span>Student s2 <span style=color:#f92672>=</span> (Student) p2; <span style=color:#75715e>// runtime error! ClassCastException!</span>
</span></span></code></pre></div></li><li><p><code>instanceof</code>判断一个变量所指向的实例是否指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p><p>利用<code>instanceof</code>，在向下转型前可以先判断：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student();
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (p <span style=color:#66d9ef>instanceof</span> Student) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 只有判断成功才会向下转型:</span>
</span></span><span style=display:flex><span>    Student s <span style=color:#f92672>=</span> (Student) p; <span style=color:#75715e>// 一定会成功</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=多态>多态<a hidden class=anchor aria-hidden=true href=#多态>#</a></h4><ul><li><p><strong>继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为重写</strong></p><p><strong>方法名相同，方法参数相同，但方法返回值不同，也是不同的方法</strong></p><p><strong>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型</strong></p></li><li><p><strong>多态的特性就是，运行期才能动态决定调用的子类方法</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span>
</span></span><span style=display:flex><span>        Income<span style=color:#f92672>[]</span> incomes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Income<span style=color:#f92672>[]</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Income(3000),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Salary(7500),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> StateCouncilSpecialAllowance(15000)
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(totalTax(incomes));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>totalTax</span>(Income... incomes) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> total <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Income income: incomes) {
</span></span><span style=display:flex><span>            total <span style=color:#f92672>=</span> total <span style=color:#f92672>+</span> income.<span style=color:#a6e22e>getTax</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> total;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Income</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>double</span> income;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Income</span>(<span style=color:#66d9ef>double</span> income) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>income</span> <span style=color:#f92672>=</span> income;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getTax</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> income <span style=color:#f92672>*</span> 0.<span style=color:#a6e22e>1</span>; <span style=color:#75715e>// 税率10%</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Salary</span> <span style=color:#66d9ef>extends</span> Income {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Salary</span>(<span style=color:#66d9ef>double</span> income) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(income);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getTax</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (income <span style=color:#f92672>&lt;=</span> 5000) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 0;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (income <span style=color:#f92672>-</span> 5000) <span style=color:#f92672>*</span> 0.<span style=color:#a6e22e>2</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StateCouncilSpecialAllowance</span> <span style=color:#66d9ef>extends</span> Income {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>StateCouncilSpecialAllowance</span>(<span style=color:#66d9ef>double</span> income) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(income);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getTax</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>重写<code>Object</code>方法</p><p><strong>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</strong></p><ul><li><code>toString()</code>：把instance输出为<code>String</code></li><li><code>equals()</code>：判断两个instance是否逻辑相等</li><li><code>hashCode()</code>：计算一个instance的哈希值</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 显示更有意义的字符串:</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Person:name=&#34;</span> <span style=color:#f92672>+</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 比较是否相等:</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>equals</span>(Object o) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当且仅当o为Person类型:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (o <span style=color:#66d9ef>instanceof</span> Person) {
</span></span><span style=display:flex><span>            Person p <span style=color:#f92672>=</span> (Person) o;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 并且name字段相同时，返回true:</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>.<span style=color:#a6e22e>equals</span>(p.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 计算hash:</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hashCode</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>.<span style=color:#a6e22e>hashCode</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>调用<code>super</code></p><p><strong>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用父类的hello()方法:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>hello</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;!&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>final</code></p><ul><li><p>用<code>final</code>修饰的方法不能被<code>Override</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> String <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// compile error: 不允许覆写</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>用<code>final</code>修饰的类不能被继承</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> String name;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// compile error: 不允许继承自Person</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>用<code>final</code>修饰的字段在初始化后不能被修改</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> String name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Unamed&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>p.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;New Name&#34;</span>; <span style=color:#75715e>// compile error!</span>
</span></span></code></pre></div><p><strong>可在构造方法中初始化final字段：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=抽象类>抽象类<a hidden class=anchor aria-hidden=true href=#抽象类>#</a></h4><ul><li><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，<strong>目的是让子类去覆写它，可以把父类的方法声明为抽象方法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>();<span style=color:#75715e>//无法编译`Person`类</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。<code>Person</code>类也无法被实例化</p><p>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(); <span style=color:#75715e>// 编译错误</span>
</span></span></code></pre></div><p><strong>抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错</strong></p></li><li><p><strong>抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力</strong></p></li></ul></li><li><h4 id=接口>接口<a hidden class=anchor aria-hidden=true href=#接口>#</a></h4><ul><li><p><strong>一个抽象类没有字段，所有方法全部都是抽象方法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> String <span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以把该抽象类改写为接口：<code>interface</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>接口定义的所有方法默认都是<code>public abstract</code>的，这两个修饰符不需要写出来</strong></p></li><li><p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，使用<code>implements</code>关键字</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>implements</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Student</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; run&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>接口继承</p><p><strong><code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>extends</span> Hello {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Person</code>接口现在实际上有3个抽象方法签名，其中一个来自继承的<code>Hello</code>接口</p></li><li><p><code>default</code>方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// interface</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>);
</span></span><span style=display:flex><span>        p.<span style=color:#a6e22e>run</span>();<span style=color:#75715e>//Xiao Ming run</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(getName() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; run&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>implements</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Student</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类;
如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法</p></li></ul></li><li><h4 id=静态字段和静态方法>静态字段和静态方法<a hidden class=anchor aria-hidden=true href=#静态字段和静态方法>#</a></h4><ul><li><p><strong><code>class</code>中定义的字段，我们称之为实例字段，特点是，每个实例都有独立的字段，各个实例的同名字段互不影响</strong></p></li><li><p><strong>用<code>static</code>修饰的字段，称为静态字段，只有一个共享“空间”，所有实例都会共享该字段</strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person ming <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>, 12);
</span></span><span style=display:flex><span>        Person hong <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Xiao Hong&#34;</span>, 15);
</span></span><span style=display:flex><span>        ming.<span style=color:#a6e22e>number</span> <span style=color:#f92672>=</span> 88;
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(hong.<span style=color:#a6e22e>number</span>);
</span></span><span style=display:flex><span>        hong.<span style=color:#a6e22e>number</span> <span style=color:#f92672>=</span> 99;
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(ming.<span style=color:#a6e22e>number</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> number;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>推荐用类名来访问静态字段。可以把静态字段理解为描述<code>class</code>本身的字段</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person.<span style=color:#a6e22e>number</span> <span style=color:#f92672>=</span> 99;
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Person.<span style=color:#a6e22e>number</span>);
</span></span></code></pre></div></li><li><p><strong>静态方法：<code>static</code>修饰的方法称为静态方法</strong></p><p><strong>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person.<span style=color:#a6e22e>setNumber</span>(99);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Person.<span style=color:#a6e22e>number</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> number;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setNumber</span>(<span style=color:#66d9ef>int</span> value) {
</span></span><span style=display:flex><span>        number <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>静态方法属于<code>class</code>而不属于实例，静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它只能访问静态字段</strong></p></li><li><p>接口的静态字段</p><p><strong><code>interface</code>字段只能<code>public static final</code>，可把这些修饰符都去掉，可简写为：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 编译器会自动加上public static final:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> MALE <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> FEMALE <span style=color:#f92672>=</span> 2;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译器会自动把该字段变为<code>public static final</code>类型</p></li></ul></li><li><h4 id=包>包<a hidden class=anchor aria-hidden=true href=#包>#</a></h4><ul><li><p><strong>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code></strong></p><p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code></p><p>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code></p></li><li><p>在定义<code>class</code>的时候，需要在第一行声明这个<code>class</code>属于哪个包。</p><p>小明的<code>Person.java</code>文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> ming; <span style=color:#75715e>// 申明包名ming</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong><em>包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系</em></strong></p></li><li><p>包结构把上面的Java文件组织</p><ul><li><p>假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那所有文件结构就是：</p><pre tabindex=0><code>package_sample
└─ src
    ├─ hong
    │  └─ Person.java
    │  ming
    │  └─ Person.java
    └─ mr
       └─ jun
          └─ Arrays.java
</code></pre><p>即所有Java文件对应的目录层次要和包的层次一致</p></li><li><p>编译后的<code>.class</code>文件也需要按照包结构存放。如果使用IDE，把编译后的<code>.class</code>文件放到<code>bin</code>目录下，那么，编译的文件结构就是：</p><pre tabindex=0><code>package_sample
└─ bin
   ├─ hong
   │  └─ Person.class
   │  ming
   │  └─ Person.class
   └─ mr
      └─ jun
         └─ Arrays.class
</code></pre></li></ul></li><li><p><code>import</code></p><ul><li><p>一个<code>class</code>中，我们总会引用其他的<code>class</code></p></li><li><p>写法是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Person.java</span>
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> ming;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 导入完整类名:</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> mr.jun.Arrays;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 写简单类名: Arrays</span>
</span></span><span style=display:flex><span>        Arrays arrays <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Arrays();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来</strong></p><pre tabindex=0><code>import mr.jun.*;// 导入mr.jun包的所有class:
</code></pre><p>一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包</p></li></ul></li></ul></li><li><h4 id=作用域修饰符可用来限定访问作用域>作用域：修饰符可用来限定访问作用域<a hidden class=anchor aria-hidden=true href=#作用域修饰符可用来限定访问作用域>#</a></h4><ul><li><p><code>public</code></p><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> abc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hi</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的<code>Hello</code>是<code>public</code>，因此，可以被其他包的类访问：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> xyz;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Main可以访问Hello</span>
</span></span><span style=display:flex><span>        Hello h <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Hello();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>private</code></p><p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> abc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 不能被其他类调用:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hi</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>hi</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>实际上，确切地说，<code>private</code>访问权限被限定在<code>class</code>的内部，而且与方法声明顺序<em>无关</em>，<strong>推荐把<code>private</code>方法放到后面</strong></p><ul><li><p>由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// private</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Inner i <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Inner();
</span></span><span style=display:flex><span>        i.<span style=color:#a6e22e>hi</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// private方法:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;private hello!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 静态内部类:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Inner</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hi</span>() {
</span></span><span style=display:flex><span>            Main.<span style=color:#a6e22e>hello</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p><code>protected</code></p><ul><li><p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> abc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// protected方法:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hi</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> xyz;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> <span style=color:#66d9ef>extends</span> Hello {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 可以访问protected方法:</span>
</span></span><span style=display:flex><span>        hi();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p><code>package</code></p><ul><li><p><strong>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> abc;
</span></span><span style=display:flex><span><span style=color:#75715e>// package权限的类:</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// package权限的方法:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hi</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> abc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 可以访问package权限的类:</span>
</span></span><span style=display:flex><span>        Hello h <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Hello();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 可以调用package权限的方法:</span>
</span></span><span style=display:flex><span>        h.<span style=color:#a6e22e>hi</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>局部变量</p><ul><li>在方法内部定义的变量称为局部变量，作用域**从变量声明处开始到对应的块结束**</li></ul></li><li><p><code>final</code></p><ul><li><p>用<code>final</code>修饰<code>class</code>可以阻止被继承：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> abc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 无法被继承:</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hi</span>(<span style=color:#66d9ef>int</span> t) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> t;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> abc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 无法被覆写:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hi</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> abc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hi</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>n</span> <span style=color:#f92672>=</span> 1; <span style=color:#75715e>// error!</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>用<code>final</code>修饰局部变量可以阻止被重新赋值：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> abc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hi</span>(<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> t) {
</span></span><span style=display:flex><span>        t <span style=color:#f92672>=</span> 1; <span style=color:#75715e>// error!</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=内部类>内部类<a hidden class=anchor aria-hidden=true href=#内部类>#</a></h4><ul><li><p>**定义在另一个类的内部，所以称为内部类 **</p></li><li><p>一个类定义在另一个类的内部：<strong>Inner Class</strong></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Outer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Inner</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 定义了一个Inner Class</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// inner class</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Outer outer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Outer(<span style=color:#e6db74>&#34;Nested&#34;</span>); <span style=color:#75715e>// 实例化一个Outer</span>
</span></span><span style=display:flex><span>        Outer.<span style=color:#a6e22e>Inner</span> inner <span style=color:#f92672>=</span> outer.<span style=color:#a6e22e>new</span> <span style=color:#a6e22e>Inner</span>(); <span style=color:#75715e>// 实例化一个Inner</span>
</span></span><span style=display:flex><span>        inner.<span style=color:#a6e22e>hello</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Outer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Outer(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Inner</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> Outer.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>不需要在Outer Class中明确地定义这个Class，而是在方法内部：匿名类</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Anonymous Class</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Outer outer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Outer(<span style=color:#e6db74>&#34;Nested&#34;</span>);
</span></span><span style=display:flex><span>        outer.<span style=color:#a6e22e>asyncHello</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Outer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Outer(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>asyncHello</span>() {
</span></span><span style=display:flex><span>        Runnable r <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Runnable() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> Outer.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(r).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p>观察<code>asyncHello()</code>方法，我们在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的匿名类，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Runnable r <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Runnable() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 实现必要的抽象方法...</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而匿名类被编译为<code>Outer$1.class</code>。如果有多个匿名类，Java编译器会将每个匿名类依次命名为<code>Outer$1</code>、<code>Outer$2</code>、<code>Outer$3</code>……</p></li><li><p><code>static nested class</code></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Outer.<span style=color:#a6e22e>StaticNested</span> sn <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Outer.<span style=color:#a6e22e>StaticNested</span>();
</span></span><span style=display:flex><span>        sn.<span style=color:#a6e22e>hello</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Outer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> String NAME <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;OUTER&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Outer(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StaticNested</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> Outer.<span style=color:#a6e22e>NAME</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限</p></li></ul></li></ul></li><li><h4 id=classpath和jar><code>classpath</code>和<code>jar</code><a hidden class=anchor aria-hidden=true href=#classpath和jar>#</a></h4><ul><li><pre tabindex=0><code>classpath`是JVM用到的一个环境变量，它用来指示JVM如何搜索`class
</code></pre><ul><li>因Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，要加载一个<code>abc.xyz.Hello</code>的类，应该去哪搜索对应的<code>Hello.class</code>文件</li></ul></li><li><p><code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关</p><ul><li><p>在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>""</code>括起来，可能长这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>C:\work\project1\bin;C:\shared;&#34;D:\My Documents\project1\bin&#34;
</span></span></code></pre></div></li><li><p>在Linux系统上，用<code>:</code>分隔，可能长这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin
</span></span></code></pre></div></li></ul></li><li><p>假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p><ul><li>&lt;当前目录>\abc\xyz\Hello.class</li><li>C:\work\project1\bin\abc\xyz\Hello.class</li><li>C:\shared\abc\xyz\Hello.class</li></ul></li><li><p>在启动JVM时设置<code>classpath</code>才是推荐的做法。实际上就是给<code>java</code>命令传入<code>-classpath</code>参数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello
</span></span></code></pre></div></li><li><p><code>jar</code>包</p><p>有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理；<strong>jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件</strong></p><ul><li><p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的<code>class</code>，就可以把jar包放到<code>classpath</code>中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>java -cp ./hello.jar abc.xyz.Hello
</span></span></code></pre></div><p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类</p></li></ul></li><li><p>如何创建jar包？</p><p>直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功</p><p>假设编译输出的目录结构是这样：</p><pre tabindex=0><code>package_sample
└─ bin
   ├─ hong
   │  └─ Person.class
   │  ming
   │  └─ Person.class
   └─ mr
      └─ jun
         └─ Arrays.class
</code></pre><p>特别注意的是，jar包里的第一层目录，不能是<code>bin</code>，而应该是<code>hong</code>、<code>ming</code>、<code>mr</code></p><p>上面的<strong><code>hello.zip</code>包含有<code>bin</code>目录，说明打包打得有问题</strong>，JVM仍然无法从jar包中查找正确的<code>class</code>，原因是<code>hong.Person</code>必须按<code>hong/Person.class</code>存放，而不是<code>bin/hong/Person.class</code></p></li></ul></li><li><h4 id=class版本><code>class</code>版本<a hidden class=anchor aria-hidden=true href=#class版本>#</a></h4><ul><li><p>Java 8，Java 11，Java 17，是指JDK的版本，也就是JVM的版本</p><p>是<code>java.exe</code>这个程序的版本：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ java -version
</span></span><span style=display:flex><span>java version &#34;17&#34; 2021-09-14 LTS
</span></span></code></pre></div><p>而每个版本的JVM，它能执行的class文件版本也不同。例如，Java 11对应的class文件版本是55，而Java 17对应的class文件版本是61</p></li><li><p><strong>指定编译输出有两种方式</strong></p><ul><li>一种是在<code>javac</code>命令行中用参数<code>--release</code>设置：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ javac --release 11 Main.java
</span></span></code></pre></div><p>参数<code>--release 11</code>表示源码兼容Java 11，编译的class输出版本为Java 11兼容，即class版本55。</p><p>​ 第二种方式是用参数<code>--source</code>指定源码版本，用参数<code>--target</code>指定输出class版本：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>$ javac --source 9 --target 11 Main.java
</span></span></code></pre></div><p>如果使用Java 17的JDK编译，它会把源码视为Java 9兼容版本，并输出class为Java 11兼容版本</p></li><li><p><strong>运行时使用哪个JDK版本，编译时就尽量使用同一版本的JDK编译源码</strong></p></li></ul></li><li><h4 id=模块>模块<a hidden class=anchor aria-hidden=true href=#模块>#</a></h4><ul><li><code>.class</code>文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆<code>.class</code>文件，很不便于管理，所以，<code>jar</code>文件就是<code>class</code>文件的容器</li><li><strong>jar只是用于存放class的容器，它并不关心class之间的依赖</strong><ul><li>如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种**自带“依赖关系”的class容器就是模块**</li></ul></li><li></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/java02/><span class=title>« Prev Page</span><br><span>Java高级</span>
</a><a class=next href=https://zwlzls.github.io/posts/python02/><span class=title>Next Page »</span><br><span>Python高级</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>