<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java中级 | 我的博客</title>
<meta name=keywords content="Java"><meta name=description content='面向对象基础 理解： class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型
instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同
定义class
创建一个类，例如，给这个类命名为Person，就是定义一个class：
class Person { public String name; public int age; } class Book { public String name; public String author; public String isbn; public double price; } 创建实例
定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符
Person ming = new Person(); 区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例
ming.name = "Xiao Ming"; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = "Xiao Hong"; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：
┌──────────────────┐ ming ──────▶│Person instance │ ├──────────────────┤ │name = "Xiao Ming"│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────▶│Person instance │ ├──────────────────┤ │name = "Xiao Hong"│ │age = 15 │ └──────────────────┘ 方法 意义：'><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/java01/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/java01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Java中级"><meta property="og:description" content='面向对象基础 理解： class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型
instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同
定义class
创建一个类，例如，给这个类命名为Person，就是定义一个class：
class Person { public String name; public int age; } class Book { public String name; public String author; public String isbn; public double price; } 创建实例
定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符
Person ming = new Person(); 区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例
ming.name = "Xiao Ming"; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = "Xiao Hong"; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：
┌──────────────────┐ ming ──────▶│Person instance │ ├──────────────────┤ │name = "Xiao Ming"│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────▶│Person instance │ ├──────────────────┤ │name = "Xiao Hong"│ │age = 15 │ └──────────────────┘ 方法 意义：'><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/java01/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-22T22:05:54+08:00"><meta property="article:modified_time" content="2025-01-22T22:05:54+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java中级"><meta name=twitter:description content='面向对象基础 理解： class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型
instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同
定义class
创建一个类，例如，给这个类命名为Person，就是定义一个class：
class Person { public String name; public int age; } class Book { public String name; public String author; public String isbn; public double price; } 创建实例
定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符
Person ming = new Person(); 区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例
ming.name = "Xiao Ming"; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = "Xiao Hong"; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：
┌──────────────────┐ ming ──────▶│Person instance │ ├──────────────────┤ │name = "Xiao Ming"│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────▶│Person instance │ ├──────────────────┤ │name = "Xiao Hong"│ │age = 15 │ └──────────────────┘ 方法 意义：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Java中级","item":"https://zwlzls.github.io/posts/java01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java中级","name":"Java中级","description":"面向对象基础 理解： class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型\ninstance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同\n定义class\n创建一个类，例如，给这个类命名为Person，就是定义一个class：\nclass Person { public String name; public int age; } class Book { public String name; public String author; public String isbn; public double price; } 创建实例\n定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符\nPerson ming = new Person(); 区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例\nming.name = \u0026#34;Xiao Ming\u0026#34;; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = \u0026#34;Xiao Hong\u0026#34;; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：\n┌──────────────────┐ ming ──────▶│Person instance │ ├──────────────────┤ │name = \u0026#34;Xiao Ming\u0026#34;│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────▶│Person instance │ ├──────────────────┤ │name = \u0026#34;Xiao Hong\u0026#34;│ │age = 15 │ └──────────────────┘ 方法 意义：","keywords":["Java"],"articleBody":"面向对象基础 理解： class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型\ninstance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同\n定义class\n创建一个类，例如，给这个类命名为Person，就是定义一个class：\nclass Person { public String name; public int age; } class Book { public String name; public String author; public String isbn; public double price; } 创建实例\n定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符\nPerson ming = new Person(); 区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例\nming.name = \"Xiao Ming\"; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = \"Xiao Hong\"; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：\n┌──────────────────┐ ming ──────▶│Person instance │ ├──────────────────┤ │name = \"Xiao Ming\"│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────▶│Person instance │ ├──────────────────┤ │name = \"Xiao Hong\"│ │age = 15 │ └──────────────────┘ 方法 意义：\n一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性\n外部代码不能直接读取private字段，但可以通过getName()和getAge()间接获取private字段的值\n**调用方法**的语法是实例变量.方法名(参数);。一个方法调用就是一个语句，所以不要忘了在末尾加;\nming.setName(\"Xiao Ming\"); 定义方法\n修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值; } 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return\n定义private方法的理由是内部方法是可以调用private方法的\nthis变量\n在方法内部，可以使用一个隐含的变量this，它始终指向当前实例\n如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this：\nclass Person { private String name; public void setName(String name) { this.name = name; // 前面的this不可少，少了就变成局部变量name了 } } 方法参数\n包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。\nclass Person { ... public void setNameAndAge(String name, int age) { ... } } 可变参数\n可变参数用类型...定义，可变参数相当于数组类型：\nclass Group { private String[] names; public void setNames(String... names) { this.names = names; } } 上面的setNames()就定义了一个可变参数。调用时，可以这么写：\nGroup g = new Group(); g.setNames(\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"); // 传入3个String g.setNames(\"Xiao Ming\", \"Xiao Hong\"); // 传入2个String g.setNames(\"Xiao Ming\"); // 传入1个String g.setNames(); // 传入0个String 参数绑定\n基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响\n// 基本类型参数绑定 public class Main { public static void main(String[] args) { Person p = new Person(); int n = 15; // n的值为15 p.setAge(n); // 传入n的值 System.out.println(p.getAge()); // 15 n = 20; // n的值改为20 System.out.println(p.getAge()); // 15 } } class Person { private int age; public int getAge() { return this.age; } public void setAge(int age) { this.age = age; } } 引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）\n// 引用类型参数绑定 public class Main { public static void main(String[] args) { Person p = new Person(); String[] fullname = new String[] { \"Homer\", \"Simpson\" }; p.setName(fullname); // 传入fullname数组 System.out.println(p.getName()); // \"Homer Simpson\" fullname[0] = \"Bart\"; // fullname数组的第一个元素修改为\"Bart\" System.out.println(p.getName()); // \"Bart Simpson\" } } class Person { private String[] name; public String getName() { return this.name[0] + \" \" + this.name[1]; } public void setName(String[] name) { this.name = name; } } string的\npublic class Main { public static void main(String[] args) { Person p = new Person(); String bob = \"Bob\"; p.setName(bob); // 传入bob变量 System.out.println(p.getName()); // \"Bob\" bob = \"Alice\"; // bob改名为Alice System.out.println(p.getName()); // \"Bob\" } } class Person { private String name; public String getName() { return this.name; } public void setName(String name) { this.name = name; } } 构造方法 创建对象实例时就把内部字段全部初始化为合适的值\n// 构造方法 public class Main { public static void main(String[] args) { Person p = new Person(\"Xiao Ming\", 15); System.out.println(p.getName()); System.out.println(p.getAge()); } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } } 默认构造方法\n特别注意的是，如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法：\n// 构造方法 public class Main { public static void main(String[] args) { Person p = new Person(); // 编译错误:找不到这个构造方法 } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } } 既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来：\n// 构造方法 public class Main { public static void main(String[] args) { Person p1 = new Person(\"Xiao Ming\", 15); // 既可以调用带参数的构造方法 Person p2 = new Person(); // 也可以调用无参数构造方法 } } class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; } } 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false：\nclass Person { private String name; // 默认初始化为null private int age; // 默认初始化为0 public Person() { } } 多个构造方法\nclass Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this.name = name; this.age = 12; } public Person() { } } 如果调用new Person(\"Xiao Ming\", 20);，会自动匹配到构造方法public Person(String, int)\n如果调用new Person(\"Xiao Ming\");，会自动匹配到构造方法public Person(String)。\n如果调用new Person();，会自动匹配到构造方法public Person()\n可以改为\nclass Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this(name, 18); // 调用另一个构造方法Person(String, int) } public Person() { this(\"Unnamed\"); // 调用另一个构造方法Person(String) } } 方法重载 有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法\nclass Hello { public void hello() { System.out.println(\"Hello, world!\"); } public void hello(String name) { System.out.println(\"Hello, \" + name + \"!\"); } public void hello(String name, int age) { if (age \u003c 18) { System.out.println(\"Hi, \" + name + \"!\"); } else { System.out.println(\"Hello, \" + name + \"!\"); } } } 这种方法名相同，但各自的参数不同，称为方法重载（Overload）\n重载目的：功能类似的方法使用同一名字，更容易记住，调用起来更简单\n继承 可以复用代码\nclass Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...} } class Student extends Person { // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() { … } public void setScore(int score) { … } } 子类自动获得了父类的所有字段，严禁定义与父类重名的字段！\nprtected\n子类无法访问父类的private字段或者private方法。\n例如，Student类就无法访问Person类的name和age字段：\nclass Person { private String name; private int age; } class Student extends Person { public String hello() { return \"Hello, \" + name; // 编译错误：无法访问name字段 } } 让子类可以访问父类的字段，我们需要把private改为protected\n用protected修饰的字段可以被子类访问：\nclass Person { protected String name; protected int age; } class Student extends Person { public String hello() { return \"Hello, \" + name; // OK! } } super\nsuper关键字表示父类（超类）。子类引用父类的字段时，可用super.fieldName\npublic class Main { public static void main(String[] args) { Student s = new Student(\"Xiao Ming\", 12, 89); } } class Person { protected String name; protected int age; public Person(String name, int age) { this.name = name; this.age = age; } } class Student extends Person { protected int score; public Student(String name, int age, int score) { this.score = score; } } 以上运行就会失误\n解决方法是调用Person类存在的某个构造方法。例如：\nclass Student extends Person { protected int score; public Student(String name, int age, int score) { super(name, age); // 调用父类的构造方法Person(String, int) this.score = score; } } 阻止继承\n只要某个class没有final修饰符，那么任何类都可以从该class继承\nJava 15开始，允许使用sealed修饰class，并通过permits明确写出能够从该class继承的子类名称\n例如，定义一个Shape类：\npublic sealed class Shape permits Rect, Circle, Triangle { ... } 上述Shape类就是一个sealed类，它只允许指定的3个类继承它。如果写：\npublic final class Rect extends Shape {...} 是没问题的，因为Rect出现在Shape的permits列表中。但是，如果定义一个Ellipse就会报错：\npublic final class Ellipse extends Shape {...} // Compile error: class is not allowed to extend sealed class: Shape 向上转型\n把一个子类类型安全地变为父类类型的赋值，被称为向上转型\n向上转型实际上是把一个子类型安全地变为更加抽象的父类型：\nStudent s = new Student(); Person p = s; // upcasting, ok Object o1 = p; // upcasting, ok Object o2 = s; // upcasting, ok 向下转型\n把一个父类类型强制转型为子类类型，就是向下转型\nPerson p1 = new Student(); // upcasting, ok Person p2 = new Person(); Student s1 = (Student) p1; // ok Student s2 = (Student) p2; // runtime error! ClassCastException! instanceof判断一个变量所指向的实例是否指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false。\n利用instanceof，在向下转型前可以先判断：\nPerson p = new Student(); if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功 } 多态 继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为重写\n方法名相同，方法参数相同，但方法返回值不同，也是不同的方法\nJava的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型\n多态的特性就是，运行期才能动态决定调用的子类方法\npublic class Main { public static void main(String[] args) { // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes = new Income[] { new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) }; System.out.println(totalTax(incomes)); } public static double totalTax(Income... incomes) { double total = 0; for (Income income: incomes) { total = total + income.getTax(); } return total; } } class Income { protected double income; public Income(double income) { this.income = income; } public double getTax() { return income * 0.1; // 税率10% } } class Salary extends Income { public Salary(double income) { super(income); } @Override public double getTax() { if (income \u003c= 5000) { return 0; } return (income - 5000) * 0.2; } } class StateCouncilSpecialAllowance extends Income { public StateCouncilSpecialAllowance(double income) { super(income); } @Override public double getTax() { return 0; } } 重写Object方法\n因为所有的class最终都继承自Object，而Object定义了几个重要的方法：\ntoString()：把instance输出为String equals()：判断两个instance是否逻辑相等 hashCode()：计算一个instance的哈希值 class Person { ... // 显示更有意义的字符串: @Override public String toString() { return \"Person:name=\" + name; } // 比较是否相等: @Override public boolean equals(Object o) { // 当且仅当o为Person类型: if (o instanceof Person) { Person p = (Person) o; // 并且name字段相同时，返回true: return this.name.equals(p.name); } return false; } // 计算hash: @Override public int hashCode() { return this.name.hashCode(); } } 调用super\n在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用\nclass Person { protected String name; public String hello() { return \"Hello, \" + name; } } class Student extends Person { @Override public String hello() { // 调用父类的hello()方法: return super.hello() + \"!\"; } } final\n用final修饰的方法不能被Override\nclass Person { protected String name; public final String hello() { return \"Hello, \" + name; } } class Student extends Person { // compile error: 不允许覆写 @Override public String hello() { } } 用final修饰的类不能被继承\nfinal class Person { protected String name; } // compile error: 不允许继承自Person class Student extends Person { } 用final修饰的字段在初始化后不能被修改\nclass Person { public final String name = \"Unamed\"; } Person p = new Person(); p.name = \"New Name\"; // compile error! 可在构造方法中初始化final字段：\nclass Person { public final String name; public Person(String name) { this.name = name; } } 抽象类 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，可以把父类的方法声明为抽象方法：\nclass Person { public abstract void run();//无法编译`Person`类 } 方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。Person类也无法被实例化\n必须把Person类本身也声明为abstract，才能正确编译它：\nabstract class Person { public abstract void run(); } 使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类：\nPerson p = new Person(); // 编译错误 抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错\n抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力\n接口 一个抽象类没有字段，所有方法全部都是抽象方法：\nabstract class Person { public abstract void run(); public abstract String getName(); } 可以把该抽象类改写为接口：interface。\ninterface Person { void run(); String getName(); } 接口定义的所有方法默认都是public abstract的，这两个修饰符不需要写出来\n当一个具体的class去实现一个interface时，使用implements关键字\nclass Student implements Person { private String name; public Student(String name) { this.name = name; } @Override public void run() { System.out.println(this.name + \" run\"); } @Override public String getName() { return this.name; } } 接口继承\ninterface继承自interface使用extends，它相当于扩展了接口的方法\ninterface Hello { void hello(); } interface Person extends Hello { void run(); String getName(); } Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口\ndefault方法\n// interface public class Main { public static void main(String[] args) { Person p = new Student(\"Xiao Ming\"); p.run();//Xiao Ming run } } interface Person { String getName(); default void run() { System.out.println(getName() + \" run\"); } } class Student implements Person { private String name; public Student(String name) { this.name = name; } public String getName() { return this.name; } } default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类; 如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法\n静态字段和静态方法 class中定义的字段，我们称之为实例字段，特点是，每个实例都有独立的字段，各个实例的同名字段互不影响\n用static修饰的字段，称为静态字段，只有一个共享“空间”，所有实例都会共享该字段\npublic class Main { public static void main(String[] args) { Person ming = new Person(\"Xiao Ming\", 12); Person hong = new Person(\"Xiao Hong\", 15); ming.number = 88; System.out.println(hong.number); hong.number = 99; System.out.println(ming.number); } } class Person { public String name; public int age; public static int number; public Person(String name, int age) { this.name = name; this.age = age; } } 推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段\nPerson.number = 99; System.out.println(Person.number); ","wordCount":"1668","inLanguage":"en","datePublished":"2025-01-22T22:05:54+08:00","dateModified":"2025-01-22T22:05:54+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/java01/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Java中级</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e5%9f%ba%e7%a1%80 aria-label=面向对象基础>面向对象基础</a><ul><li><a href=#%e7%90%86%e8%a7%a3 aria-label=理解：>理解：</a></li><li><a href=#%e6%96%b9%e6%b3%95 aria-label=方法>方法</a></li><li><a href=#%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95 aria-label=构造方法>构造方法</a></li><li><a href=#%e6%96%b9%e6%b3%95%e9%87%8d%e8%bd%bd aria-label=方法重载>方法重载</a></li><li><a href=#%e7%bb%a7%e6%89%bf aria-label=继承>继承</a></li><li><a href=#%e5%a4%9a%e6%80%81 aria-label=多态>多态</a></li><li><a href=#%e6%8a%bd%e8%b1%a1%e7%b1%bb aria-label=抽象类>抽象类</a></li><li><a href=#%e6%8e%a5%e5%8f%a3 aria-label=接口>接口</a></li><li><a href=#%e9%9d%99%e6%80%81%e5%ad%97%e6%ae%b5%e5%92%8c%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95 aria-label=静态字段和静态方法>静态字段和静态方法</a></li></ul></li></ul></div></details></div><div class=post-content><h3 id=面向对象基础>面向对象基础<a hidden class=anchor aria-hidden=true href=#面向对象基础>#</a></h3><ul><li><h4 id=理解>理解：<a hidden class=anchor aria-hidden=true href=#理解>#</a></h4><ul><li><p>class是一种对象模版，定义了如何创建实例，class本身就是一种数据类型</p></li><li><p>instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同</p></li><li><p>定义class</p><ul><li><p>创建一个类，例如，给这个类命名为<code>Person</code>，就是定义一个<code>class</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Book</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String author;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String isbn;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> price;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>创建实例</p><ul><li><p><strong>定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person ming <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span></code></pre></div><p><strong>区分<code>Person ming</code>是定义<code>Person</code>类型的变量<code>ming</code>，而<code>new Person()</code>是创建<code>Person</code>实例</strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ming.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Xiao Ming&#34;</span>; <span style=color:#75715e>// 对字段name赋值</span>
</span></span><span style=display:flex><span>ming.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> 12; <span style=color:#75715e>// 对字段age赋值</span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(ming.<span style=color:#a6e22e>name</span>); <span style=color:#75715e>// 访问字段name</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Person hong <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>hong.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Xiao Hong&#34;</span>;
</span></span><span style=display:flex><span>hong.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> 15;
</span></span></code></pre></div><p>上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：</p><pre tabindex=0><code>            ┌──────────────────┐
ming ──────▶│Person instance   │
            ├──────────────────┤
            │name = &#34;Xiao Ming&#34;│
            │age = 12          │
            └──────────────────┘
            ┌──────────────────┐
hong ──────▶│Person instance   │
            ├──────────────────┤
            │name = &#34;Xiao Hong&#34;│
            │age = 15          │
            └──────────────────┘
</code></pre></li></ul></li></ul></li><li><h4 id=方法>方法<a hidden class=anchor aria-hidden=true href=#方法>#</a></h4><ul><li><p>意义：</p><ul><li><p>一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性</p><p>外部代码不能直接读取<code>private</code>字段，但可以通过<code>getName()</code>和<code>getAge()</code>间接获取<code>private</code>字段的值</p></li><li><p>**调用方法**的语法是<code>实例变量.方法名(参数);</code>。一个方法调用就是一个语句，所以不要忘了在末尾加<code>;</code></p><pre tabindex=0><code>ming.setName(&#34;Xiao Ming&#34;);
</code></pre></li></ul></li><li><p>定义方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>修饰符 方法返回类型 <span style=color:#a6e22e>方法名</span>(方法参数列表) {
</span></span><span style=display:flex><span>    若干方法语句;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> 方法返回值;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>方法返回值通过<code>return</code>语句实现，如果没有返回值，返回类型设置为<code>void</code>，可以省略<code>return</code></p></li><li><p>定义<code>private</code>方法的理由是内部方法是可以调用<code>private</code>方法的</p></li><li><p><code>this</code>变量</p><ul><li><p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例</p></li><li><p>如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上<code>this</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name; <span style=color:#75715e>// 前面的this不可少，少了就变成局部变量name了</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>方法参数</p><ul><li><p>包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setNameAndAge</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>可变参数</p><ul><li><p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Group</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String<span style=color:#f92672>[]</span> names;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setNames</span>(String... names) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>names</span> <span style=color:#f92672>=</span> names;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>上面的<code>setNames()</code>就定义了一个可变参数。调用时，可以这么写：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Group g <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Group();
</span></span><span style=display:flex><span>g.<span style=color:#a6e22e>setNames</span>(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>, <span style=color:#e6db74>&#34;Xiao Hong&#34;</span>, <span style=color:#e6db74>&#34;Xiao Jun&#34;</span>); <span style=color:#75715e>// 传入3个String</span>
</span></span><span style=display:flex><span>g.<span style=color:#a6e22e>setNames</span>(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>, <span style=color:#e6db74>&#34;Xiao Hong&#34;</span>); <span style=color:#75715e>// 传入2个String</span>
</span></span><span style=display:flex><span>g.<span style=color:#a6e22e>setNames</span>(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>); <span style=color:#75715e>// 传入1个String</span>
</span></span><span style=display:flex><span>g.<span style=color:#a6e22e>setNames</span>(); <span style=color:#75715e>// 传入0个String</span>
</span></span></code></pre></div></li></ul></li><li><p>参数绑定</p><ul><li><p><strong>基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 基本类型参数绑定</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> 15; <span style=color:#75715e>// n的值为15</span>
</span></span><span style=display:flex><span>        p.<span style=color:#a6e22e>setAge</span>(n); <span style=color:#75715e>// 传入n的值</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getAge</span>()); <span style=color:#75715e>// 15</span>
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> 20; <span style=color:#75715e>// n的值改为20</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getAge</span>()); <span style=color:#75715e>// 15</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setAge</span>(<span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 引用类型参数绑定</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>        String<span style=color:#f92672>[]</span> fullname <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String<span style=color:#f92672>[]</span> { <span style=color:#e6db74>&#34;Homer&#34;</span>, <span style=color:#e6db74>&#34;Simpson&#34;</span> };
</span></span><span style=display:flex><span>        p.<span style=color:#a6e22e>setName</span>(fullname); <span style=color:#75715e>// 传入fullname数组</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getName</span>()); <span style=color:#75715e>// &#34;Homer Simpson&#34;</span>
</span></span><span style=display:flex><span>        fullname<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Bart&#34;</span>; <span style=color:#75715e>// fullname数组的第一个元素修改为&#34;Bart&#34;</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getName</span>()); <span style=color:#75715e>// &#34;Bart Simpson&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String<span style=color:#f92672>[]</span> name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span>(String<span style=color:#f92672>[]</span> name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>string</code>的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>        String bob <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Bob&#34;</span>;
</span></span><span style=display:flex><span>        p.<span style=color:#a6e22e>setName</span>(bob); <span style=color:#75715e>// 传入bob变量</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getName</span>()); <span style=color:#75715e>// &#34;Bob&#34;</span>
</span></span><span style=display:flex><span>        bob <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Alice&#34;</span>; <span style=color:#75715e>// bob改名为Alice</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getName</span>()); <span style=color:#75715e>// &#34;Bob&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=构造方法>构造方法<a hidden class=anchor aria-hidden=true href=#构造方法>#</a></h4><ul><li><p><strong>创建对象实例时就把内部字段全部初始化为合适的值</strong></p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 构造方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>, 15);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(p.<span style=color:#a6e22e>getAge</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>默认构造方法</p><ul><li><p>特别注意的是，如果我们自定义了一个构造方法，那么，编译器就<em>不再</em>自动创建默认构造方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 构造方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(); <span style=color:#75715e>// 编译错误:找不到这个构造方法</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 构造方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>, 15); <span style=color:#75715e>// 既可以调用带参数的构造方法</span>
</span></span><span style=display:flex><span>        Person p2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(); <span style=color:#75715e>// 也可以调用无参数构造方法</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>没有在构造方法中初始化字段时，引用类型的字段默认是<code>null</code>，数值类型的字段用默认值，<code>int</code>类型默认值是<code>0</code>，布尔类型默认值是<code>false</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name; <span style=color:#75715e>// 默认初始化为null</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age; <span style=color:#75715e>// 默认初始化为0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p>多个构造方法</p><ul><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> 12;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果调用<code>new Person("Xiao Ming", 20);</code>，会自动匹配到构造方法<code>public Person(String, int)</code></p><p>如果调用<code>new Person("Xiao Ming");</code>，会自动匹配到构造方法<code>public Person(String)</code>。</p><p>如果调用<code>new Person();</code>，会自动匹配到构造方法<code>public Person()</code></p></li><li><p>可以改为</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>(name, 18); <span style=color:#75715e>// 调用另一个构造方法Person(String, int)</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>(<span style=color:#e6db74>&#34;Unnamed&#34;</span>); <span style=color:#75715e>// 调用另一个构造方法Person(String)</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=方法重载>方法重载<a hidden class=anchor aria-hidden=true href=#方法重载>#</a></h4><ul><li><p><strong>有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成<em>同名</em>方法</strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Hello, world!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>(String name) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (age <span style=color:#f92672>&lt;</span> 18) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Hi, &#34;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;!&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;!&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>这种方法名相同，但各自的参数不同，称为方法重载（<code>Overload</code>）</strong></p><p><strong>重载目的：功能类似的方法使用同一名字，更容易记住，调用起来更简单</strong></p></li></ul></li><li><h4 id=继承>继承<a hidden class=anchor aria-hidden=true href=#继承>#</a></h4><ul><li><p>可以复用代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {...}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span>(String name) {...}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() {...}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setAge</span>(<span style=color:#66d9ef>int</span> age) {...}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 不要重复name和age字段/方法,</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 只需要定义新增score字段/方法:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> score;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getScore</span>() { <span style=color:#960050;background-color:#1e0010>…</span> }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setScore</span>(<span style=color:#66d9ef>int</span> score) { <span style=color:#960050;background-color:#1e0010>…</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</p></li><li><p><code>prtected</code></p><p><strong>子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。</strong></p><p>例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> name; <span style=color:#75715e>// 编译错误：无法访问name字段</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code></strong></p><p>用<code>protected</code>修饰的字段可以被子类访问：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> name; <span style=color:#75715e>// OK!</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>super</code></p><p><strong><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可用<code>super.fieldName</code></strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Student s <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>, 12, 89);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>int</span> score;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Student</span>(String name, <span style=color:#66d9ef>int</span> age, <span style=color:#66d9ef>int</span> score) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>score</span> <span style=color:#f92672>=</span> score;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>以上运行就会失误</strong></p><p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>int</span> score;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Student</span>(String name, <span style=color:#66d9ef>int</span> age, <span style=color:#66d9ef>int</span> score) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(name, age); <span style=color:#75715e>// 调用父类的构造方法Person(String, int)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>score</span> <span style=color:#f92672>=</span> score;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>阻止继承</p><ul><li><p><strong>只要某个class没有<code>final</code>修饰符，那么任何类都可以从该class继承</strong></p></li><li><p><strong>Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称</strong></p><p>例如，定义一个<code>Shape</code>类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Shape</span> permits Rect, Circle, Triangle {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述<code>Shape</code>类就是一个<code>sealed</code>类，它只允许指定的3个类继承它。如果写：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Rect</span> <span style=color:#66d9ef>extends</span> Shape {...}
</span></span></code></pre></div><p>是没问题的，因为<code>Rect</code>出现在<code>Shape</code>的<code>permits</code>列表中。但是，如果定义一个<code>Ellipse</code>就会报错：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ellipse</span> <span style=color:#66d9ef>extends</span> Shape {...}
</span></span><span style=display:flex><span><span style=color:#75715e>// Compile error: class is not allowed to extend sealed class: Shape</span>
</span></span></code></pre></div></li></ul></li><li><p>向上转型</p><ul><li><p><strong>把一个子类类型安全地变为父类类型的赋值，被称为向上转型</strong></p><p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Student s <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student();
</span></span><span style=display:flex><span>Person p <span style=color:#f92672>=</span> s; <span style=color:#75715e>// upcasting, ok</span>
</span></span><span style=display:flex><span>Object o1 <span style=color:#f92672>=</span> p; <span style=color:#75715e>// upcasting, ok</span>
</span></span><span style=display:flex><span>Object o2 <span style=color:#f92672>=</span> s; <span style=color:#75715e>// upcasting, ok</span>
</span></span></code></pre></div></li></ul></li><li><p>向下转型</p><ul><li><p>把一个父类类型强制转型为子类类型，就是向下转型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person p1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student(); <span style=color:#75715e>// upcasting, ok</span>
</span></span><span style=display:flex><span>Person p2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>Student s1 <span style=color:#f92672>=</span> (Student) p1; <span style=color:#75715e>// ok</span>
</span></span><span style=display:flex><span>Student s2 <span style=color:#f92672>=</span> (Student) p2; <span style=color:#75715e>// runtime error! ClassCastException!</span>
</span></span></code></pre></div></li><li><p><code>instanceof</code>判断一个变量所指向的实例是否指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p><p>利用<code>instanceof</code>，在向下转型前可以先判断：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student();
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (p <span style=color:#66d9ef>instanceof</span> Student) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 只有判断成功才会向下转型:</span>
</span></span><span style=display:flex><span>    Student s <span style=color:#f92672>=</span> (Student) p; <span style=color:#75715e>// 一定会成功</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=多态>多态<a hidden class=anchor aria-hidden=true href=#多态>#</a></h4><ul><li><p><strong>继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为重写</strong></p><p><strong>方法名相同，方法参数相同，但方法返回值不同，也是不同的方法</strong></p><p><strong>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型</strong></p></li><li><p><strong>多态的特性就是，运行期才能动态决定调用的子类方法</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span>
</span></span><span style=display:flex><span>        Income<span style=color:#f92672>[]</span> incomes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Income<span style=color:#f92672>[]</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Income(3000),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Salary(7500),
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> StateCouncilSpecialAllowance(15000)
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(totalTax(incomes));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>totalTax</span>(Income... incomes) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> total <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Income income: incomes) {
</span></span><span style=display:flex><span>            total <span style=color:#f92672>=</span> total <span style=color:#f92672>+</span> income.<span style=color:#a6e22e>getTax</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> total;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Income</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>double</span> income;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Income</span>(<span style=color:#66d9ef>double</span> income) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>income</span> <span style=color:#f92672>=</span> income;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getTax</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> income <span style=color:#f92672>*</span> 0.<span style=color:#a6e22e>1</span>; <span style=color:#75715e>// 税率10%</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Salary</span> <span style=color:#66d9ef>extends</span> Income {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Salary</span>(<span style=color:#66d9ef>double</span> income) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(income);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getTax</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (income <span style=color:#f92672>&lt;=</span> 5000) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 0;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (income <span style=color:#f92672>-</span> 5000) <span style=color:#f92672>*</span> 0.<span style=color:#a6e22e>2</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StateCouncilSpecialAllowance</span> <span style=color:#66d9ef>extends</span> Income {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>StateCouncilSpecialAllowance</span>(<span style=color:#66d9ef>double</span> income) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(income);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getTax</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>重写<code>Object</code>方法</p><p><strong>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</strong></p><ul><li><code>toString()</code>：把instance输出为<code>String</code></li><li><code>equals()</code>：判断两个instance是否逻辑相等</li><li><code>hashCode()</code>：计算一个instance的哈希值</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 显示更有意义的字符串:</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Person:name=&#34;</span> <span style=color:#f92672>+</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 比较是否相等:</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>equals</span>(Object o) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当且仅当o为Person类型:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (o <span style=color:#66d9ef>instanceof</span> Person) {
</span></span><span style=display:flex><span>            Person p <span style=color:#f92672>=</span> (Person) o;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 并且name字段相同时，返回true:</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>.<span style=color:#a6e22e>equals</span>(p.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 计算hash:</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hashCode</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>.<span style=color:#a6e22e>hashCode</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>调用<code>super</code></p><p><strong>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用父类的hello()方法:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>hello</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;!&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><code>final</code></p><ul><li><p>用<code>final</code>修饰的方法不能被<code>Override</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> String <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// compile error: 不允许覆写</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>hello</span>() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>用<code>final</code>修饰的类不能被继承</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> String name;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// compile error: 不允许继承自Person</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>extends</span> Person {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>用<code>final</code>修饰的字段在初始化后不能被修改</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> String name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Unamed&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();
</span></span><span style=display:flex><span>p.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;New Name&#34;</span>; <span style=color:#75715e>// compile error!</span>
</span></span></code></pre></div><p><strong>可在构造方法中初始化final字段：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li></ul></li><li><h4 id=抽象类>抽象类<a hidden class=anchor aria-hidden=true href=#抽象类>#</a></h4><ul><li><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，<strong>目的是让子类去覆写它，可以把父类的方法声明为抽象方法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>();<span style=color:#75715e>//无法编译`Person`类</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。<code>Person</code>类也无法被实例化</p><p>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(); <span style=color:#75715e>// 编译错误</span>
</span></span></code></pre></div><p><strong>抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错</strong></p></li><li><p><strong>抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力</strong></p></li></ul></li><li><h4 id=接口>接口<a hidden class=anchor aria-hidden=true href=#接口>#</a></h4><ul><li><p><strong>一个抽象类没有字段，所有方法全部都是抽象方法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> String <span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以把该抽象类改写为接口：<code>interface</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>接口定义的所有方法默认都是<code>public abstract</code>的，这两个修饰符不需要写出来</strong></p></li><li><p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，使用<code>implements</code>关键字</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>implements</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Student</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; run&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>接口继承</p><p><strong><code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>extends</span> Hello {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Person</code>接口现在实际上有3个抽象方法签名，其中一个来自继承的<code>Hello</code>接口</p></li><li><p><code>default</code>方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// interface</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Student(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>);
</span></span><span style=display:flex><span>        p.<span style=color:#a6e22e>run</span>();<span style=color:#75715e>//Xiao Ming run</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(getName() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; run&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>implements</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Student</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类;
如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法</p></li></ul></li><li><h4 id=静态字段和静态方法>静态字段和静态方法<a hidden class=anchor aria-hidden=true href=#静态字段和静态方法>#</a></h4><ul><li><p><strong><code>class</code>中定义的字段，我们称之为实例字段，特点是，每个实例都有独立的字段，各个实例的同名字段互不影响</strong></p></li><li><p><strong>用<code>static</code>修饰的字段，称为静态字段，只有一个共享“空间”，所有实例都会共享该字段</strong></p></li><li><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Person ming <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Xiao Ming&#34;</span>, 12);
</span></span><span style=display:flex><span>        Person hong <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;Xiao Hong&#34;</span>, 15);
</span></span><span style=display:flex><span>        ming.<span style=color:#a6e22e>number</span> <span style=color:#f92672>=</span> 88;
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(hong.<span style=color:#a6e22e>number</span>);
</span></span><span style=display:flex><span>        hong.<span style=color:#a6e22e>number</span> <span style=color:#f92672>=</span> 99;
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(ming.<span style=color:#a6e22e>number</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> number;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Person</span>(String name, <span style=color:#66d9ef>int</span> age) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>推荐用类名来访问静态字段。可以把静态字段理解为描述<code>class</code>本身的字段</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Person.<span style=color:#a6e22e>number</span> <span style=color:#f92672>=</span> 99;
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Person.<span style=color:#a6e22e>number</span>);
</span></span></code></pre></div></li><li></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/java02/><span class=title>« Prev Page</span><br><span>Java02</span>
</a><a class=next href=https://zwlzls.github.io/posts/python02/><span class=title>Next Page »</span><br><span>Python高级</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>