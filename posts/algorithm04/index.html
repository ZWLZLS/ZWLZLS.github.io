<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>算法总结 | 我的博客</title>
<meta name=keywords content="算法"><meta name=description content="以前写的总结 框架思维：
数据结构的存储方式：数组和链表 任何数据结构无非遍历和访问，在不同的场合高效增删改查 而遍历分为线性和非线性（for/while和递归） 算法心得：
算法的本质就是无穷举 数组/单链表常用：双指针，二分搜索，滑动窗口，回文子串，前缀和，差分数组 二叉树常用：1.遍历一遍二叉树(递归函数无返回值) 2.分解问题计算答案(递归函数有返回值) 二叉树：
void traverse(TreeNode root) { if (root == null) { return; } // 前序位置 :进入结点的时候 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 :离开结点的时候 } 层序遍历：竖while横for 链表：双指针
设置虚拟结点，用指针来进行变化，同时新建链表注意指明最后一个结点 回溯算法：
回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」 我们通过保证元素之间的相对顺序来防止出现重复子集&mdash;-用start变量 标记那些元素可以被选择&mdash;&ndash;用used数组 重复元素中找可能解&mdash;-先排序，用num[i]==num[i-1]来减枝 重复元素的全排列&mdash;-先排序，用num[i]==num[i-1]&&!used[i-1]固定相同数值位置来减枝（规则：相同则前一个必走过），且used[i]标记该数值是否被使用 子集/组合问题必须用start，排列问题必用used数组 数组：
双指针
一维前缀和：preSum[i] 记录 nums[0..i-1] 的累加和
二维前缀和：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和 对于前缀和问题：申请新数组范围是n+1，数组实际从索引1开始
差分数组：差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。 后面数据靠前面的差值，diff[i] 就是 nums[i] 和 nums[i-1] 之差 如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可："><meta name=author content><link rel=canonical href=https://zwlzls.github.io/posts/algorithm04/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.b1bb1c7768cbdd79e8258ec7b1dd6e3783e316fcaf65c607a0c60c4947c617ef.css integrity="sha256-sbscd2jL3XnoJY7Hsd1uN4PjFvyvZcYHoMYMSUfGF+8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.30d2332871da51f600f574811c17751e6c862577d450b624f86e2bc8a6e31221.js integrity="sha256-MNIzKHHaUfYA9XSBHBd1HmyGJXfUULYk+G4ryKbjEiE=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://zwlzls.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zwlzls.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zwlzls.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zwlzls.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zwlzls.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.123.0"><link rel=alternate hreflang=en href=https://zwlzls.github.io/posts/algorithm04/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="算法总结"><meta property="og:description" content="以前写的总结 框架思维：
数据结构的存储方式：数组和链表 任何数据结构无非遍历和访问，在不同的场合高效增删改查 而遍历分为线性和非线性（for/while和递归） 算法心得：
算法的本质就是无穷举 数组/单链表常用：双指针，二分搜索，滑动窗口，回文子串，前缀和，差分数组 二叉树常用：1.遍历一遍二叉树(递归函数无返回值) 2.分解问题计算答案(递归函数有返回值) 二叉树：
void traverse(TreeNode root) { if (root == null) { return; } // 前序位置 :进入结点的时候 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 :离开结点的时候 } 层序遍历：竖while横for 链表：双指针
设置虚拟结点，用指针来进行变化，同时新建链表注意指明最后一个结点 回溯算法：
回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」 我们通过保证元素之间的相对顺序来防止出现重复子集&mdash;-用start变量 标记那些元素可以被选择&mdash;&ndash;用used数组 重复元素中找可能解&mdash;-先排序，用num[i]==num[i-1]来减枝 重复元素的全排列&mdash;-先排序，用num[i]==num[i-1]&&!used[i-1]固定相同数值位置来减枝（规则：相同则前一个必走过），且used[i]标记该数值是否被使用 子集/组合问题必须用start，排列问题必用used数组 数组：
双指针
一维前缀和：preSum[i] 记录 nums[0..i-1] 的累加和
二维前缀和：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和 对于前缀和问题：申请新数组范围是n+1，数组实际从索引1开始
差分数组：差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。 后面数据靠前面的差值，diff[i] 就是 nums[i] 和 nums[i-1] 之差 如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可："><meta property="og:type" content="article"><meta property="og:url" content="https://zwlzls.github.io/posts/algorithm04/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-24T13:13:05+08:00"><meta property="article:modified_time" content="2025-02-24T13:13:05+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="算法总结"><meta name=twitter:description content="以前写的总结 框架思维：
数据结构的存储方式：数组和链表 任何数据结构无非遍历和访问，在不同的场合高效增删改查 而遍历分为线性和非线性（for/while和递归） 算法心得：
算法的本质就是无穷举 数组/单链表常用：双指针，二分搜索，滑动窗口，回文子串，前缀和，差分数组 二叉树常用：1.遍历一遍二叉树(递归函数无返回值) 2.分解问题计算答案(递归函数有返回值) 二叉树：
void traverse(TreeNode root) { if (root == null) { return; } // 前序位置 :进入结点的时候 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 :离开结点的时候 } 层序遍历：竖while横for 链表：双指针
设置虚拟结点，用指针来进行变化，同时新建链表注意指明最后一个结点 回溯算法：
回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」 我们通过保证元素之间的相对顺序来防止出现重复子集&mdash;-用start变量 标记那些元素可以被选择&mdash;&ndash;用used数组 重复元素中找可能解&mdash;-先排序，用num[i]==num[i-1]来减枝 重复元素的全排列&mdash;-先排序，用num[i]==num[i-1]&&!used[i-1]固定相同数值位置来减枝（规则：相同则前一个必走过），且used[i]标记该数值是否被使用 子集/组合问题必须用start，排列问题必用used数组 数组：
双指针
一维前缀和：preSum[i] 记录 nums[0..i-1] 的累加和
二维前缀和：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和 对于前缀和问题：申请新数组范围是n+1，数组实际从索引1开始
差分数组：差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。 后面数据靠前面的差值，diff[i] 就是 nums[i] 和 nums[i-1] 之差 如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zwlzls.github.io/posts/"},{"@type":"ListItem","position":2,"name":"算法总结","item":"https://zwlzls.github.io/posts/algorithm04/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"算法总结","name":"算法总结","description":"以前写的总结 框架思维：\n数据结构的存储方式：数组和链表 任何数据结构无非遍历和访问，在不同的场合高效增删改查 而遍历分为线性和非线性（for/while和递归） 算法心得：\n算法的本质就是无穷举 数组/单链表常用：双指针，二分搜索，滑动窗口，回文子串，前缀和，差分数组 二叉树常用：1.遍历一遍二叉树(递归函数无返回值) 2.分解问题计算答案(递归函数有返回值) 二叉树：\nvoid traverse(TreeNode root) { if (root == null) { return; } // 前序位置 :进入结点的时候 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 :离开结点的时候 } 层序遍历：竖while横for 链表：双指针\n设置虚拟结点，用指针来进行变化，同时新建链表注意指明最后一个结点 回溯算法：\n回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」 我们通过保证元素之间的相对顺序来防止出现重复子集\u0026mdash;-用start变量 标记那些元素可以被选择\u0026mdash;\u0026ndash;用used数组 重复元素中找可能解\u0026mdash;-先排序，用num[i]==num[i-1]来减枝 重复元素的全排列\u0026mdash;-先排序，用num[i]==num[i-1]\u0026amp;\u0026amp;!used[i-1]固定相同数值位置来减枝（规则：相同则前一个必走过），且used[i]标记该数值是否被使用 子集/组合问题必须用start，排列问题必用used数组 数组：\n双指针\n一维前缀和：preSum[i] 记录 nums[0..i-1] 的累加和\n二维前缀和：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和 对于前缀和问题：申请新数组范围是n+1，数组实际从索引1开始\n差分数组：差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。 后面数据靠前面的差值，diff[i] 就是 nums[i] 和 nums[i-1] 之差 如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可：","keywords":["算法"],"articleBody":"以前写的总结 框架思维：\n数据结构的存储方式：数组和链表 任何数据结构无非遍历和访问，在不同的场合高效增删改查 而遍历分为线性和非线性（for/while和递归） 算法心得：\n算法的本质就是无穷举 数组/单链表常用：双指针，二分搜索，滑动窗口，回文子串，前缀和，差分数组 二叉树常用：1.遍历一遍二叉树(递归函数无返回值) 2.分解问题计算答案(递归函数有返回值) 二叉树：\nvoid traverse(TreeNode root) { if (root == null) { return; } // 前序位置 :进入结点的时候 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 :离开结点的时候 } 层序遍历：竖while横for 链表：双指针\n设置虚拟结点，用指针来进行变化，同时新建链表注意指明最后一个结点 回溯算法：\n回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」 我们通过保证元素之间的相对顺序来防止出现重复子集—-用start变量 标记那些元素可以被选择—–用used数组 重复元素中找可能解—-先排序，用num[i]==num[i-1]来减枝 重复元素的全排列—-先排序，用num[i]==num[i-1]\u0026\u0026!used[i-1]固定相同数值位置来减枝（规则：相同则前一个必走过），且used[i]标记该数值是否被使用 子集/组合问题必须用start，排列问题必用used数组 数组：\n双指针\n一维前缀和：preSum[i] 记录 nums[0..i-1] 的累加和\n二维前缀和：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和 对于前缀和问题：申请新数组范围是n+1，数组实际从索引1开始\n差分数组：差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。 后面数据靠前面的差值，diff[i] 就是 nums[i] 和 nums[i-1] 之差 如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可：\n链表用指针遍历，可以用坐标来标记数组是否遍历\n滑动窗口无法解决含有负数的数组，前缀和喜欢与HashMap搭配\n递归与树的结合认知\n1.写代码表面有几次就会产生几个树枝，这个思想肯定要有 2.返回值是下一层给上一层的值，因此代码要返回到最顶层（最初层），递归才会结束· 3.递归要有结束标志，也就是递归到最底层时，就开始进行返回（这时会产生有一个虚假层） 4.核心代码是虚假层与倒数第一层的之间的关系 某一层如果不返回的话，就会一直递归（所以要注意空） 5.写代码时就是思考什么时候停止，任意两层如何返回。 递归：\nreturn后，就会进入上一层，进行递归语句的后面语句 链表\nA指向B A.next=B\n左边有next可以控制指针方向，右边有next只是简单的赋值操作\n链表结点建立关系：要用堆去思考 例如下列情况： 对于一：p10先指向一个空间，p11再指向p10的空间,p10又去指向另一个空间p2的 结果：p10,p2同一地址，p11一地址 对于二：p10先指向一个空间，p11再指向p10的空间，p10的下一个空间为p2 结果：p10,p11同一个地址，在共同下一个地址为p2\n**因此情况二才是我们平时刷题希望的结果，**共同指向同一个地址， 改变p10,p11的链表结果，都会去影响另一个\n情况一\t情况二 TreeNode1 p10=new TreeNode1(); TreeNode1 p10=new TreeNode1(); TreeNode1 p11=p10; TreeNode1 p11=p10; p10=p2;\tp10.next=p2; 二叉树方面：\n只要找到建立好树的某个节点，去寻找其左右结点，就会按树的结点编排去找， 因此即使只知道某个结点，也是可以直接读出它的左右节点， 相当于已经在最初时建立好了关系，在任何一个时间读取，之间依旧有关系。 对与字符串问题\n可以使用数组，索引为每个字母，值由具体题定 对于滑动窗口问题：\n就需要两个while循环，循环之间是镶嵌关系 其中一个循环控制右指针，另一个循环控制左指针 在方法中定义的变量一定要有初始值\n数组相邻比大小：可以先从左向右遍历，再从右向左遍历\n对于方法返回值，若只有一层，只要遇到return就会返回，也就函数调用结束，没有遍历完的就不会再管了\n找区间交集个数，只需要排序数组末尾数字 滚动数组的空间复杂度O(1),数组的空间复杂度O(n) 滚动数组赋值时，从后往前赋值\n位运算异或：0与任何数异或为任何数，相同数之间异或值为0，且异或满足交换律，结合律\n数组排序可以有效的解决重复问题,看下一个数组值与当前数组值是否相等 查看相邻数组值是否相等，if(i\u003e0\u0026\u0026arr[i]==arr[i-1])\n对于快排的思考，先找基准：例如以最左边为基准，则找排列从最右边，就是两个的方向要相反，找到基准之后，在进行排列时， 记住：一定要确保每一个整体满足l","wordCount":"153","inLanguage":"en","datePublished":"2025-02-24T13:13:05+08:00","dateModified":"2025-02-24T13:13:05+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zwlzls.github.io/posts/algorithm04/"},"publisher":{"@type":"Organization","name":"我的博客","logo":{"@type":"ImageObject","url":"https://zwlzls.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zwlzls.github.io/ accesskey=h title="我的博客 (Alt + H)">我的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://zwlzls.github.io/categories title=分类><span>分类</span></a></li><li><a href=https://zwlzls.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://zwlzls.github.io/about title=about><span>about</span></a></li><li><a href=https://zwlzls.github.io/archives title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>算法总结</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%a5%e5%89%8d%e5%86%99%e7%9a%84%e6%80%bb%e7%bb%93 aria-label=以前写的总结>以前写的总结</a></li></ul></div></details></div><div class=post-content><h3 id=以前写的总结>以前写的总结<a hidden class=anchor aria-hidden=true href=#以前写的总结>#</a></h3><p><strong>框架思维：</strong></p><ul><li>数据结构的存储方式：数组和链表</li><li>任何数据结构无非遍历和访问，在不同的场合高效增删改查</li><li>而遍历分为线性和非线性（for/while和递归）</li></ul><p><strong>算法心得：</strong></p><ul><li>算法的本质就是无穷举</li><li>数组/单链表常用：双指针，二分搜索，滑动窗口，回文子串，前缀和，差分数组</li><li>二叉树常用：1.遍历一遍二叉树(递归函数<strong>无</strong>返回值) 2.分解问题计算答案(递归函数<strong>有</strong>返回值)</li></ul><p><strong>二叉树：</strong></p><pre tabindex=0><code>void traverse(TreeNode root) {
if (root == null) {
	return; 
} 
// 前序位置 :进入结点的时候
traverse(root.left);
// 中序位置 
traverse(root.right);
// 后序位置  :离开结点的时候
}
</code></pre><ul><li>层序遍历：竖while横for</li></ul><p><strong>链表：双指针</strong></p><ul><li>设置虚拟结点，用指针来进行变化，同时新建链表注意指明最后一个结点</li></ul><p><strong>回溯算法：</strong></p><ul><li><strong>回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」</strong></li><li>我们通过保证元素之间的相对顺序来防止出现重复子集&mdash;-用start变量</li><li>标记那些元素可以被选择&mdash;&ndash;用used数组</li><li>重复元素中找可能解&mdash;-先排序，用<code>num[i]==num[i-1]</code>来减枝</li><li>重复元素的全排列&mdash;-先排序，用<code>num[i]==num[i-1]&&!used[i-1]</code>固定相同数值位置来减枝（规则：相同则前一个必走过），且<code>used[i]</code>标记该数值是否被使用</li><li>子集/组合问题必须用start，排列问题必用used数组</li></ul><p><strong>数组：</strong></p><ul><li><p>双指针</p></li><li><p>一维前缀和：<code>preSum[i]</code> 记录 <code>nums[0..i-1]</code> 的累加和</p></li><li><p>二维前缀和：<code>preSum[i][j]</code> 记录 matrix 中子矩阵 <code>[0, 0, i-1, j-1]</code> 的元素和
对于前缀和问题：申请新数组范围是n+1，数组实际从索引1开始</p></li><li><p>差分数组：<strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong>。
后面数据靠前面的差值，<code>diff[i]</code> 就是 <code>nums[i]</code> 和 <code>nums[i-1]</code> 之差
如果你想对区间 <code>nums[i..j]</code> 的元素全部加 3，那么只需要让 <code>diff[i] += 3</code>，然后再让 <code>diff[j+1] -= 3</code> 即可：</p></li><li><p>链表用指针遍历，可以用坐标来标记数组是否遍历</p></li><li><p>滑动窗口无法解决含有负数的数组，前缀和喜欢与HashMap搭配</p></li></ul><p><strong>递归与树的结合认知</strong></p><ul><li>1.写代码表面有几次就会产生几个树枝，这个思想肯定要有</li><li>2.返回值是下一层给上一层的值，因此代码要返回到最顶层（最初层），递归才会结束·</li><li>3.递归要有结束标志，也就是递归到最底层时，就开始进行返回（这时会产生有一个虚假层）</li><li>4.核心代码是虚假层与倒数第一层的之间的关系</li><li>某一层如果不返回的话，就会一直递归（所以要注意空）</li><li>5.写代码时就是思考什么时候停止，任意两层如何返回。</li></ul><p><strong>递归：</strong></p><ul><li><strong>return后，就会进入上一层，进行递归语句的后面语句</strong></li></ul><p><strong>链表</strong></p><ul><li><p>A指向B A.next=B</p></li><li><p>左边有next可以控制指针方向，右边有next只是简单的赋值操作</p></li><li><p>链表结点建立关系：要用堆去思考
例如下列情况：
对于一：p10先指向一个空间，p11再指向p10的空间,p10又去指向另一个空间p2的
结果：p10,p2同一地址，p11一地址
对于二：p10先指向一个空间，p11再指向p10的空间，p10的下一个空间为p2
结果：p10,p11同一个地址，在共同下一个地址为p2</p></li></ul><blockquote><p>**因此情况二才是我们平时刷题希望的结果，**共同指向同一个地址，
改变p10,p11的链表结果，都会去影响另一个</p></blockquote><pre><code>	情况一											情况二
	TreeNode1 p10=new TreeNode1();  				TreeNode1 p10=new TreeNode1();  
	TreeNode1 p11=p10;  							TreeNode1 p11=p10;  
	p10=p2;											p10.next=p2;
</code></pre><p><strong>二叉树方面：</strong></p><ul><li>只要找到建立好树的某个节点，去寻找其左右结点，就会按树的结点编排去找，
因此即使只知道某个结点，也是可以直接读出它的左右节点，
相当于已经在最初时建立好了关系，在任何一个时间读取，之间依旧有关系。</li></ul><p><strong>对与字符串问题</strong></p><ul><li>可以使用数组，索引为每个字母，值<strong>由具体题定</strong></li></ul><p><strong>对于滑动窗口问题：</strong></p><ul><li>就需要两个while循环，循环之间是镶嵌关系
其中一个循环控制右指针，另一个循环控制左指针</li></ul><blockquote><p>在方法中定义的变量一定要有初始值</p></blockquote><blockquote><p>数组相邻比大小：可以先从左向右遍历，再从右向左遍历</p></blockquote><blockquote><p>对于方法返回值，若只有一层，只要遇到return就会返回，也就函数调用结束，没有遍历完的就不会再管了</p></blockquote><ul><li>找区间交集个数，只需要排序数组末尾数字</li></ul><blockquote><p>滚动数组的空间复杂度O(1),数组的空间复杂度O(n)
<strong>滚动数组赋值时，从后往前赋值</strong></p></blockquote><blockquote><p>位运算异或：0与任何数异或为任何数，相同数之间异或值为0，且异或满足交换律，结合律</p></blockquote><blockquote><p>数组排序可以有效的解决重复问题,看下一个数组值与当前数组值是否相等
查看相邻数组值是否相等，<code>if(i>0&&amp;arr[i]==arr[i-1])</code></p></blockquote><ul><li>对于快排的思考，先找基准：例如以最左边为基准，则找排列从最右边，就是两个的方向要<strong>相反</strong>，找到基准之后，在进行排列时，</li><li><strong>记住：一定要确保每一个整体满足l&lt;r，因此不管是交换时，还是找数字排列都要有前提条件</strong></li><li>每一个<code>l&lt;r</code>的大循环结束，接下来就要思考把基准值放在应放的位置，而<code>l==r</code>就是那个应放的位置，因此一次函数只是将一个</li><li>基准值放在应放的位置，再进行递归，因此就要思考递归结束标志</li></ul><blockquote><p>返回值<code>int[][]</code>和<code>List&lt;List&lt;>></code>是不同的，不能想成一样</p></blockquote><ul><li>集合在思考时写为空集长度为0，而compare在进行数组排列时，不能用>=区分，只能是>,=</li></ul><p>要求区间是开区间，则while中不加==</p><blockquote><p>1.算法的本质就是穷尽举，知道自己的目标什么，找到思考的条件，进行反向思考进行条件所有，
就比如数组时刻要序列不超过范围，二叉树时刻注意是否为空等这些条件，把无数的条件，
进行逆向思考，即可知道所有范围，满足穷举。
2.一定要知道变量和目标，时刻清晰</p></blockquote><ul><li>链表不能用等于直接连接：p1=p2<strong>这是错误</strong>，但指针可以</li><li>实参传值时不能i++,必须i+1</li></ul><p>String类型比较大小：s2.compareTo(s1) len相同逐一比assic码，不同比len</p><p>list集合变字符串：res.toArray(new String[res.size()])</p><p><strong>Pair和Map</strong>
Pair是一对值，Map是集合<br><code>List&lt;Pair&lt;>></code>和<code>Map&lt;></code>类似</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zwlzls.github.io/tags/%E7%AE%97%E6%B3%95/>算法</a></li></ul><nav class=paginav><a class=prev href=https://zwlzls.github.io/posts/algorithm03/><span class=title>« Prev Page</span><br><span>Algorithm03</span>
</a><a class=next href=https://zwlzls.github.io/posts/algorithm02/><span class=title>Next Page »</span><br><span>Algorithm02</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://zwlzls.github.io/>我的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let details=document.getElementsByClassName("details");details=details||[];for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>